
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Role
 * 
 */
export type Role = $Result.DefaultSelection<Prisma.$RolePayload>
/**
 * Model UserRole
 * 
 */
export type UserRole = $Result.DefaultSelection<Prisma.$UserRolePayload>
/**
 * Model City
 * 
 */
export type City = $Result.DefaultSelection<Prisma.$CityPayload>
/**
 * Model Activity
 * 
 */
export type Activity = $Result.DefaultSelection<Prisma.$ActivityPayload>
/**
 * Model Hotel
 * 
 */
export type Hotel = $Result.DefaultSelection<Prisma.$HotelPayload>
/**
 * Model Restaurant
 * 
 */
export type Restaurant = $Result.DefaultSelection<Prisma.$RestaurantPayload>
/**
 * Model Transport
 * 
 */
export type Transport = $Result.DefaultSelection<Prisma.$TransportPayload>
/**
 * Model Trip
 * 
 */
export type Trip = $Result.DefaultSelection<Prisma.$TripPayload>
/**
 * Model TripStop
 * 
 */
export type TripStop = $Result.DefaultSelection<Prisma.$TripStopPayload>
/**
 * Model StopActivity
 * 
 */
export type StopActivity = $Result.DefaultSelection<Prisma.$StopActivityPayload>
/**
 * Model TripBudget
 * 
 */
export type TripBudget = $Result.DefaultSelection<Prisma.$TripBudgetPayload>
/**
 * Model TripMedia
 * 
 */
export type TripMedia = $Result.DefaultSelection<Prisma.$TripMediaPayload>
/**
 * Model TripShare
 * 
 */
export type TripShare = $Result.DefaultSelection<Prisma.$TripSharePayload>
/**
 * Model TripVersion
 * 
 */
export type TripVersion = $Result.DefaultSelection<Prisma.$TripVersionPayload>
/**
 * Model UserSavedDestination
 * 
 */
export type UserSavedDestination = $Result.DefaultSelection<Prisma.$UserSavedDestinationPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model Weather
 * 
 */
export type Weather = $Result.DefaultSelection<Prisma.$WeatherPayload>
/**
 * Model Guide
 * 
 */
export type Guide = $Result.DefaultSelection<Prisma.$GuidePayload>
/**
 * Model Event
 * 
 */
export type Event = $Result.DefaultSelection<Prisma.$EventPayload>
/**
 * Model CostOfLiving
 * 
 */
export type CostOfLiving = $Result.DefaultSelection<Prisma.$CostOfLivingPayload>
/**
 * Model Crowd
 * 
 */
export type Crowd = $Result.DefaultSelection<Prisma.$CrowdPayload>
/**
 * Model Currency
 * 
 */
export type Currency = $Result.DefaultSelection<Prisma.$CurrencyPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.RoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userRole`: Exposes CRUD operations for the **UserRole** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserRoles
    * const userRoles = await prisma.userRole.findMany()
    * ```
    */
  get userRole(): Prisma.UserRoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.city`: Exposes CRUD operations for the **City** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cities
    * const cities = await prisma.city.findMany()
    * ```
    */
  get city(): Prisma.CityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.activity`: Exposes CRUD operations for the **Activity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Activities
    * const activities = await prisma.activity.findMany()
    * ```
    */
  get activity(): Prisma.ActivityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.hotel`: Exposes CRUD operations for the **Hotel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Hotels
    * const hotels = await prisma.hotel.findMany()
    * ```
    */
  get hotel(): Prisma.HotelDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.restaurant`: Exposes CRUD operations for the **Restaurant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Restaurants
    * const restaurants = await prisma.restaurant.findMany()
    * ```
    */
  get restaurant(): Prisma.RestaurantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transport`: Exposes CRUD operations for the **Transport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transports
    * const transports = await prisma.transport.findMany()
    * ```
    */
  get transport(): Prisma.TransportDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.trip`: Exposes CRUD operations for the **Trip** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Trips
    * const trips = await prisma.trip.findMany()
    * ```
    */
  get trip(): Prisma.TripDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tripStop`: Exposes CRUD operations for the **TripStop** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TripStops
    * const tripStops = await prisma.tripStop.findMany()
    * ```
    */
  get tripStop(): Prisma.TripStopDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.stopActivity`: Exposes CRUD operations for the **StopActivity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StopActivities
    * const stopActivities = await prisma.stopActivity.findMany()
    * ```
    */
  get stopActivity(): Prisma.StopActivityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tripBudget`: Exposes CRUD operations for the **TripBudget** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TripBudgets
    * const tripBudgets = await prisma.tripBudget.findMany()
    * ```
    */
  get tripBudget(): Prisma.TripBudgetDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tripMedia`: Exposes CRUD operations for the **TripMedia** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TripMedias
    * const tripMedias = await prisma.tripMedia.findMany()
    * ```
    */
  get tripMedia(): Prisma.TripMediaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tripShare`: Exposes CRUD operations for the **TripShare** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TripShares
    * const tripShares = await prisma.tripShare.findMany()
    * ```
    */
  get tripShare(): Prisma.TripShareDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tripVersion`: Exposes CRUD operations for the **TripVersion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TripVersions
    * const tripVersions = await prisma.tripVersion.findMany()
    * ```
    */
  get tripVersion(): Prisma.TripVersionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userSavedDestination`: Exposes CRUD operations for the **UserSavedDestination** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserSavedDestinations
    * const userSavedDestinations = await prisma.userSavedDestination.findMany()
    * ```
    */
  get userSavedDestination(): Prisma.UserSavedDestinationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.weather`: Exposes CRUD operations for the **Weather** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Weathers
    * const weathers = await prisma.weather.findMany()
    * ```
    */
  get weather(): Prisma.WeatherDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.guide`: Exposes CRUD operations for the **Guide** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Guides
    * const guides = await prisma.guide.findMany()
    * ```
    */
  get guide(): Prisma.GuideDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.event`: Exposes CRUD operations for the **Event** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Events
    * const events = await prisma.event.findMany()
    * ```
    */
  get event(): Prisma.EventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.costOfLiving`: Exposes CRUD operations for the **CostOfLiving** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CostOfLivings
    * const costOfLivings = await prisma.costOfLiving.findMany()
    * ```
    */
  get costOfLiving(): Prisma.CostOfLivingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.crowd`: Exposes CRUD operations for the **Crowd** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Crowds
    * const crowds = await prisma.crowd.findMany()
    * ```
    */
  get crowd(): Prisma.CrowdDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.currency`: Exposes CRUD operations for the **Currency** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Currencies
    * const currencies = await prisma.currency.findMany()
    * ```
    */
  get currency(): Prisma.CurrencyDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.1
   * Query Engine version: c2990dca591cba766e3b7ef5d9e8a84796e47ab7
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Role: 'Role',
    UserRole: 'UserRole',
    City: 'City',
    Activity: 'Activity',
    Hotel: 'Hotel',
    Restaurant: 'Restaurant',
    Transport: 'Transport',
    Trip: 'Trip',
    TripStop: 'TripStop',
    StopActivity: 'StopActivity',
    TripBudget: 'TripBudget',
    TripMedia: 'TripMedia',
    TripShare: 'TripShare',
    TripVersion: 'TripVersion',
    UserSavedDestination: 'UserSavedDestination',
    AuditLog: 'AuditLog',
    Weather: 'Weather',
    Guide: 'Guide',
    Event: 'Event',
    CostOfLiving: 'CostOfLiving',
    Crowd: 'Crowd',
    Currency: 'Currency'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "role" | "userRole" | "city" | "activity" | "hotel" | "restaurant" | "transport" | "trip" | "tripStop" | "stopActivity" | "tripBudget" | "tripMedia" | "tripShare" | "tripVersion" | "userSavedDestination" | "auditLog" | "weather" | "guide" | "event" | "costOfLiving" | "crowd" | "currency"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Role: {
        payload: Prisma.$RolePayload<ExtArgs>
        fields: Prisma.RoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findFirst: {
            args: Prisma.RoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findMany: {
            args: Prisma.RoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          create: {
            args: Prisma.RoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          createMany: {
            args: Prisma.RoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          delete: {
            args: Prisma.RoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          update: {
            args: Prisma.RoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          deleteMany: {
            args: Prisma.RoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RoleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          upsert: {
            args: Prisma.RoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRole>
          }
          groupBy: {
            args: Prisma.RoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleCountArgs<ExtArgs>
            result: $Utils.Optional<RoleCountAggregateOutputType> | number
          }
        }
      }
      UserRole: {
        payload: Prisma.$UserRolePayload<ExtArgs>
        fields: Prisma.UserRoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserRoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserRoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          findFirst: {
            args: Prisma.UserRoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserRoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          findMany: {
            args: Prisma.UserRoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>[]
          }
          create: {
            args: Prisma.UserRoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          createMany: {
            args: Prisma.UserRoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserRoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>[]
          }
          delete: {
            args: Prisma.UserRoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          update: {
            args: Prisma.UserRoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          deleteMany: {
            args: Prisma.UserRoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserRoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserRoleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>[]
          }
          upsert: {
            args: Prisma.UserRoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          aggregate: {
            args: Prisma.UserRoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserRole>
          }
          groupBy: {
            args: Prisma.UserRoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserRoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserRoleCountArgs<ExtArgs>
            result: $Utils.Optional<UserRoleCountAggregateOutputType> | number
          }
        }
      }
      City: {
        payload: Prisma.$CityPayload<ExtArgs>
        fields: Prisma.CityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          findFirst: {
            args: Prisma.CityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          findMany: {
            args: Prisma.CityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>[]
          }
          create: {
            args: Prisma.CityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          createMany: {
            args: Prisma.CityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>[]
          }
          delete: {
            args: Prisma.CityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          update: {
            args: Prisma.CityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          deleteMany: {
            args: Prisma.CityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>[]
          }
          upsert: {
            args: Prisma.CityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          aggregate: {
            args: Prisma.CityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCity>
          }
          groupBy: {
            args: Prisma.CityGroupByArgs<ExtArgs>
            result: $Utils.Optional<CityGroupByOutputType>[]
          }
          count: {
            args: Prisma.CityCountArgs<ExtArgs>
            result: $Utils.Optional<CityCountAggregateOutputType> | number
          }
        }
      }
      Activity: {
        payload: Prisma.$ActivityPayload<ExtArgs>
        fields: Prisma.ActivityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActivityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActivityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          findFirst: {
            args: Prisma.ActivityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActivityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          findMany: {
            args: Prisma.ActivityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>[]
          }
          create: {
            args: Prisma.ActivityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          createMany: {
            args: Prisma.ActivityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActivityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>[]
          }
          delete: {
            args: Prisma.ActivityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          update: {
            args: Prisma.ActivityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          deleteMany: {
            args: Prisma.ActivityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActivityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ActivityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>[]
          }
          upsert: {
            args: Prisma.ActivityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          aggregate: {
            args: Prisma.ActivityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActivity>
          }
          groupBy: {
            args: Prisma.ActivityGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActivityGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActivityCountArgs<ExtArgs>
            result: $Utils.Optional<ActivityCountAggregateOutputType> | number
          }
        }
      }
      Hotel: {
        payload: Prisma.$HotelPayload<ExtArgs>
        fields: Prisma.HotelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HotelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HotelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPayload>
          }
          findFirst: {
            args: Prisma.HotelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HotelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPayload>
          }
          findMany: {
            args: Prisma.HotelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPayload>[]
          }
          create: {
            args: Prisma.HotelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPayload>
          }
          createMany: {
            args: Prisma.HotelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HotelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPayload>[]
          }
          delete: {
            args: Prisma.HotelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPayload>
          }
          update: {
            args: Prisma.HotelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPayload>
          }
          deleteMany: {
            args: Prisma.HotelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HotelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.HotelUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPayload>[]
          }
          upsert: {
            args: Prisma.HotelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPayload>
          }
          aggregate: {
            args: Prisma.HotelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHotel>
          }
          groupBy: {
            args: Prisma.HotelGroupByArgs<ExtArgs>
            result: $Utils.Optional<HotelGroupByOutputType>[]
          }
          count: {
            args: Prisma.HotelCountArgs<ExtArgs>
            result: $Utils.Optional<HotelCountAggregateOutputType> | number
          }
        }
      }
      Restaurant: {
        payload: Prisma.$RestaurantPayload<ExtArgs>
        fields: Prisma.RestaurantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RestaurantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RestaurantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantPayload>
          }
          findFirst: {
            args: Prisma.RestaurantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RestaurantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantPayload>
          }
          findMany: {
            args: Prisma.RestaurantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantPayload>[]
          }
          create: {
            args: Prisma.RestaurantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantPayload>
          }
          createMany: {
            args: Prisma.RestaurantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RestaurantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantPayload>[]
          }
          delete: {
            args: Prisma.RestaurantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantPayload>
          }
          update: {
            args: Prisma.RestaurantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantPayload>
          }
          deleteMany: {
            args: Prisma.RestaurantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RestaurantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RestaurantUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantPayload>[]
          }
          upsert: {
            args: Prisma.RestaurantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantPayload>
          }
          aggregate: {
            args: Prisma.RestaurantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRestaurant>
          }
          groupBy: {
            args: Prisma.RestaurantGroupByArgs<ExtArgs>
            result: $Utils.Optional<RestaurantGroupByOutputType>[]
          }
          count: {
            args: Prisma.RestaurantCountArgs<ExtArgs>
            result: $Utils.Optional<RestaurantCountAggregateOutputType> | number
          }
        }
      }
      Transport: {
        payload: Prisma.$TransportPayload<ExtArgs>
        fields: Prisma.TransportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransportPayload>
          }
          findFirst: {
            args: Prisma.TransportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransportPayload>
          }
          findMany: {
            args: Prisma.TransportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransportPayload>[]
          }
          create: {
            args: Prisma.TransportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransportPayload>
          }
          createMany: {
            args: Prisma.TransportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransportPayload>[]
          }
          delete: {
            args: Prisma.TransportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransportPayload>
          }
          update: {
            args: Prisma.TransportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransportPayload>
          }
          deleteMany: {
            args: Prisma.TransportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TransportUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransportPayload>[]
          }
          upsert: {
            args: Prisma.TransportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransportPayload>
          }
          aggregate: {
            args: Prisma.TransportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransport>
          }
          groupBy: {
            args: Prisma.TransportGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransportGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransportCountArgs<ExtArgs>
            result: $Utils.Optional<TransportCountAggregateOutputType> | number
          }
        }
      }
      Trip: {
        payload: Prisma.$TripPayload<ExtArgs>
        fields: Prisma.TripFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TripFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TripFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripPayload>
          }
          findFirst: {
            args: Prisma.TripFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TripFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripPayload>
          }
          findMany: {
            args: Prisma.TripFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripPayload>[]
          }
          create: {
            args: Prisma.TripCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripPayload>
          }
          createMany: {
            args: Prisma.TripCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TripCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripPayload>[]
          }
          delete: {
            args: Prisma.TripDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripPayload>
          }
          update: {
            args: Prisma.TripUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripPayload>
          }
          deleteMany: {
            args: Prisma.TripDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TripUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TripUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripPayload>[]
          }
          upsert: {
            args: Prisma.TripUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripPayload>
          }
          aggregate: {
            args: Prisma.TripAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrip>
          }
          groupBy: {
            args: Prisma.TripGroupByArgs<ExtArgs>
            result: $Utils.Optional<TripGroupByOutputType>[]
          }
          count: {
            args: Prisma.TripCountArgs<ExtArgs>
            result: $Utils.Optional<TripCountAggregateOutputType> | number
          }
        }
      }
      TripStop: {
        payload: Prisma.$TripStopPayload<ExtArgs>
        fields: Prisma.TripStopFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TripStopFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripStopPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TripStopFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripStopPayload>
          }
          findFirst: {
            args: Prisma.TripStopFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripStopPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TripStopFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripStopPayload>
          }
          findMany: {
            args: Prisma.TripStopFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripStopPayload>[]
          }
          create: {
            args: Prisma.TripStopCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripStopPayload>
          }
          createMany: {
            args: Prisma.TripStopCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TripStopCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripStopPayload>[]
          }
          delete: {
            args: Prisma.TripStopDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripStopPayload>
          }
          update: {
            args: Prisma.TripStopUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripStopPayload>
          }
          deleteMany: {
            args: Prisma.TripStopDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TripStopUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TripStopUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripStopPayload>[]
          }
          upsert: {
            args: Prisma.TripStopUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripStopPayload>
          }
          aggregate: {
            args: Prisma.TripStopAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTripStop>
          }
          groupBy: {
            args: Prisma.TripStopGroupByArgs<ExtArgs>
            result: $Utils.Optional<TripStopGroupByOutputType>[]
          }
          count: {
            args: Prisma.TripStopCountArgs<ExtArgs>
            result: $Utils.Optional<TripStopCountAggregateOutputType> | number
          }
        }
      }
      StopActivity: {
        payload: Prisma.$StopActivityPayload<ExtArgs>
        fields: Prisma.StopActivityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StopActivityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StopActivityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StopActivityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StopActivityPayload>
          }
          findFirst: {
            args: Prisma.StopActivityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StopActivityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StopActivityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StopActivityPayload>
          }
          findMany: {
            args: Prisma.StopActivityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StopActivityPayload>[]
          }
          create: {
            args: Prisma.StopActivityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StopActivityPayload>
          }
          createMany: {
            args: Prisma.StopActivityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StopActivityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StopActivityPayload>[]
          }
          delete: {
            args: Prisma.StopActivityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StopActivityPayload>
          }
          update: {
            args: Prisma.StopActivityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StopActivityPayload>
          }
          deleteMany: {
            args: Prisma.StopActivityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StopActivityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StopActivityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StopActivityPayload>[]
          }
          upsert: {
            args: Prisma.StopActivityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StopActivityPayload>
          }
          aggregate: {
            args: Prisma.StopActivityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStopActivity>
          }
          groupBy: {
            args: Prisma.StopActivityGroupByArgs<ExtArgs>
            result: $Utils.Optional<StopActivityGroupByOutputType>[]
          }
          count: {
            args: Prisma.StopActivityCountArgs<ExtArgs>
            result: $Utils.Optional<StopActivityCountAggregateOutputType> | number
          }
        }
      }
      TripBudget: {
        payload: Prisma.$TripBudgetPayload<ExtArgs>
        fields: Prisma.TripBudgetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TripBudgetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripBudgetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TripBudgetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripBudgetPayload>
          }
          findFirst: {
            args: Prisma.TripBudgetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripBudgetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TripBudgetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripBudgetPayload>
          }
          findMany: {
            args: Prisma.TripBudgetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripBudgetPayload>[]
          }
          create: {
            args: Prisma.TripBudgetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripBudgetPayload>
          }
          createMany: {
            args: Prisma.TripBudgetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TripBudgetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripBudgetPayload>[]
          }
          delete: {
            args: Prisma.TripBudgetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripBudgetPayload>
          }
          update: {
            args: Prisma.TripBudgetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripBudgetPayload>
          }
          deleteMany: {
            args: Prisma.TripBudgetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TripBudgetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TripBudgetUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripBudgetPayload>[]
          }
          upsert: {
            args: Prisma.TripBudgetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripBudgetPayload>
          }
          aggregate: {
            args: Prisma.TripBudgetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTripBudget>
          }
          groupBy: {
            args: Prisma.TripBudgetGroupByArgs<ExtArgs>
            result: $Utils.Optional<TripBudgetGroupByOutputType>[]
          }
          count: {
            args: Prisma.TripBudgetCountArgs<ExtArgs>
            result: $Utils.Optional<TripBudgetCountAggregateOutputType> | number
          }
        }
      }
      TripMedia: {
        payload: Prisma.$TripMediaPayload<ExtArgs>
        fields: Prisma.TripMediaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TripMediaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripMediaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TripMediaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripMediaPayload>
          }
          findFirst: {
            args: Prisma.TripMediaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripMediaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TripMediaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripMediaPayload>
          }
          findMany: {
            args: Prisma.TripMediaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripMediaPayload>[]
          }
          create: {
            args: Prisma.TripMediaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripMediaPayload>
          }
          createMany: {
            args: Prisma.TripMediaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TripMediaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripMediaPayload>[]
          }
          delete: {
            args: Prisma.TripMediaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripMediaPayload>
          }
          update: {
            args: Prisma.TripMediaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripMediaPayload>
          }
          deleteMany: {
            args: Prisma.TripMediaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TripMediaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TripMediaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripMediaPayload>[]
          }
          upsert: {
            args: Prisma.TripMediaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripMediaPayload>
          }
          aggregate: {
            args: Prisma.TripMediaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTripMedia>
          }
          groupBy: {
            args: Prisma.TripMediaGroupByArgs<ExtArgs>
            result: $Utils.Optional<TripMediaGroupByOutputType>[]
          }
          count: {
            args: Prisma.TripMediaCountArgs<ExtArgs>
            result: $Utils.Optional<TripMediaCountAggregateOutputType> | number
          }
        }
      }
      TripShare: {
        payload: Prisma.$TripSharePayload<ExtArgs>
        fields: Prisma.TripShareFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TripShareFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripSharePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TripShareFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripSharePayload>
          }
          findFirst: {
            args: Prisma.TripShareFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripSharePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TripShareFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripSharePayload>
          }
          findMany: {
            args: Prisma.TripShareFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripSharePayload>[]
          }
          create: {
            args: Prisma.TripShareCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripSharePayload>
          }
          createMany: {
            args: Prisma.TripShareCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TripShareCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripSharePayload>[]
          }
          delete: {
            args: Prisma.TripShareDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripSharePayload>
          }
          update: {
            args: Prisma.TripShareUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripSharePayload>
          }
          deleteMany: {
            args: Prisma.TripShareDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TripShareUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TripShareUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripSharePayload>[]
          }
          upsert: {
            args: Prisma.TripShareUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripSharePayload>
          }
          aggregate: {
            args: Prisma.TripShareAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTripShare>
          }
          groupBy: {
            args: Prisma.TripShareGroupByArgs<ExtArgs>
            result: $Utils.Optional<TripShareGroupByOutputType>[]
          }
          count: {
            args: Prisma.TripShareCountArgs<ExtArgs>
            result: $Utils.Optional<TripShareCountAggregateOutputType> | number
          }
        }
      }
      TripVersion: {
        payload: Prisma.$TripVersionPayload<ExtArgs>
        fields: Prisma.TripVersionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TripVersionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripVersionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TripVersionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripVersionPayload>
          }
          findFirst: {
            args: Prisma.TripVersionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripVersionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TripVersionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripVersionPayload>
          }
          findMany: {
            args: Prisma.TripVersionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripVersionPayload>[]
          }
          create: {
            args: Prisma.TripVersionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripVersionPayload>
          }
          createMany: {
            args: Prisma.TripVersionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TripVersionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripVersionPayload>[]
          }
          delete: {
            args: Prisma.TripVersionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripVersionPayload>
          }
          update: {
            args: Prisma.TripVersionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripVersionPayload>
          }
          deleteMany: {
            args: Prisma.TripVersionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TripVersionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TripVersionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripVersionPayload>[]
          }
          upsert: {
            args: Prisma.TripVersionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripVersionPayload>
          }
          aggregate: {
            args: Prisma.TripVersionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTripVersion>
          }
          groupBy: {
            args: Prisma.TripVersionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TripVersionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TripVersionCountArgs<ExtArgs>
            result: $Utils.Optional<TripVersionCountAggregateOutputType> | number
          }
        }
      }
      UserSavedDestination: {
        payload: Prisma.$UserSavedDestinationPayload<ExtArgs>
        fields: Prisma.UserSavedDestinationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserSavedDestinationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSavedDestinationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserSavedDestinationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSavedDestinationPayload>
          }
          findFirst: {
            args: Prisma.UserSavedDestinationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSavedDestinationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserSavedDestinationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSavedDestinationPayload>
          }
          findMany: {
            args: Prisma.UserSavedDestinationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSavedDestinationPayload>[]
          }
          create: {
            args: Prisma.UserSavedDestinationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSavedDestinationPayload>
          }
          createMany: {
            args: Prisma.UserSavedDestinationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserSavedDestinationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSavedDestinationPayload>[]
          }
          delete: {
            args: Prisma.UserSavedDestinationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSavedDestinationPayload>
          }
          update: {
            args: Prisma.UserSavedDestinationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSavedDestinationPayload>
          }
          deleteMany: {
            args: Prisma.UserSavedDestinationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserSavedDestinationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserSavedDestinationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSavedDestinationPayload>[]
          }
          upsert: {
            args: Prisma.UserSavedDestinationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSavedDestinationPayload>
          }
          aggregate: {
            args: Prisma.UserSavedDestinationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserSavedDestination>
          }
          groupBy: {
            args: Prisma.UserSavedDestinationGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserSavedDestinationGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserSavedDestinationCountArgs<ExtArgs>
            result: $Utils.Optional<UserSavedDestinationCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      Weather: {
        payload: Prisma.$WeatherPayload<ExtArgs>
        fields: Prisma.WeatherFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WeatherFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WeatherFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherPayload>
          }
          findFirst: {
            args: Prisma.WeatherFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WeatherFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherPayload>
          }
          findMany: {
            args: Prisma.WeatherFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherPayload>[]
          }
          create: {
            args: Prisma.WeatherCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherPayload>
          }
          createMany: {
            args: Prisma.WeatherCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WeatherCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherPayload>[]
          }
          delete: {
            args: Prisma.WeatherDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherPayload>
          }
          update: {
            args: Prisma.WeatherUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherPayload>
          }
          deleteMany: {
            args: Prisma.WeatherDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WeatherUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WeatherUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherPayload>[]
          }
          upsert: {
            args: Prisma.WeatherUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeatherPayload>
          }
          aggregate: {
            args: Prisma.WeatherAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWeather>
          }
          groupBy: {
            args: Prisma.WeatherGroupByArgs<ExtArgs>
            result: $Utils.Optional<WeatherGroupByOutputType>[]
          }
          count: {
            args: Prisma.WeatherCountArgs<ExtArgs>
            result: $Utils.Optional<WeatherCountAggregateOutputType> | number
          }
        }
      }
      Guide: {
        payload: Prisma.$GuidePayload<ExtArgs>
        fields: Prisma.GuideFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GuideFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuidePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GuideFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuidePayload>
          }
          findFirst: {
            args: Prisma.GuideFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuidePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GuideFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuidePayload>
          }
          findMany: {
            args: Prisma.GuideFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuidePayload>[]
          }
          create: {
            args: Prisma.GuideCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuidePayload>
          }
          createMany: {
            args: Prisma.GuideCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GuideCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuidePayload>[]
          }
          delete: {
            args: Prisma.GuideDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuidePayload>
          }
          update: {
            args: Prisma.GuideUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuidePayload>
          }
          deleteMany: {
            args: Prisma.GuideDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GuideUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GuideUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuidePayload>[]
          }
          upsert: {
            args: Prisma.GuideUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuidePayload>
          }
          aggregate: {
            args: Prisma.GuideAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGuide>
          }
          groupBy: {
            args: Prisma.GuideGroupByArgs<ExtArgs>
            result: $Utils.Optional<GuideGroupByOutputType>[]
          }
          count: {
            args: Prisma.GuideCountArgs<ExtArgs>
            result: $Utils.Optional<GuideCountAggregateOutputType> | number
          }
        }
      }
      Event: {
        payload: Prisma.$EventPayload<ExtArgs>
        fields: Prisma.EventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          findFirst: {
            args: Prisma.EventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          findMany: {
            args: Prisma.EventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[]
          }
          create: {
            args: Prisma.EventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          createMany: {
            args: Prisma.EventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[]
          }
          delete: {
            args: Prisma.EventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          update: {
            args: Prisma.EventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          deleteMany: {
            args: Prisma.EventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[]
          }
          upsert: {
            args: Prisma.EventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          aggregate: {
            args: Prisma.EventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvent>
          }
          groupBy: {
            args: Prisma.EventGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventCountArgs<ExtArgs>
            result: $Utils.Optional<EventCountAggregateOutputType> | number
          }
        }
      }
      CostOfLiving: {
        payload: Prisma.$CostOfLivingPayload<ExtArgs>
        fields: Prisma.CostOfLivingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CostOfLivingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostOfLivingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CostOfLivingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostOfLivingPayload>
          }
          findFirst: {
            args: Prisma.CostOfLivingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostOfLivingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CostOfLivingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostOfLivingPayload>
          }
          findMany: {
            args: Prisma.CostOfLivingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostOfLivingPayload>[]
          }
          create: {
            args: Prisma.CostOfLivingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostOfLivingPayload>
          }
          createMany: {
            args: Prisma.CostOfLivingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CostOfLivingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostOfLivingPayload>[]
          }
          delete: {
            args: Prisma.CostOfLivingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostOfLivingPayload>
          }
          update: {
            args: Prisma.CostOfLivingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostOfLivingPayload>
          }
          deleteMany: {
            args: Prisma.CostOfLivingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CostOfLivingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CostOfLivingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostOfLivingPayload>[]
          }
          upsert: {
            args: Prisma.CostOfLivingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostOfLivingPayload>
          }
          aggregate: {
            args: Prisma.CostOfLivingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCostOfLiving>
          }
          groupBy: {
            args: Prisma.CostOfLivingGroupByArgs<ExtArgs>
            result: $Utils.Optional<CostOfLivingGroupByOutputType>[]
          }
          count: {
            args: Prisma.CostOfLivingCountArgs<ExtArgs>
            result: $Utils.Optional<CostOfLivingCountAggregateOutputType> | number
          }
        }
      }
      Crowd: {
        payload: Prisma.$CrowdPayload<ExtArgs>
        fields: Prisma.CrowdFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CrowdFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrowdPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CrowdFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrowdPayload>
          }
          findFirst: {
            args: Prisma.CrowdFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrowdPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CrowdFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrowdPayload>
          }
          findMany: {
            args: Prisma.CrowdFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrowdPayload>[]
          }
          create: {
            args: Prisma.CrowdCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrowdPayload>
          }
          createMany: {
            args: Prisma.CrowdCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CrowdCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrowdPayload>[]
          }
          delete: {
            args: Prisma.CrowdDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrowdPayload>
          }
          update: {
            args: Prisma.CrowdUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrowdPayload>
          }
          deleteMany: {
            args: Prisma.CrowdDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CrowdUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CrowdUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrowdPayload>[]
          }
          upsert: {
            args: Prisma.CrowdUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrowdPayload>
          }
          aggregate: {
            args: Prisma.CrowdAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCrowd>
          }
          groupBy: {
            args: Prisma.CrowdGroupByArgs<ExtArgs>
            result: $Utils.Optional<CrowdGroupByOutputType>[]
          }
          count: {
            args: Prisma.CrowdCountArgs<ExtArgs>
            result: $Utils.Optional<CrowdCountAggregateOutputType> | number
          }
        }
      }
      Currency: {
        payload: Prisma.$CurrencyPayload<ExtArgs>
        fields: Prisma.CurrencyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CurrencyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CurrencyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>
          }
          findFirst: {
            args: Prisma.CurrencyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CurrencyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>
          }
          findMany: {
            args: Prisma.CurrencyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>[]
          }
          create: {
            args: Prisma.CurrencyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>
          }
          createMany: {
            args: Prisma.CurrencyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CurrencyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>[]
          }
          delete: {
            args: Prisma.CurrencyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>
          }
          update: {
            args: Prisma.CurrencyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>
          }
          deleteMany: {
            args: Prisma.CurrencyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CurrencyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CurrencyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>[]
          }
          upsert: {
            args: Prisma.CurrencyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>
          }
          aggregate: {
            args: Prisma.CurrencyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCurrency>
          }
          groupBy: {
            args: Prisma.CurrencyGroupByArgs<ExtArgs>
            result: $Utils.Optional<CurrencyGroupByOutputType>[]
          }
          count: {
            args: Prisma.CurrencyCountArgs<ExtArgs>
            result: $Utils.Optional<CurrencyCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    role?: RoleOmit
    userRole?: UserRoleOmit
    city?: CityOmit
    activity?: ActivityOmit
    hotel?: HotelOmit
    restaurant?: RestaurantOmit
    transport?: TransportOmit
    trip?: TripOmit
    tripStop?: TripStopOmit
    stopActivity?: StopActivityOmit
    tripBudget?: TripBudgetOmit
    tripMedia?: TripMediaOmit
    tripShare?: TripShareOmit
    tripVersion?: TripVersionOmit
    userSavedDestination?: UserSavedDestinationOmit
    auditLog?: AuditLogOmit
    weather?: WeatherOmit
    guide?: GuideOmit
    event?: EventOmit
    costOfLiving?: CostOfLivingOmit
    crowd?: CrowdOmit
    currency?: CurrencyOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    trips: number
    savedDestinations: number
    auditLogs: number
    userRoles: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trips?: boolean | UserCountOutputTypeCountTripsArgs
    savedDestinations?: boolean | UserCountOutputTypeCountSavedDestinationsArgs
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
    userRoles?: boolean | UserCountOutputTypeCountUserRolesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTripsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TripWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSavedDestinationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSavedDestinationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
  }


  /**
   * Count Type RoleCountOutputType
   */

  export type RoleCountOutputType = {
    userRoles: number
  }

  export type RoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userRoles?: boolean | RoleCountOutputTypeCountUserRolesArgs
  }

  // Custom InputTypes
  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountUserRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
  }


  /**
   * Count Type CityCountOutputType
   */

  export type CityCountOutputType = {
    activities: number
    hotels: number
    restaurants: number
    transportFrom: number
    transportTo: number
    tripStops: number
    savedDestinations: number
  }

  export type CityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activities?: boolean | CityCountOutputTypeCountActivitiesArgs
    hotels?: boolean | CityCountOutputTypeCountHotelsArgs
    restaurants?: boolean | CityCountOutputTypeCountRestaurantsArgs
    transportFrom?: boolean | CityCountOutputTypeCountTransportFromArgs
    transportTo?: boolean | CityCountOutputTypeCountTransportToArgs
    tripStops?: boolean | CityCountOutputTypeCountTripStopsArgs
    savedDestinations?: boolean | CityCountOutputTypeCountSavedDestinationsArgs
  }

  // Custom InputTypes
  /**
   * CityCountOutputType without action
   */
  export type CityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CityCountOutputType
     */
    select?: CityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CityCountOutputType without action
   */
  export type CityCountOutputTypeCountActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWhereInput
  }

  /**
   * CityCountOutputType without action
   */
  export type CityCountOutputTypeCountHotelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotelWhereInput
  }

  /**
   * CityCountOutputType without action
   */
  export type CityCountOutputTypeCountRestaurantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RestaurantWhereInput
  }

  /**
   * CityCountOutputType without action
   */
  export type CityCountOutputTypeCountTransportFromArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransportWhereInput
  }

  /**
   * CityCountOutputType without action
   */
  export type CityCountOutputTypeCountTransportToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransportWhereInput
  }

  /**
   * CityCountOutputType without action
   */
  export type CityCountOutputTypeCountTripStopsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TripStopWhereInput
  }

  /**
   * CityCountOutputType without action
   */
  export type CityCountOutputTypeCountSavedDestinationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSavedDestinationWhereInput
  }


  /**
   * Count Type ActivityCountOutputType
   */

  export type ActivityCountOutputType = {
    stopActivities: number
  }

  export type ActivityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stopActivities?: boolean | ActivityCountOutputTypeCountStopActivitiesArgs
  }

  // Custom InputTypes
  /**
   * ActivityCountOutputType without action
   */
  export type ActivityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityCountOutputType
     */
    select?: ActivityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ActivityCountOutputType without action
   */
  export type ActivityCountOutputTypeCountStopActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StopActivityWhereInput
  }


  /**
   * Count Type TripCountOutputType
   */

  export type TripCountOutputType = {
    stops: number
    budgets: number
    media: number
    shares: number
    versions: number
  }

  export type TripCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stops?: boolean | TripCountOutputTypeCountStopsArgs
    budgets?: boolean | TripCountOutputTypeCountBudgetsArgs
    media?: boolean | TripCountOutputTypeCountMediaArgs
    shares?: boolean | TripCountOutputTypeCountSharesArgs
    versions?: boolean | TripCountOutputTypeCountVersionsArgs
  }

  // Custom InputTypes
  /**
   * TripCountOutputType without action
   */
  export type TripCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripCountOutputType
     */
    select?: TripCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TripCountOutputType without action
   */
  export type TripCountOutputTypeCountStopsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TripStopWhereInput
  }

  /**
   * TripCountOutputType without action
   */
  export type TripCountOutputTypeCountBudgetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TripBudgetWhereInput
  }

  /**
   * TripCountOutputType without action
   */
  export type TripCountOutputTypeCountMediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TripMediaWhereInput
  }

  /**
   * TripCountOutputType without action
   */
  export type TripCountOutputTypeCountSharesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TripShareWhereInput
  }

  /**
   * TripCountOutputType without action
   */
  export type TripCountOutputTypeCountVersionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TripVersionWhereInput
  }


  /**
   * Count Type TripStopCountOutputType
   */

  export type TripStopCountOutputType = {
    activities: number
  }

  export type TripStopCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activities?: boolean | TripStopCountOutputTypeCountActivitiesArgs
  }

  // Custom InputTypes
  /**
   * TripStopCountOutputType without action
   */
  export type TripStopCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripStopCountOutputType
     */
    select?: TripStopCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TripStopCountOutputType without action
   */
  export type TripStopCountOutputTypeCountActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StopActivityWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    fullName: string | null
    profilePhotoUrl: string | null
    preferredLanguage: string | null
    preferredCurrency: string | null
    emailVerified: boolean | null
    isActive: boolean | null
    lastLoginAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    fullName: string | null
    profilePhotoUrl: string | null
    preferredLanguage: string | null
    preferredCurrency: string | null
    emailVerified: boolean | null
    isActive: boolean | null
    lastLoginAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    passwordHash: number
    fullName: number
    profilePhotoUrl: number
    preferredLanguage: number
    preferredCurrency: number
    emailVerified: number
    isActive: number
    lastLoginAt: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    fullName?: true
    profilePhotoUrl?: true
    preferredLanguage?: true
    preferredCurrency?: true
    emailVerified?: true
    isActive?: true
    lastLoginAt?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    fullName?: true
    profilePhotoUrl?: true
    preferredLanguage?: true
    preferredCurrency?: true
    emailVerified?: true
    isActive?: true
    lastLoginAt?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    fullName?: true
    profilePhotoUrl?: true
    preferredLanguage?: true
    preferredCurrency?: true
    emailVerified?: true
    isActive?: true
    lastLoginAt?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    passwordHash: string
    fullName: string
    profilePhotoUrl: string | null
    preferredLanguage: string
    preferredCurrency: string
    emailVerified: boolean
    isActive: boolean
    lastLoginAt: Date | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    fullName?: boolean
    profilePhotoUrl?: boolean
    preferredLanguage?: boolean
    preferredCurrency?: boolean
    emailVerified?: boolean
    isActive?: boolean
    lastLoginAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    trips?: boolean | User$tripsArgs<ExtArgs>
    savedDestinations?: boolean | User$savedDestinationsArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    userRoles?: boolean | User$userRolesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    fullName?: boolean
    profilePhotoUrl?: boolean
    preferredLanguage?: boolean
    preferredCurrency?: boolean
    emailVerified?: boolean
    isActive?: boolean
    lastLoginAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    fullName?: boolean
    profilePhotoUrl?: boolean
    preferredLanguage?: boolean
    preferredCurrency?: boolean
    emailVerified?: boolean
    isActive?: boolean
    lastLoginAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    fullName?: boolean
    profilePhotoUrl?: boolean
    preferredLanguage?: boolean
    preferredCurrency?: boolean
    emailVerified?: boolean
    isActive?: boolean
    lastLoginAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "passwordHash" | "fullName" | "profilePhotoUrl" | "preferredLanguage" | "preferredCurrency" | "emailVerified" | "isActive" | "lastLoginAt" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trips?: boolean | User$tripsArgs<ExtArgs>
    savedDestinations?: boolean | User$savedDestinationsArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    userRoles?: boolean | User$userRolesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      trips: Prisma.$TripPayload<ExtArgs>[]
      savedDestinations: Prisma.$UserSavedDestinationPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      userRoles: Prisma.$UserRolePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      passwordHash: string
      fullName: string
      profilePhotoUrl: string | null
      preferredLanguage: string
      preferredCurrency: string
      emailVerified: boolean
      isActive: boolean
      lastLoginAt: Date | null
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    trips<T extends User$tripsArgs<ExtArgs> = {}>(args?: Subset<T, User$tripsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    savedDestinations<T extends User$savedDestinationsArgs<ExtArgs> = {}>(args?: Subset<T, User$savedDestinationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSavedDestinationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userRoles<T extends User$userRolesArgs<ExtArgs> = {}>(args?: Subset<T, User$userRolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly fullName: FieldRef<"User", 'String'>
    readonly profilePhotoUrl: FieldRef<"User", 'String'>
    readonly preferredLanguage: FieldRef<"User", 'String'>
    readonly preferredCurrency: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'Boolean'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly lastLoginAt: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly deletedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.trips
   */
  export type User$tripsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trip
     */
    omit?: TripOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    where?: TripWhereInput
    orderBy?: TripOrderByWithRelationInput | TripOrderByWithRelationInput[]
    cursor?: TripWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TripScalarFieldEnum | TripScalarFieldEnum[]
  }

  /**
   * User.savedDestinations
   */
  export type User$savedDestinationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSavedDestination
     */
    select?: UserSavedDestinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSavedDestination
     */
    omit?: UserSavedDestinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSavedDestinationInclude<ExtArgs> | null
    where?: UserSavedDestinationWhereInput
    orderBy?: UserSavedDestinationOrderByWithRelationInput | UserSavedDestinationOrderByWithRelationInput[]
    cursor?: UserSavedDestinationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserSavedDestinationScalarFieldEnum | UserSavedDestinationScalarFieldEnum[]
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User.userRoles
   */
  export type User$userRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    cursor?: UserRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    permissions: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    permissions: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleCountAggregateOutputType = {
    id: number
    name: number
    description: number
    permissions: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RoleMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    permissions?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    permissions?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    permissions?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Role to aggregate.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type RoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithAggregationInput | RoleOrderByWithAggregationInput[]
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum
    having?: RoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }

  export type RoleGroupByOutputType = {
    id: string
    name: string
    description: string | null
    permissions: string
    createdAt: Date
    updatedAt: Date
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type RoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    permissions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userRoles?: boolean | Role$userRolesArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>

  export type RoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    permissions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["role"]>

  export type RoleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    permissions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["role"]>

  export type RoleSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    permissions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "permissions" | "createdAt" | "updatedAt", ExtArgs["result"]["role"]>
  export type RoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userRoles?: boolean | Role$userRolesArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type RoleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Role"
    objects: {
      userRoles: Prisma.$UserRolePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      permissions: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["role"]>
    composites: {}
  }

  type RoleGetPayload<S extends boolean | null | undefined | RoleDefaultArgs> = $Result.GetResult<Prisma.$RolePayload, S>

  type RoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface RoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Role'], meta: { name: 'Role' } }
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleFindUniqueArgs>(args: SelectSubset<T, RoleFindUniqueArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Role that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs>(args: SelectSubset<T, RoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleFindFirstArgs>(args?: SelectSubset<T, RoleFindFirstArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleFindFirstOrThrowArgs>(args?: SelectSubset<T, RoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoleFindManyArgs>(args?: SelectSubset<T, RoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
     */
    create<T extends RoleCreateArgs>(args: SelectSubset<T, RoleCreateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Roles.
     * @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoleCreateManyArgs>(args?: SelectSubset<T, RoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Roles and returns the data saved in the database.
     * @param {RoleCreateManyAndReturnArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoleCreateManyAndReturnArgs>(args?: SelectSubset<T, RoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
     */
    delete<T extends RoleDeleteArgs>(args: SelectSubset<T, RoleDeleteArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoleUpdateArgs>(args: SelectSubset<T, RoleUpdateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoleDeleteManyArgs>(args?: SelectSubset<T, RoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoleUpdateManyArgs>(args: SelectSubset<T, RoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles and returns the data updated in the database.
     * @param {RoleUpdateManyAndReturnArgs} args - Arguments to update many Roles.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RoleUpdateManyAndReturnArgs>(args: SelectSubset<T, RoleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     */
    upsert<T extends RoleUpsertArgs>(args: SelectSubset<T, RoleUpsertArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Role model
   */
  readonly fields: RoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userRoles<T extends Role$userRolesArgs<ExtArgs> = {}>(args?: Subset<T, Role$userRolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Role model
   */
  interface RoleFieldRefs {
    readonly id: FieldRef<"Role", 'String'>
    readonly name: FieldRef<"Role", 'String'>
    readonly description: FieldRef<"Role", 'String'>
    readonly permissions: FieldRef<"Role", 'String'>
    readonly createdAt: FieldRef<"Role", 'DateTime'>
    readonly updatedAt: FieldRef<"Role", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Role findUnique
   */
  export type RoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findUniqueOrThrow
   */
  export type RoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findFirst
   */
  export type RoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findFirstOrThrow
   */
  export type RoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findMany
   */
  export type RoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role create
   */
  export type RoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to create a Role.
     */
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>
  }

  /**
   * Role createMany
   */
  export type RoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
  }

  /**
   * Role createManyAndReturn
   */
  export type RoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
  }

  /**
   * Role update
   */
  export type RoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to update a Role.
     */
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
    /**
     * Choose, which Role to update.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Role updateManyAndReturn
   */
  export type RoleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Role upsert
   */
  export type RoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The filter to search for the Role to update in case it exists.
     */
    where: RoleWhereUniqueInput
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     */
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
  }

  /**
   * Role delete
   */
  export type RoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter which Role to delete.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to delete
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to delete.
     */
    limit?: number
  }

  /**
   * Role.userRoles
   */
  export type Role$userRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    cursor?: UserRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * Role without action
   */
  export type RoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
  }


  /**
   * Model UserRole
   */

  export type AggregateUserRole = {
    _count: UserRoleCountAggregateOutputType | null
    _min: UserRoleMinAggregateOutputType | null
    _max: UserRoleMaxAggregateOutputType | null
  }

  export type UserRoleMinAggregateOutputType = {
    id: string | null
    userId: string | null
    roleId: string | null
    assignedAt: Date | null
  }

  export type UserRoleMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    roleId: string | null
    assignedAt: Date | null
  }

  export type UserRoleCountAggregateOutputType = {
    id: number
    userId: number
    roleId: number
    assignedAt: number
    _all: number
  }


  export type UserRoleMinAggregateInputType = {
    id?: true
    userId?: true
    roleId?: true
    assignedAt?: true
  }

  export type UserRoleMaxAggregateInputType = {
    id?: true
    userId?: true
    roleId?: true
    assignedAt?: true
  }

  export type UserRoleCountAggregateInputType = {
    id?: true
    userId?: true
    roleId?: true
    assignedAt?: true
    _all?: true
  }

  export type UserRoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRole to aggregate.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserRoles
    **/
    _count?: true | UserRoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserRoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserRoleMaxAggregateInputType
  }

  export type GetUserRoleAggregateType<T extends UserRoleAggregateArgs> = {
        [P in keyof T & keyof AggregateUserRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserRole[P]>
      : GetScalarType<T[P], AggregateUserRole[P]>
  }




  export type UserRoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithAggregationInput | UserRoleOrderByWithAggregationInput[]
    by: UserRoleScalarFieldEnum[] | UserRoleScalarFieldEnum
    having?: UserRoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserRoleCountAggregateInputType | true
    _min?: UserRoleMinAggregateInputType
    _max?: UserRoleMaxAggregateInputType
  }

  export type UserRoleGroupByOutputType = {
    id: string
    userId: string
    roleId: string
    assignedAt: Date
    _count: UserRoleCountAggregateOutputType | null
    _min: UserRoleMinAggregateOutputType | null
    _max: UserRoleMaxAggregateOutputType | null
  }

  type GetUserRoleGroupByPayload<T extends UserRoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserRoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserRoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserRoleGroupByOutputType[P]>
            : GetScalarType<T[P], UserRoleGroupByOutputType[P]>
        }
      >
    >


  export type UserRoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    roleId?: boolean
    assignedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userRole"]>

  export type UserRoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    roleId?: boolean
    assignedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userRole"]>

  export type UserRoleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    roleId?: boolean
    assignedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userRole"]>

  export type UserRoleSelectScalar = {
    id?: boolean
    userId?: boolean
    roleId?: boolean
    assignedAt?: boolean
  }

  export type UserRoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "roleId" | "assignedAt", ExtArgs["result"]["userRole"]>
  export type UserRoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }
  export type UserRoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }
  export type UserRoleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }

  export type $UserRolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserRole"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      role: Prisma.$RolePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      roleId: string
      assignedAt: Date
    }, ExtArgs["result"]["userRole"]>
    composites: {}
  }

  type UserRoleGetPayload<S extends boolean | null | undefined | UserRoleDefaultArgs> = $Result.GetResult<Prisma.$UserRolePayload, S>

  type UserRoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserRoleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserRoleCountAggregateInputType | true
    }

  export interface UserRoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserRole'], meta: { name: 'UserRole' } }
    /**
     * Find zero or one UserRole that matches the filter.
     * @param {UserRoleFindUniqueArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserRoleFindUniqueArgs>(args: SelectSubset<T, UserRoleFindUniqueArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserRole that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserRoleFindUniqueOrThrowArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserRoleFindUniqueOrThrowArgs>(args: SelectSubset<T, UserRoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserRole that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindFirstArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserRoleFindFirstArgs>(args?: SelectSubset<T, UserRoleFindFirstArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserRole that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindFirstOrThrowArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserRoleFindFirstOrThrowArgs>(args?: SelectSubset<T, UserRoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserRoles
     * const userRoles = await prisma.userRole.findMany()
     * 
     * // Get first 10 UserRoles
     * const userRoles = await prisma.userRole.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userRoleWithIdOnly = await prisma.userRole.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserRoleFindManyArgs>(args?: SelectSubset<T, UserRoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserRole.
     * @param {UserRoleCreateArgs} args - Arguments to create a UserRole.
     * @example
     * // Create one UserRole
     * const UserRole = await prisma.userRole.create({
     *   data: {
     *     // ... data to create a UserRole
     *   }
     * })
     * 
     */
    create<T extends UserRoleCreateArgs>(args: SelectSubset<T, UserRoleCreateArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserRoles.
     * @param {UserRoleCreateManyArgs} args - Arguments to create many UserRoles.
     * @example
     * // Create many UserRoles
     * const userRole = await prisma.userRole.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserRoleCreateManyArgs>(args?: SelectSubset<T, UserRoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserRoles and returns the data saved in the database.
     * @param {UserRoleCreateManyAndReturnArgs} args - Arguments to create many UserRoles.
     * @example
     * // Create many UserRoles
     * const userRole = await prisma.userRole.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserRoles and only return the `id`
     * const userRoleWithIdOnly = await prisma.userRole.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserRoleCreateManyAndReturnArgs>(args?: SelectSubset<T, UserRoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserRole.
     * @param {UserRoleDeleteArgs} args - Arguments to delete one UserRole.
     * @example
     * // Delete one UserRole
     * const UserRole = await prisma.userRole.delete({
     *   where: {
     *     // ... filter to delete one UserRole
     *   }
     * })
     * 
     */
    delete<T extends UserRoleDeleteArgs>(args: SelectSubset<T, UserRoleDeleteArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserRole.
     * @param {UserRoleUpdateArgs} args - Arguments to update one UserRole.
     * @example
     * // Update one UserRole
     * const userRole = await prisma.userRole.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserRoleUpdateArgs>(args: SelectSubset<T, UserRoleUpdateArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserRoles.
     * @param {UserRoleDeleteManyArgs} args - Arguments to filter UserRoles to delete.
     * @example
     * // Delete a few UserRoles
     * const { count } = await prisma.userRole.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserRoleDeleteManyArgs>(args?: SelectSubset<T, UserRoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserRoles
     * const userRole = await prisma.userRole.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserRoleUpdateManyArgs>(args: SelectSubset<T, UserRoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserRoles and returns the data updated in the database.
     * @param {UserRoleUpdateManyAndReturnArgs} args - Arguments to update many UserRoles.
     * @example
     * // Update many UserRoles
     * const userRole = await prisma.userRole.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserRoles and only return the `id`
     * const userRoleWithIdOnly = await prisma.userRole.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserRoleUpdateManyAndReturnArgs>(args: SelectSubset<T, UserRoleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserRole.
     * @param {UserRoleUpsertArgs} args - Arguments to update or create a UserRole.
     * @example
     * // Update or create a UserRole
     * const userRole = await prisma.userRole.upsert({
     *   create: {
     *     // ... data to create a UserRole
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserRole we want to update
     *   }
     * })
     */
    upsert<T extends UserRoleUpsertArgs>(args: SelectSubset<T, UserRoleUpsertArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleCountArgs} args - Arguments to filter UserRoles to count.
     * @example
     * // Count the number of UserRoles
     * const count = await prisma.userRole.count({
     *   where: {
     *     // ... the filter for the UserRoles we want to count
     *   }
     * })
    **/
    count<T extends UserRoleCountArgs>(
      args?: Subset<T, UserRoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserRoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserRoleAggregateArgs>(args: Subset<T, UserRoleAggregateArgs>): Prisma.PrismaPromise<GetUserRoleAggregateType<T>>

    /**
     * Group by UserRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserRoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserRoleGroupByArgs['orderBy'] }
        : { orderBy?: UserRoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserRoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserRole model
   */
  readonly fields: UserRoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserRole.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserRoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserRole model
   */
  interface UserRoleFieldRefs {
    readonly id: FieldRef<"UserRole", 'String'>
    readonly userId: FieldRef<"UserRole", 'String'>
    readonly roleId: FieldRef<"UserRole", 'String'>
    readonly assignedAt: FieldRef<"UserRole", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserRole findUnique
   */
  export type UserRoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole findUniqueOrThrow
   */
  export type UserRoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole findFirst
   */
  export type UserRoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRoles.
     */
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole findFirstOrThrow
   */
  export type UserRoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRoles.
     */
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole findMany
   */
  export type UserRoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRoles to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole create
   */
  export type UserRoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The data needed to create a UserRole.
     */
    data: XOR<UserRoleCreateInput, UserRoleUncheckedCreateInput>
  }

  /**
   * UserRole createMany
   */
  export type UserRoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserRoles.
     */
    data: UserRoleCreateManyInput | UserRoleCreateManyInput[]
  }

  /**
   * UserRole createManyAndReturn
   */
  export type UserRoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * The data used to create many UserRoles.
     */
    data: UserRoleCreateManyInput | UserRoleCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserRole update
   */
  export type UserRoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The data needed to update a UserRole.
     */
    data: XOR<UserRoleUpdateInput, UserRoleUncheckedUpdateInput>
    /**
     * Choose, which UserRole to update.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole updateMany
   */
  export type UserRoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserRoles.
     */
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyInput>
    /**
     * Filter which UserRoles to update
     */
    where?: UserRoleWhereInput
    /**
     * Limit how many UserRoles to update.
     */
    limit?: number
  }

  /**
   * UserRole updateManyAndReturn
   */
  export type UserRoleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * The data used to update UserRoles.
     */
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyInput>
    /**
     * Filter which UserRoles to update
     */
    where?: UserRoleWhereInput
    /**
     * Limit how many UserRoles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserRole upsert
   */
  export type UserRoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The filter to search for the UserRole to update in case it exists.
     */
    where: UserRoleWhereUniqueInput
    /**
     * In case the UserRole found by the `where` argument doesn't exist, create a new UserRole with this data.
     */
    create: XOR<UserRoleCreateInput, UserRoleUncheckedCreateInput>
    /**
     * In case the UserRole was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserRoleUpdateInput, UserRoleUncheckedUpdateInput>
  }

  /**
   * UserRole delete
   */
  export type UserRoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter which UserRole to delete.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole deleteMany
   */
  export type UserRoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRoles to delete
     */
    where?: UserRoleWhereInput
    /**
     * Limit how many UserRoles to delete.
     */
    limit?: number
  }

  /**
   * UserRole without action
   */
  export type UserRoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
  }


  /**
   * Model City
   */

  export type AggregateCity = {
    _count: CityCountAggregateOutputType | null
    _avg: CityAvgAggregateOutputType | null
    _sum: CitySumAggregateOutputType | null
    _min: CityMinAggregateOutputType | null
    _max: CityMaxAggregateOutputType | null
  }

  export type CityAvgAggregateOutputType = {
    latitude: number | null
    longitude: number | null
    costIndex: number | null
    popularityScore: number | null
  }

  export type CitySumAggregateOutputType = {
    latitude: number | null
    longitude: number | null
    costIndex: number | null
    popularityScore: number | null
  }

  export type CityMinAggregateOutputType = {
    id: string | null
    name: string | null
    country: string | null
    countryCode: string | null
    region: string | null
    latitude: number | null
    longitude: number | null
    timezone: string | null
    costIndex: number | null
    popularityScore: number | null
    description: string | null
    imageUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type CityMaxAggregateOutputType = {
    id: string | null
    name: string | null
    country: string | null
    countryCode: string | null
    region: string | null
    latitude: number | null
    longitude: number | null
    timezone: string | null
    costIndex: number | null
    popularityScore: number | null
    description: string | null
    imageUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type CityCountAggregateOutputType = {
    id: number
    name: number
    country: number
    countryCode: number
    region: number
    latitude: number
    longitude: number
    timezone: number
    costIndex: number
    popularityScore: number
    description: number
    imageUrl: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type CityAvgAggregateInputType = {
    latitude?: true
    longitude?: true
    costIndex?: true
    popularityScore?: true
  }

  export type CitySumAggregateInputType = {
    latitude?: true
    longitude?: true
    costIndex?: true
    popularityScore?: true
  }

  export type CityMinAggregateInputType = {
    id?: true
    name?: true
    country?: true
    countryCode?: true
    region?: true
    latitude?: true
    longitude?: true
    timezone?: true
    costIndex?: true
    popularityScore?: true
    description?: true
    imageUrl?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type CityMaxAggregateInputType = {
    id?: true
    name?: true
    country?: true
    countryCode?: true
    region?: true
    latitude?: true
    longitude?: true
    timezone?: true
    costIndex?: true
    popularityScore?: true
    description?: true
    imageUrl?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type CityCountAggregateInputType = {
    id?: true
    name?: true
    country?: true
    countryCode?: true
    region?: true
    latitude?: true
    longitude?: true
    timezone?: true
    costIndex?: true
    popularityScore?: true
    description?: true
    imageUrl?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type CityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which City to aggregate.
     */
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     */
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Cities
    **/
    _count?: true | CityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CityMaxAggregateInputType
  }

  export type GetCityAggregateType<T extends CityAggregateArgs> = {
        [P in keyof T & keyof AggregateCity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCity[P]>
      : GetScalarType<T[P], AggregateCity[P]>
  }




  export type CityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CityWhereInput
    orderBy?: CityOrderByWithAggregationInput | CityOrderByWithAggregationInput[]
    by: CityScalarFieldEnum[] | CityScalarFieldEnum
    having?: CityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CityCountAggregateInputType | true
    _avg?: CityAvgAggregateInputType
    _sum?: CitySumAggregateInputType
    _min?: CityMinAggregateInputType
    _max?: CityMaxAggregateInputType
  }

  export type CityGroupByOutputType = {
    id: string
    name: string
    country: string
    countryCode: string
    region: string | null
    latitude: number
    longitude: number
    timezone: string
    costIndex: number
    popularityScore: number
    description: string | null
    imageUrl: string | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: CityCountAggregateOutputType | null
    _avg: CityAvgAggregateOutputType | null
    _sum: CitySumAggregateOutputType | null
    _min: CityMinAggregateOutputType | null
    _max: CityMaxAggregateOutputType | null
  }

  type GetCityGroupByPayload<T extends CityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CityGroupByOutputType[P]>
            : GetScalarType<T[P], CityGroupByOutputType[P]>
        }
      >
    >


  export type CitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    country?: boolean
    countryCode?: boolean
    region?: boolean
    latitude?: boolean
    longitude?: boolean
    timezone?: boolean
    costIndex?: boolean
    popularityScore?: boolean
    description?: boolean
    imageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    activities?: boolean | City$activitiesArgs<ExtArgs>
    hotels?: boolean | City$hotelsArgs<ExtArgs>
    restaurants?: boolean | City$restaurantsArgs<ExtArgs>
    transportFrom?: boolean | City$transportFromArgs<ExtArgs>
    transportTo?: boolean | City$transportToArgs<ExtArgs>
    tripStops?: boolean | City$tripStopsArgs<ExtArgs>
    savedDestinations?: boolean | City$savedDestinationsArgs<ExtArgs>
    _count?: boolean | CityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["city"]>

  export type CitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    country?: boolean
    countryCode?: boolean
    region?: boolean
    latitude?: boolean
    longitude?: boolean
    timezone?: boolean
    costIndex?: boolean
    popularityScore?: boolean
    description?: boolean
    imageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["city"]>

  export type CitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    country?: boolean
    countryCode?: boolean
    region?: boolean
    latitude?: boolean
    longitude?: boolean
    timezone?: boolean
    costIndex?: boolean
    popularityScore?: boolean
    description?: boolean
    imageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["city"]>

  export type CitySelectScalar = {
    id?: boolean
    name?: boolean
    country?: boolean
    countryCode?: boolean
    region?: boolean
    latitude?: boolean
    longitude?: boolean
    timezone?: boolean
    costIndex?: boolean
    popularityScore?: boolean
    description?: boolean
    imageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type CityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "country" | "countryCode" | "region" | "latitude" | "longitude" | "timezone" | "costIndex" | "popularityScore" | "description" | "imageUrl" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["city"]>
  export type CityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activities?: boolean | City$activitiesArgs<ExtArgs>
    hotels?: boolean | City$hotelsArgs<ExtArgs>
    restaurants?: boolean | City$restaurantsArgs<ExtArgs>
    transportFrom?: boolean | City$transportFromArgs<ExtArgs>
    transportTo?: boolean | City$transportToArgs<ExtArgs>
    tripStops?: boolean | City$tripStopsArgs<ExtArgs>
    savedDestinations?: boolean | City$savedDestinationsArgs<ExtArgs>
    _count?: boolean | CityCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "City"
    objects: {
      activities: Prisma.$ActivityPayload<ExtArgs>[]
      hotels: Prisma.$HotelPayload<ExtArgs>[]
      restaurants: Prisma.$RestaurantPayload<ExtArgs>[]
      transportFrom: Prisma.$TransportPayload<ExtArgs>[]
      transportTo: Prisma.$TransportPayload<ExtArgs>[]
      tripStops: Prisma.$TripStopPayload<ExtArgs>[]
      savedDestinations: Prisma.$UserSavedDestinationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      country: string
      countryCode: string
      region: string | null
      latitude: number
      longitude: number
      timezone: string
      costIndex: number
      popularityScore: number
      description: string | null
      imageUrl: string | null
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["city"]>
    composites: {}
  }

  type CityGetPayload<S extends boolean | null | undefined | CityDefaultArgs> = $Result.GetResult<Prisma.$CityPayload, S>

  type CityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CityCountAggregateInputType | true
    }

  export interface CityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['City'], meta: { name: 'City' } }
    /**
     * Find zero or one City that matches the filter.
     * @param {CityFindUniqueArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CityFindUniqueArgs>(args: SelectSubset<T, CityFindUniqueArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one City that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CityFindUniqueOrThrowArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CityFindUniqueOrThrowArgs>(args: SelectSubset<T, CityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first City that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFindFirstArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CityFindFirstArgs>(args?: SelectSubset<T, CityFindFirstArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first City that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFindFirstOrThrowArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CityFindFirstOrThrowArgs>(args?: SelectSubset<T, CityFindFirstOrThrowArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Cities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cities
     * const cities = await prisma.city.findMany()
     * 
     * // Get first 10 Cities
     * const cities = await prisma.city.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cityWithIdOnly = await prisma.city.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CityFindManyArgs>(args?: SelectSubset<T, CityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a City.
     * @param {CityCreateArgs} args - Arguments to create a City.
     * @example
     * // Create one City
     * const City = await prisma.city.create({
     *   data: {
     *     // ... data to create a City
     *   }
     * })
     * 
     */
    create<T extends CityCreateArgs>(args: SelectSubset<T, CityCreateArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Cities.
     * @param {CityCreateManyArgs} args - Arguments to create many Cities.
     * @example
     * // Create many Cities
     * const city = await prisma.city.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CityCreateManyArgs>(args?: SelectSubset<T, CityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Cities and returns the data saved in the database.
     * @param {CityCreateManyAndReturnArgs} args - Arguments to create many Cities.
     * @example
     * // Create many Cities
     * const city = await prisma.city.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Cities and only return the `id`
     * const cityWithIdOnly = await prisma.city.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CityCreateManyAndReturnArgs>(args?: SelectSubset<T, CityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a City.
     * @param {CityDeleteArgs} args - Arguments to delete one City.
     * @example
     * // Delete one City
     * const City = await prisma.city.delete({
     *   where: {
     *     // ... filter to delete one City
     *   }
     * })
     * 
     */
    delete<T extends CityDeleteArgs>(args: SelectSubset<T, CityDeleteArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one City.
     * @param {CityUpdateArgs} args - Arguments to update one City.
     * @example
     * // Update one City
     * const city = await prisma.city.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CityUpdateArgs>(args: SelectSubset<T, CityUpdateArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Cities.
     * @param {CityDeleteManyArgs} args - Arguments to filter Cities to delete.
     * @example
     * // Delete a few Cities
     * const { count } = await prisma.city.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CityDeleteManyArgs>(args?: SelectSubset<T, CityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cities
     * const city = await prisma.city.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CityUpdateManyArgs>(args: SelectSubset<T, CityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cities and returns the data updated in the database.
     * @param {CityUpdateManyAndReturnArgs} args - Arguments to update many Cities.
     * @example
     * // Update many Cities
     * const city = await prisma.city.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Cities and only return the `id`
     * const cityWithIdOnly = await prisma.city.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CityUpdateManyAndReturnArgs>(args: SelectSubset<T, CityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one City.
     * @param {CityUpsertArgs} args - Arguments to update or create a City.
     * @example
     * // Update or create a City
     * const city = await prisma.city.upsert({
     *   create: {
     *     // ... data to create a City
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the City we want to update
     *   }
     * })
     */
    upsert<T extends CityUpsertArgs>(args: SelectSubset<T, CityUpsertArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityCountArgs} args - Arguments to filter Cities to count.
     * @example
     * // Count the number of Cities
     * const count = await prisma.city.count({
     *   where: {
     *     // ... the filter for the Cities we want to count
     *   }
     * })
    **/
    count<T extends CityCountArgs>(
      args?: Subset<T, CityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a City.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CityAggregateArgs>(args: Subset<T, CityAggregateArgs>): Prisma.PrismaPromise<GetCityAggregateType<T>>

    /**
     * Group by City.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CityGroupByArgs['orderBy'] }
        : { orderBy?: CityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the City model
   */
  readonly fields: CityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for City.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    activities<T extends City$activitiesArgs<ExtArgs> = {}>(args?: Subset<T, City$activitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    hotels<T extends City$hotelsArgs<ExtArgs> = {}>(args?: Subset<T, City$hotelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    restaurants<T extends City$restaurantsArgs<ExtArgs> = {}>(args?: Subset<T, City$restaurantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RestaurantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transportFrom<T extends City$transportFromArgs<ExtArgs> = {}>(args?: Subset<T, City$transportFromArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transportTo<T extends City$transportToArgs<ExtArgs> = {}>(args?: Subset<T, City$transportToArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tripStops<T extends City$tripStopsArgs<ExtArgs> = {}>(args?: Subset<T, City$tripStopsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TripStopPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    savedDestinations<T extends City$savedDestinationsArgs<ExtArgs> = {}>(args?: Subset<T, City$savedDestinationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSavedDestinationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the City model
   */
  interface CityFieldRefs {
    readonly id: FieldRef<"City", 'String'>
    readonly name: FieldRef<"City", 'String'>
    readonly country: FieldRef<"City", 'String'>
    readonly countryCode: FieldRef<"City", 'String'>
    readonly region: FieldRef<"City", 'String'>
    readonly latitude: FieldRef<"City", 'Float'>
    readonly longitude: FieldRef<"City", 'Float'>
    readonly timezone: FieldRef<"City", 'String'>
    readonly costIndex: FieldRef<"City", 'Float'>
    readonly popularityScore: FieldRef<"City", 'Int'>
    readonly description: FieldRef<"City", 'String'>
    readonly imageUrl: FieldRef<"City", 'String'>
    readonly createdAt: FieldRef<"City", 'DateTime'>
    readonly updatedAt: FieldRef<"City", 'DateTime'>
    readonly deletedAt: FieldRef<"City", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * City findUnique
   */
  export type CityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which City to fetch.
     */
    where: CityWhereUniqueInput
  }

  /**
   * City findUniqueOrThrow
   */
  export type CityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which City to fetch.
     */
    where: CityWhereUniqueInput
  }

  /**
   * City findFirst
   */
  export type CityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which City to fetch.
     */
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     */
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cities.
     */
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cities.
     */
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }

  /**
   * City findFirstOrThrow
   */
  export type CityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which City to fetch.
     */
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     */
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cities.
     */
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cities.
     */
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }

  /**
   * City findMany
   */
  export type CityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which Cities to fetch.
     */
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     */
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Cities.
     */
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     */
    skip?: number
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }

  /**
   * City create
   */
  export type CityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * The data needed to create a City.
     */
    data: XOR<CityCreateInput, CityUncheckedCreateInput>
  }

  /**
   * City createMany
   */
  export type CityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Cities.
     */
    data: CityCreateManyInput | CityCreateManyInput[]
  }

  /**
   * City createManyAndReturn
   */
  export type CityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * The data used to create many Cities.
     */
    data: CityCreateManyInput | CityCreateManyInput[]
  }

  /**
   * City update
   */
  export type CityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * The data needed to update a City.
     */
    data: XOR<CityUpdateInput, CityUncheckedUpdateInput>
    /**
     * Choose, which City to update.
     */
    where: CityWhereUniqueInput
  }

  /**
   * City updateMany
   */
  export type CityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Cities.
     */
    data: XOR<CityUpdateManyMutationInput, CityUncheckedUpdateManyInput>
    /**
     * Filter which Cities to update
     */
    where?: CityWhereInput
    /**
     * Limit how many Cities to update.
     */
    limit?: number
  }

  /**
   * City updateManyAndReturn
   */
  export type CityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * The data used to update Cities.
     */
    data: XOR<CityUpdateManyMutationInput, CityUncheckedUpdateManyInput>
    /**
     * Filter which Cities to update
     */
    where?: CityWhereInput
    /**
     * Limit how many Cities to update.
     */
    limit?: number
  }

  /**
   * City upsert
   */
  export type CityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * The filter to search for the City to update in case it exists.
     */
    where: CityWhereUniqueInput
    /**
     * In case the City found by the `where` argument doesn't exist, create a new City with this data.
     */
    create: XOR<CityCreateInput, CityUncheckedCreateInput>
    /**
     * In case the City was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CityUpdateInput, CityUncheckedUpdateInput>
  }

  /**
   * City delete
   */
  export type CityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter which City to delete.
     */
    where: CityWhereUniqueInput
  }

  /**
   * City deleteMany
   */
  export type CityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cities to delete
     */
    where?: CityWhereInput
    /**
     * Limit how many Cities to delete.
     */
    limit?: number
  }

  /**
   * City.activities
   */
  export type City$activitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    where?: ActivityWhereInput
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    cursor?: ActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * City.hotels
   */
  export type City$hotelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hotel
     */
    omit?: HotelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
    where?: HotelWhereInput
    orderBy?: HotelOrderByWithRelationInput | HotelOrderByWithRelationInput[]
    cursor?: HotelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HotelScalarFieldEnum | HotelScalarFieldEnum[]
  }

  /**
   * City.restaurants
   */
  export type City$restaurantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Restaurant
     */
    select?: RestaurantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Restaurant
     */
    omit?: RestaurantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantInclude<ExtArgs> | null
    where?: RestaurantWhereInput
    orderBy?: RestaurantOrderByWithRelationInput | RestaurantOrderByWithRelationInput[]
    cursor?: RestaurantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RestaurantScalarFieldEnum | RestaurantScalarFieldEnum[]
  }

  /**
   * City.transportFrom
   */
  export type City$transportFromArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transport
     */
    select?: TransportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transport
     */
    omit?: TransportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransportInclude<ExtArgs> | null
    where?: TransportWhereInput
    orderBy?: TransportOrderByWithRelationInput | TransportOrderByWithRelationInput[]
    cursor?: TransportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransportScalarFieldEnum | TransportScalarFieldEnum[]
  }

  /**
   * City.transportTo
   */
  export type City$transportToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transport
     */
    select?: TransportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transport
     */
    omit?: TransportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransportInclude<ExtArgs> | null
    where?: TransportWhereInput
    orderBy?: TransportOrderByWithRelationInput | TransportOrderByWithRelationInput[]
    cursor?: TransportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransportScalarFieldEnum | TransportScalarFieldEnum[]
  }

  /**
   * City.tripStops
   */
  export type City$tripStopsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripStop
     */
    select?: TripStopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TripStop
     */
    omit?: TripStopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripStopInclude<ExtArgs> | null
    where?: TripStopWhereInput
    orderBy?: TripStopOrderByWithRelationInput | TripStopOrderByWithRelationInput[]
    cursor?: TripStopWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TripStopScalarFieldEnum | TripStopScalarFieldEnum[]
  }

  /**
   * City.savedDestinations
   */
  export type City$savedDestinationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSavedDestination
     */
    select?: UserSavedDestinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSavedDestination
     */
    omit?: UserSavedDestinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSavedDestinationInclude<ExtArgs> | null
    where?: UserSavedDestinationWhereInput
    orderBy?: UserSavedDestinationOrderByWithRelationInput | UserSavedDestinationOrderByWithRelationInput[]
    cursor?: UserSavedDestinationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserSavedDestinationScalarFieldEnum | UserSavedDestinationScalarFieldEnum[]
  }

  /**
   * City without action
   */
  export type CityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
  }


  /**
   * Model Activity
   */

  export type AggregateActivity = {
    _count: ActivityCountAggregateOutputType | null
    _avg: ActivityAvgAggregateOutputType | null
    _sum: ActivitySumAggregateOutputType | null
    _min: ActivityMinAggregateOutputType | null
    _max: ActivityMaxAggregateOutputType | null
  }

  export type ActivityAvgAggregateOutputType = {
    estimatedCost: number | null
    durationMinutes: number | null
    rating: number | null
    popularityScore: number | null
  }

  export type ActivitySumAggregateOutputType = {
    estimatedCost: number | null
    durationMinutes: number | null
    rating: number | null
    popularityScore: number | null
  }

  export type ActivityMinAggregateOutputType = {
    id: string | null
    cityId: string | null
    name: string | null
    category: string | null
    description: string | null
    estimatedCost: number | null
    currency: string | null
    durationMinutes: number | null
    imageUrl: string | null
    rating: number | null
    popularityScore: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ActivityMaxAggregateOutputType = {
    id: string | null
    cityId: string | null
    name: string | null
    category: string | null
    description: string | null
    estimatedCost: number | null
    currency: string | null
    durationMinutes: number | null
    imageUrl: string | null
    rating: number | null
    popularityScore: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ActivityCountAggregateOutputType = {
    id: number
    cityId: number
    name: number
    category: number
    description: number
    estimatedCost: number
    currency: number
    durationMinutes: number
    imageUrl: number
    rating: number
    popularityScore: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type ActivityAvgAggregateInputType = {
    estimatedCost?: true
    durationMinutes?: true
    rating?: true
    popularityScore?: true
  }

  export type ActivitySumAggregateInputType = {
    estimatedCost?: true
    durationMinutes?: true
    rating?: true
    popularityScore?: true
  }

  export type ActivityMinAggregateInputType = {
    id?: true
    cityId?: true
    name?: true
    category?: true
    description?: true
    estimatedCost?: true
    currency?: true
    durationMinutes?: true
    imageUrl?: true
    rating?: true
    popularityScore?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ActivityMaxAggregateInputType = {
    id?: true
    cityId?: true
    name?: true
    category?: true
    description?: true
    estimatedCost?: true
    currency?: true
    durationMinutes?: true
    imageUrl?: true
    rating?: true
    popularityScore?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ActivityCountAggregateInputType = {
    id?: true
    cityId?: true
    name?: true
    category?: true
    description?: true
    estimatedCost?: true
    currency?: true
    durationMinutes?: true
    imageUrl?: true
    rating?: true
    popularityScore?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type ActivityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Activity to aggregate.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Activities
    **/
    _count?: true | ActivityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ActivityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ActivitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivityMaxAggregateInputType
  }

  export type GetActivityAggregateType<T extends ActivityAggregateArgs> = {
        [P in keyof T & keyof AggregateActivity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivity[P]>
      : GetScalarType<T[P], AggregateActivity[P]>
  }




  export type ActivityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWhereInput
    orderBy?: ActivityOrderByWithAggregationInput | ActivityOrderByWithAggregationInput[]
    by: ActivityScalarFieldEnum[] | ActivityScalarFieldEnum
    having?: ActivityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivityCountAggregateInputType | true
    _avg?: ActivityAvgAggregateInputType
    _sum?: ActivitySumAggregateInputType
    _min?: ActivityMinAggregateInputType
    _max?: ActivityMaxAggregateInputType
  }

  export type ActivityGroupByOutputType = {
    id: string
    cityId: string
    name: string
    category: string
    description: string | null
    estimatedCost: number
    currency: string
    durationMinutes: number | null
    imageUrl: string | null
    rating: number | null
    popularityScore: number
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: ActivityCountAggregateOutputType | null
    _avg: ActivityAvgAggregateOutputType | null
    _sum: ActivitySumAggregateOutputType | null
    _min: ActivityMinAggregateOutputType | null
    _max: ActivityMaxAggregateOutputType | null
  }

  type GetActivityGroupByPayload<T extends ActivityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActivityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivityGroupByOutputType[P]>
            : GetScalarType<T[P], ActivityGroupByOutputType[P]>
        }
      >
    >


  export type ActivitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cityId?: boolean
    name?: boolean
    category?: boolean
    description?: boolean
    estimatedCost?: boolean
    currency?: boolean
    durationMinutes?: boolean
    imageUrl?: boolean
    rating?: boolean
    popularityScore?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    city?: boolean | CityDefaultArgs<ExtArgs>
    stopActivities?: boolean | Activity$stopActivitiesArgs<ExtArgs>
    _count?: boolean | ActivityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activity"]>

  export type ActivitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cityId?: boolean
    name?: boolean
    category?: boolean
    description?: boolean
    estimatedCost?: boolean
    currency?: boolean
    durationMinutes?: boolean
    imageUrl?: boolean
    rating?: boolean
    popularityScore?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    city?: boolean | CityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activity"]>

  export type ActivitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cityId?: boolean
    name?: boolean
    category?: boolean
    description?: boolean
    estimatedCost?: boolean
    currency?: boolean
    durationMinutes?: boolean
    imageUrl?: boolean
    rating?: boolean
    popularityScore?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    city?: boolean | CityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activity"]>

  export type ActivitySelectScalar = {
    id?: boolean
    cityId?: boolean
    name?: boolean
    category?: boolean
    description?: boolean
    estimatedCost?: boolean
    currency?: boolean
    durationMinutes?: boolean
    imageUrl?: boolean
    rating?: boolean
    popularityScore?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type ActivityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cityId" | "name" | "category" | "description" | "estimatedCost" | "currency" | "durationMinutes" | "imageUrl" | "rating" | "popularityScore" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["activity"]>
  export type ActivityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    city?: boolean | CityDefaultArgs<ExtArgs>
    stopActivities?: boolean | Activity$stopActivitiesArgs<ExtArgs>
    _count?: boolean | ActivityCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ActivityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    city?: boolean | CityDefaultArgs<ExtArgs>
  }
  export type ActivityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    city?: boolean | CityDefaultArgs<ExtArgs>
  }

  export type $ActivityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Activity"
    objects: {
      city: Prisma.$CityPayload<ExtArgs>
      stopActivities: Prisma.$StopActivityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      cityId: string
      name: string
      category: string
      description: string | null
      estimatedCost: number
      currency: string
      durationMinutes: number | null
      imageUrl: string | null
      rating: number | null
      popularityScore: number
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["activity"]>
    composites: {}
  }

  type ActivityGetPayload<S extends boolean | null | undefined | ActivityDefaultArgs> = $Result.GetResult<Prisma.$ActivityPayload, S>

  type ActivityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ActivityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ActivityCountAggregateInputType | true
    }

  export interface ActivityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Activity'], meta: { name: 'Activity' } }
    /**
     * Find zero or one Activity that matches the filter.
     * @param {ActivityFindUniqueArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActivityFindUniqueArgs>(args: SelectSubset<T, ActivityFindUniqueArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Activity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ActivityFindUniqueOrThrowArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActivityFindUniqueOrThrowArgs>(args: SelectSubset<T, ActivityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Activity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindFirstArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActivityFindFirstArgs>(args?: SelectSubset<T, ActivityFindFirstArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Activity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindFirstOrThrowArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActivityFindFirstOrThrowArgs>(args?: SelectSubset<T, ActivityFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Activities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Activities
     * const activities = await prisma.activity.findMany()
     * 
     * // Get first 10 Activities
     * const activities = await prisma.activity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activityWithIdOnly = await prisma.activity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActivityFindManyArgs>(args?: SelectSubset<T, ActivityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Activity.
     * @param {ActivityCreateArgs} args - Arguments to create a Activity.
     * @example
     * // Create one Activity
     * const Activity = await prisma.activity.create({
     *   data: {
     *     // ... data to create a Activity
     *   }
     * })
     * 
     */
    create<T extends ActivityCreateArgs>(args: SelectSubset<T, ActivityCreateArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Activities.
     * @param {ActivityCreateManyArgs} args - Arguments to create many Activities.
     * @example
     * // Create many Activities
     * const activity = await prisma.activity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActivityCreateManyArgs>(args?: SelectSubset<T, ActivityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Activities and returns the data saved in the database.
     * @param {ActivityCreateManyAndReturnArgs} args - Arguments to create many Activities.
     * @example
     * // Create many Activities
     * const activity = await prisma.activity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Activities and only return the `id`
     * const activityWithIdOnly = await prisma.activity.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActivityCreateManyAndReturnArgs>(args?: SelectSubset<T, ActivityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Activity.
     * @param {ActivityDeleteArgs} args - Arguments to delete one Activity.
     * @example
     * // Delete one Activity
     * const Activity = await prisma.activity.delete({
     *   where: {
     *     // ... filter to delete one Activity
     *   }
     * })
     * 
     */
    delete<T extends ActivityDeleteArgs>(args: SelectSubset<T, ActivityDeleteArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Activity.
     * @param {ActivityUpdateArgs} args - Arguments to update one Activity.
     * @example
     * // Update one Activity
     * const activity = await prisma.activity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActivityUpdateArgs>(args: SelectSubset<T, ActivityUpdateArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Activities.
     * @param {ActivityDeleteManyArgs} args - Arguments to filter Activities to delete.
     * @example
     * // Delete a few Activities
     * const { count } = await prisma.activity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActivityDeleteManyArgs>(args?: SelectSubset<T, ActivityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Activities
     * const activity = await prisma.activity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActivityUpdateManyArgs>(args: SelectSubset<T, ActivityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Activities and returns the data updated in the database.
     * @param {ActivityUpdateManyAndReturnArgs} args - Arguments to update many Activities.
     * @example
     * // Update many Activities
     * const activity = await prisma.activity.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Activities and only return the `id`
     * const activityWithIdOnly = await prisma.activity.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ActivityUpdateManyAndReturnArgs>(args: SelectSubset<T, ActivityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Activity.
     * @param {ActivityUpsertArgs} args - Arguments to update or create a Activity.
     * @example
     * // Update or create a Activity
     * const activity = await prisma.activity.upsert({
     *   create: {
     *     // ... data to create a Activity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Activity we want to update
     *   }
     * })
     */
    upsert<T extends ActivityUpsertArgs>(args: SelectSubset<T, ActivityUpsertArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityCountArgs} args - Arguments to filter Activities to count.
     * @example
     * // Count the number of Activities
     * const count = await prisma.activity.count({
     *   where: {
     *     // ... the filter for the Activities we want to count
     *   }
     * })
    **/
    count<T extends ActivityCountArgs>(
      args?: Subset<T, ActivityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Activity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivityAggregateArgs>(args: Subset<T, ActivityAggregateArgs>): Prisma.PrismaPromise<GetActivityAggregateType<T>>

    /**
     * Group by Activity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActivityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActivityGroupByArgs['orderBy'] }
        : { orderBy?: ActivityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActivityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Activity model
   */
  readonly fields: ActivityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Activity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActivityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    city<T extends CityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CityDefaultArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    stopActivities<T extends Activity$stopActivitiesArgs<ExtArgs> = {}>(args?: Subset<T, Activity$stopActivitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StopActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Activity model
   */
  interface ActivityFieldRefs {
    readonly id: FieldRef<"Activity", 'String'>
    readonly cityId: FieldRef<"Activity", 'String'>
    readonly name: FieldRef<"Activity", 'String'>
    readonly category: FieldRef<"Activity", 'String'>
    readonly description: FieldRef<"Activity", 'String'>
    readonly estimatedCost: FieldRef<"Activity", 'Float'>
    readonly currency: FieldRef<"Activity", 'String'>
    readonly durationMinutes: FieldRef<"Activity", 'Int'>
    readonly imageUrl: FieldRef<"Activity", 'String'>
    readonly rating: FieldRef<"Activity", 'Float'>
    readonly popularityScore: FieldRef<"Activity", 'Int'>
    readonly createdAt: FieldRef<"Activity", 'DateTime'>
    readonly updatedAt: FieldRef<"Activity", 'DateTime'>
    readonly deletedAt: FieldRef<"Activity", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Activity findUnique
   */
  export type ActivityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity findUniqueOrThrow
   */
  export type ActivityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity findFirst
   */
  export type ActivityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Activities.
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Activities.
     */
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Activity findFirstOrThrow
   */
  export type ActivityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Activities.
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Activities.
     */
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Activity findMany
   */
  export type ActivityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activities to fetch.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Activities.
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Activity create
   */
  export type ActivityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * The data needed to create a Activity.
     */
    data: XOR<ActivityCreateInput, ActivityUncheckedCreateInput>
  }

  /**
   * Activity createMany
   */
  export type ActivityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Activities.
     */
    data: ActivityCreateManyInput | ActivityCreateManyInput[]
  }

  /**
   * Activity createManyAndReturn
   */
  export type ActivityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * The data used to create many Activities.
     */
    data: ActivityCreateManyInput | ActivityCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Activity update
   */
  export type ActivityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * The data needed to update a Activity.
     */
    data: XOR<ActivityUpdateInput, ActivityUncheckedUpdateInput>
    /**
     * Choose, which Activity to update.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity updateMany
   */
  export type ActivityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Activities.
     */
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyInput>
    /**
     * Filter which Activities to update
     */
    where?: ActivityWhereInput
    /**
     * Limit how many Activities to update.
     */
    limit?: number
  }

  /**
   * Activity updateManyAndReturn
   */
  export type ActivityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * The data used to update Activities.
     */
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyInput>
    /**
     * Filter which Activities to update
     */
    where?: ActivityWhereInput
    /**
     * Limit how many Activities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Activity upsert
   */
  export type ActivityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * The filter to search for the Activity to update in case it exists.
     */
    where: ActivityWhereUniqueInput
    /**
     * In case the Activity found by the `where` argument doesn't exist, create a new Activity with this data.
     */
    create: XOR<ActivityCreateInput, ActivityUncheckedCreateInput>
    /**
     * In case the Activity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActivityUpdateInput, ActivityUncheckedUpdateInput>
  }

  /**
   * Activity delete
   */
  export type ActivityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter which Activity to delete.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity deleteMany
   */
  export type ActivityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Activities to delete
     */
    where?: ActivityWhereInput
    /**
     * Limit how many Activities to delete.
     */
    limit?: number
  }

  /**
   * Activity.stopActivities
   */
  export type Activity$stopActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StopActivity
     */
    select?: StopActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StopActivity
     */
    omit?: StopActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StopActivityInclude<ExtArgs> | null
    where?: StopActivityWhereInput
    orderBy?: StopActivityOrderByWithRelationInput | StopActivityOrderByWithRelationInput[]
    cursor?: StopActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StopActivityScalarFieldEnum | StopActivityScalarFieldEnum[]
  }

  /**
   * Activity without action
   */
  export type ActivityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
  }


  /**
   * Model Hotel
   */

  export type AggregateHotel = {
    _count: HotelCountAggregateOutputType | null
    _avg: HotelAvgAggregateOutputType | null
    _sum: HotelSumAggregateOutputType | null
    _min: HotelMinAggregateOutputType | null
    _max: HotelMaxAggregateOutputType | null
  }

  export type HotelAvgAggregateOutputType = {
    pricePerNight: number | null
    rating: number | null
  }

  export type HotelSumAggregateOutputType = {
    pricePerNight: number | null
    rating: number | null
  }

  export type HotelMinAggregateOutputType = {
    id: string | null
    cityId: string | null
    name: string | null
    category: string | null
    description: string | null
    pricePerNight: number | null
    currency: string | null
    rating: number | null
    amenities: string | null
    address: string | null
    imageUrl: string | null
    contactPhone: string | null
    website: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type HotelMaxAggregateOutputType = {
    id: string | null
    cityId: string | null
    name: string | null
    category: string | null
    description: string | null
    pricePerNight: number | null
    currency: string | null
    rating: number | null
    amenities: string | null
    address: string | null
    imageUrl: string | null
    contactPhone: string | null
    website: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type HotelCountAggregateOutputType = {
    id: number
    cityId: number
    name: number
    category: number
    description: number
    pricePerNight: number
    currency: number
    rating: number
    amenities: number
    address: number
    imageUrl: number
    contactPhone: number
    website: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type HotelAvgAggregateInputType = {
    pricePerNight?: true
    rating?: true
  }

  export type HotelSumAggregateInputType = {
    pricePerNight?: true
    rating?: true
  }

  export type HotelMinAggregateInputType = {
    id?: true
    cityId?: true
    name?: true
    category?: true
    description?: true
    pricePerNight?: true
    currency?: true
    rating?: true
    amenities?: true
    address?: true
    imageUrl?: true
    contactPhone?: true
    website?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type HotelMaxAggregateInputType = {
    id?: true
    cityId?: true
    name?: true
    category?: true
    description?: true
    pricePerNight?: true
    currency?: true
    rating?: true
    amenities?: true
    address?: true
    imageUrl?: true
    contactPhone?: true
    website?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type HotelCountAggregateInputType = {
    id?: true
    cityId?: true
    name?: true
    category?: true
    description?: true
    pricePerNight?: true
    currency?: true
    rating?: true
    amenities?: true
    address?: true
    imageUrl?: true
    contactPhone?: true
    website?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type HotelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Hotel to aggregate.
     */
    where?: HotelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hotels to fetch.
     */
    orderBy?: HotelOrderByWithRelationInput | HotelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HotelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hotels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hotels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Hotels
    **/
    _count?: true | HotelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HotelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HotelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HotelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HotelMaxAggregateInputType
  }

  export type GetHotelAggregateType<T extends HotelAggregateArgs> = {
        [P in keyof T & keyof AggregateHotel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHotel[P]>
      : GetScalarType<T[P], AggregateHotel[P]>
  }




  export type HotelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotelWhereInput
    orderBy?: HotelOrderByWithAggregationInput | HotelOrderByWithAggregationInput[]
    by: HotelScalarFieldEnum[] | HotelScalarFieldEnum
    having?: HotelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HotelCountAggregateInputType | true
    _avg?: HotelAvgAggregateInputType
    _sum?: HotelSumAggregateInputType
    _min?: HotelMinAggregateInputType
    _max?: HotelMaxAggregateInputType
  }

  export type HotelGroupByOutputType = {
    id: string
    cityId: string
    name: string
    category: string
    description: string | null
    pricePerNight: number
    currency: string
    rating: number | null
    amenities: string | null
    address: string | null
    imageUrl: string | null
    contactPhone: string | null
    website: string | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: HotelCountAggregateOutputType | null
    _avg: HotelAvgAggregateOutputType | null
    _sum: HotelSumAggregateOutputType | null
    _min: HotelMinAggregateOutputType | null
    _max: HotelMaxAggregateOutputType | null
  }

  type GetHotelGroupByPayload<T extends HotelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HotelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HotelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HotelGroupByOutputType[P]>
            : GetScalarType<T[P], HotelGroupByOutputType[P]>
        }
      >
    >


  export type HotelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cityId?: boolean
    name?: boolean
    category?: boolean
    description?: boolean
    pricePerNight?: boolean
    currency?: boolean
    rating?: boolean
    amenities?: boolean
    address?: boolean
    imageUrl?: boolean
    contactPhone?: boolean
    website?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    city?: boolean | CityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hotel"]>

  export type HotelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cityId?: boolean
    name?: boolean
    category?: boolean
    description?: boolean
    pricePerNight?: boolean
    currency?: boolean
    rating?: boolean
    amenities?: boolean
    address?: boolean
    imageUrl?: boolean
    contactPhone?: boolean
    website?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    city?: boolean | CityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hotel"]>

  export type HotelSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cityId?: boolean
    name?: boolean
    category?: boolean
    description?: boolean
    pricePerNight?: boolean
    currency?: boolean
    rating?: boolean
    amenities?: boolean
    address?: boolean
    imageUrl?: boolean
    contactPhone?: boolean
    website?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    city?: boolean | CityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hotel"]>

  export type HotelSelectScalar = {
    id?: boolean
    cityId?: boolean
    name?: boolean
    category?: boolean
    description?: boolean
    pricePerNight?: boolean
    currency?: boolean
    rating?: boolean
    amenities?: boolean
    address?: boolean
    imageUrl?: boolean
    contactPhone?: boolean
    website?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type HotelOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cityId" | "name" | "category" | "description" | "pricePerNight" | "currency" | "rating" | "amenities" | "address" | "imageUrl" | "contactPhone" | "website" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["hotel"]>
  export type HotelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    city?: boolean | CityDefaultArgs<ExtArgs>
  }
  export type HotelIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    city?: boolean | CityDefaultArgs<ExtArgs>
  }
  export type HotelIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    city?: boolean | CityDefaultArgs<ExtArgs>
  }

  export type $HotelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Hotel"
    objects: {
      city: Prisma.$CityPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      cityId: string
      name: string
      category: string
      description: string | null
      pricePerNight: number
      currency: string
      rating: number | null
      amenities: string | null
      address: string | null
      imageUrl: string | null
      contactPhone: string | null
      website: string | null
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["hotel"]>
    composites: {}
  }

  type HotelGetPayload<S extends boolean | null | undefined | HotelDefaultArgs> = $Result.GetResult<Prisma.$HotelPayload, S>

  type HotelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<HotelFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HotelCountAggregateInputType | true
    }

  export interface HotelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Hotel'], meta: { name: 'Hotel' } }
    /**
     * Find zero or one Hotel that matches the filter.
     * @param {HotelFindUniqueArgs} args - Arguments to find a Hotel
     * @example
     * // Get one Hotel
     * const hotel = await prisma.hotel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HotelFindUniqueArgs>(args: SelectSubset<T, HotelFindUniqueArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Hotel that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HotelFindUniqueOrThrowArgs} args - Arguments to find a Hotel
     * @example
     * // Get one Hotel
     * const hotel = await prisma.hotel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HotelFindUniqueOrThrowArgs>(args: SelectSubset<T, HotelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Hotel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelFindFirstArgs} args - Arguments to find a Hotel
     * @example
     * // Get one Hotel
     * const hotel = await prisma.hotel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HotelFindFirstArgs>(args?: SelectSubset<T, HotelFindFirstArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Hotel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelFindFirstOrThrowArgs} args - Arguments to find a Hotel
     * @example
     * // Get one Hotel
     * const hotel = await prisma.hotel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HotelFindFirstOrThrowArgs>(args?: SelectSubset<T, HotelFindFirstOrThrowArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Hotels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Hotels
     * const hotels = await prisma.hotel.findMany()
     * 
     * // Get first 10 Hotels
     * const hotels = await prisma.hotel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const hotelWithIdOnly = await prisma.hotel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HotelFindManyArgs>(args?: SelectSubset<T, HotelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Hotel.
     * @param {HotelCreateArgs} args - Arguments to create a Hotel.
     * @example
     * // Create one Hotel
     * const Hotel = await prisma.hotel.create({
     *   data: {
     *     // ... data to create a Hotel
     *   }
     * })
     * 
     */
    create<T extends HotelCreateArgs>(args: SelectSubset<T, HotelCreateArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Hotels.
     * @param {HotelCreateManyArgs} args - Arguments to create many Hotels.
     * @example
     * // Create many Hotels
     * const hotel = await prisma.hotel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HotelCreateManyArgs>(args?: SelectSubset<T, HotelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Hotels and returns the data saved in the database.
     * @param {HotelCreateManyAndReturnArgs} args - Arguments to create many Hotels.
     * @example
     * // Create many Hotels
     * const hotel = await prisma.hotel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Hotels and only return the `id`
     * const hotelWithIdOnly = await prisma.hotel.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HotelCreateManyAndReturnArgs>(args?: SelectSubset<T, HotelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Hotel.
     * @param {HotelDeleteArgs} args - Arguments to delete one Hotel.
     * @example
     * // Delete one Hotel
     * const Hotel = await prisma.hotel.delete({
     *   where: {
     *     // ... filter to delete one Hotel
     *   }
     * })
     * 
     */
    delete<T extends HotelDeleteArgs>(args: SelectSubset<T, HotelDeleteArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Hotel.
     * @param {HotelUpdateArgs} args - Arguments to update one Hotel.
     * @example
     * // Update one Hotel
     * const hotel = await prisma.hotel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HotelUpdateArgs>(args: SelectSubset<T, HotelUpdateArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Hotels.
     * @param {HotelDeleteManyArgs} args - Arguments to filter Hotels to delete.
     * @example
     * // Delete a few Hotels
     * const { count } = await prisma.hotel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HotelDeleteManyArgs>(args?: SelectSubset<T, HotelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Hotels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Hotels
     * const hotel = await prisma.hotel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HotelUpdateManyArgs>(args: SelectSubset<T, HotelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Hotels and returns the data updated in the database.
     * @param {HotelUpdateManyAndReturnArgs} args - Arguments to update many Hotels.
     * @example
     * // Update many Hotels
     * const hotel = await prisma.hotel.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Hotels and only return the `id`
     * const hotelWithIdOnly = await prisma.hotel.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends HotelUpdateManyAndReturnArgs>(args: SelectSubset<T, HotelUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Hotel.
     * @param {HotelUpsertArgs} args - Arguments to update or create a Hotel.
     * @example
     * // Update or create a Hotel
     * const hotel = await prisma.hotel.upsert({
     *   create: {
     *     // ... data to create a Hotel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Hotel we want to update
     *   }
     * })
     */
    upsert<T extends HotelUpsertArgs>(args: SelectSubset<T, HotelUpsertArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Hotels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelCountArgs} args - Arguments to filter Hotels to count.
     * @example
     * // Count the number of Hotels
     * const count = await prisma.hotel.count({
     *   where: {
     *     // ... the filter for the Hotels we want to count
     *   }
     * })
    **/
    count<T extends HotelCountArgs>(
      args?: Subset<T, HotelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HotelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Hotel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HotelAggregateArgs>(args: Subset<T, HotelAggregateArgs>): Prisma.PrismaPromise<GetHotelAggregateType<T>>

    /**
     * Group by Hotel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HotelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HotelGroupByArgs['orderBy'] }
        : { orderBy?: HotelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HotelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHotelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Hotel model
   */
  readonly fields: HotelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Hotel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HotelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    city<T extends CityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CityDefaultArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Hotel model
   */
  interface HotelFieldRefs {
    readonly id: FieldRef<"Hotel", 'String'>
    readonly cityId: FieldRef<"Hotel", 'String'>
    readonly name: FieldRef<"Hotel", 'String'>
    readonly category: FieldRef<"Hotel", 'String'>
    readonly description: FieldRef<"Hotel", 'String'>
    readonly pricePerNight: FieldRef<"Hotel", 'Float'>
    readonly currency: FieldRef<"Hotel", 'String'>
    readonly rating: FieldRef<"Hotel", 'Float'>
    readonly amenities: FieldRef<"Hotel", 'String'>
    readonly address: FieldRef<"Hotel", 'String'>
    readonly imageUrl: FieldRef<"Hotel", 'String'>
    readonly contactPhone: FieldRef<"Hotel", 'String'>
    readonly website: FieldRef<"Hotel", 'String'>
    readonly createdAt: FieldRef<"Hotel", 'DateTime'>
    readonly updatedAt: FieldRef<"Hotel", 'DateTime'>
    readonly deletedAt: FieldRef<"Hotel", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Hotel findUnique
   */
  export type HotelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hotel
     */
    omit?: HotelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
    /**
     * Filter, which Hotel to fetch.
     */
    where: HotelWhereUniqueInput
  }

  /**
   * Hotel findUniqueOrThrow
   */
  export type HotelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hotel
     */
    omit?: HotelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
    /**
     * Filter, which Hotel to fetch.
     */
    where: HotelWhereUniqueInput
  }

  /**
   * Hotel findFirst
   */
  export type HotelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hotel
     */
    omit?: HotelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
    /**
     * Filter, which Hotel to fetch.
     */
    where?: HotelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hotels to fetch.
     */
    orderBy?: HotelOrderByWithRelationInput | HotelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Hotels.
     */
    cursor?: HotelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hotels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hotels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Hotels.
     */
    distinct?: HotelScalarFieldEnum | HotelScalarFieldEnum[]
  }

  /**
   * Hotel findFirstOrThrow
   */
  export type HotelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hotel
     */
    omit?: HotelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
    /**
     * Filter, which Hotel to fetch.
     */
    where?: HotelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hotels to fetch.
     */
    orderBy?: HotelOrderByWithRelationInput | HotelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Hotels.
     */
    cursor?: HotelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hotels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hotels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Hotels.
     */
    distinct?: HotelScalarFieldEnum | HotelScalarFieldEnum[]
  }

  /**
   * Hotel findMany
   */
  export type HotelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hotel
     */
    omit?: HotelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
    /**
     * Filter, which Hotels to fetch.
     */
    where?: HotelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hotels to fetch.
     */
    orderBy?: HotelOrderByWithRelationInput | HotelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Hotels.
     */
    cursor?: HotelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hotels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hotels.
     */
    skip?: number
    distinct?: HotelScalarFieldEnum | HotelScalarFieldEnum[]
  }

  /**
   * Hotel create
   */
  export type HotelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hotel
     */
    omit?: HotelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
    /**
     * The data needed to create a Hotel.
     */
    data: XOR<HotelCreateInput, HotelUncheckedCreateInput>
  }

  /**
   * Hotel createMany
   */
  export type HotelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Hotels.
     */
    data: HotelCreateManyInput | HotelCreateManyInput[]
  }

  /**
   * Hotel createManyAndReturn
   */
  export type HotelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Hotel
     */
    omit?: HotelOmit<ExtArgs> | null
    /**
     * The data used to create many Hotels.
     */
    data: HotelCreateManyInput | HotelCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Hotel update
   */
  export type HotelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hotel
     */
    omit?: HotelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
    /**
     * The data needed to update a Hotel.
     */
    data: XOR<HotelUpdateInput, HotelUncheckedUpdateInput>
    /**
     * Choose, which Hotel to update.
     */
    where: HotelWhereUniqueInput
  }

  /**
   * Hotel updateMany
   */
  export type HotelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Hotels.
     */
    data: XOR<HotelUpdateManyMutationInput, HotelUncheckedUpdateManyInput>
    /**
     * Filter which Hotels to update
     */
    where?: HotelWhereInput
    /**
     * Limit how many Hotels to update.
     */
    limit?: number
  }

  /**
   * Hotel updateManyAndReturn
   */
  export type HotelUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Hotel
     */
    omit?: HotelOmit<ExtArgs> | null
    /**
     * The data used to update Hotels.
     */
    data: XOR<HotelUpdateManyMutationInput, HotelUncheckedUpdateManyInput>
    /**
     * Filter which Hotels to update
     */
    where?: HotelWhereInput
    /**
     * Limit how many Hotels to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Hotel upsert
   */
  export type HotelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hotel
     */
    omit?: HotelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
    /**
     * The filter to search for the Hotel to update in case it exists.
     */
    where: HotelWhereUniqueInput
    /**
     * In case the Hotel found by the `where` argument doesn't exist, create a new Hotel with this data.
     */
    create: XOR<HotelCreateInput, HotelUncheckedCreateInput>
    /**
     * In case the Hotel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HotelUpdateInput, HotelUncheckedUpdateInput>
  }

  /**
   * Hotel delete
   */
  export type HotelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hotel
     */
    omit?: HotelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
    /**
     * Filter which Hotel to delete.
     */
    where: HotelWhereUniqueInput
  }

  /**
   * Hotel deleteMany
   */
  export type HotelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Hotels to delete
     */
    where?: HotelWhereInput
    /**
     * Limit how many Hotels to delete.
     */
    limit?: number
  }

  /**
   * Hotel without action
   */
  export type HotelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hotel
     */
    omit?: HotelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
  }


  /**
   * Model Restaurant
   */

  export type AggregateRestaurant = {
    _count: RestaurantCountAggregateOutputType | null
    _avg: RestaurantAvgAggregateOutputType | null
    _sum: RestaurantSumAggregateOutputType | null
    _min: RestaurantMinAggregateOutputType | null
    _max: RestaurantMaxAggregateOutputType | null
  }

  export type RestaurantAvgAggregateOutputType = {
    avgMealCost: number | null
    rating: number | null
  }

  export type RestaurantSumAggregateOutputType = {
    avgMealCost: number | null
    rating: number | null
  }

  export type RestaurantMinAggregateOutputType = {
    id: string | null
    cityId: string | null
    name: string | null
    cuisineType: string | null
    priceRange: string | null
    avgMealCost: number | null
    currency: string | null
    rating: number | null
    description: string | null
    address: string | null
    imageUrl: string | null
    isVegetarian: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type RestaurantMaxAggregateOutputType = {
    id: string | null
    cityId: string | null
    name: string | null
    cuisineType: string | null
    priceRange: string | null
    avgMealCost: number | null
    currency: string | null
    rating: number | null
    description: string | null
    address: string | null
    imageUrl: string | null
    isVegetarian: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type RestaurantCountAggregateOutputType = {
    id: number
    cityId: number
    name: number
    cuisineType: number
    priceRange: number
    avgMealCost: number
    currency: number
    rating: number
    description: number
    address: number
    imageUrl: number
    isVegetarian: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type RestaurantAvgAggregateInputType = {
    avgMealCost?: true
    rating?: true
  }

  export type RestaurantSumAggregateInputType = {
    avgMealCost?: true
    rating?: true
  }

  export type RestaurantMinAggregateInputType = {
    id?: true
    cityId?: true
    name?: true
    cuisineType?: true
    priceRange?: true
    avgMealCost?: true
    currency?: true
    rating?: true
    description?: true
    address?: true
    imageUrl?: true
    isVegetarian?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type RestaurantMaxAggregateInputType = {
    id?: true
    cityId?: true
    name?: true
    cuisineType?: true
    priceRange?: true
    avgMealCost?: true
    currency?: true
    rating?: true
    description?: true
    address?: true
    imageUrl?: true
    isVegetarian?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type RestaurantCountAggregateInputType = {
    id?: true
    cityId?: true
    name?: true
    cuisineType?: true
    priceRange?: true
    avgMealCost?: true
    currency?: true
    rating?: true
    description?: true
    address?: true
    imageUrl?: true
    isVegetarian?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type RestaurantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Restaurant to aggregate.
     */
    where?: RestaurantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Restaurants to fetch.
     */
    orderBy?: RestaurantOrderByWithRelationInput | RestaurantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RestaurantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Restaurants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Restaurants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Restaurants
    **/
    _count?: true | RestaurantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RestaurantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RestaurantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RestaurantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RestaurantMaxAggregateInputType
  }

  export type GetRestaurantAggregateType<T extends RestaurantAggregateArgs> = {
        [P in keyof T & keyof AggregateRestaurant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRestaurant[P]>
      : GetScalarType<T[P], AggregateRestaurant[P]>
  }




  export type RestaurantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RestaurantWhereInput
    orderBy?: RestaurantOrderByWithAggregationInput | RestaurantOrderByWithAggregationInput[]
    by: RestaurantScalarFieldEnum[] | RestaurantScalarFieldEnum
    having?: RestaurantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RestaurantCountAggregateInputType | true
    _avg?: RestaurantAvgAggregateInputType
    _sum?: RestaurantSumAggregateInputType
    _min?: RestaurantMinAggregateInputType
    _max?: RestaurantMaxAggregateInputType
  }

  export type RestaurantGroupByOutputType = {
    id: string
    cityId: string
    name: string
    cuisineType: string
    priceRange: string
    avgMealCost: number
    currency: string
    rating: number | null
    description: string | null
    address: string | null
    imageUrl: string | null
    isVegetarian: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: RestaurantCountAggregateOutputType | null
    _avg: RestaurantAvgAggregateOutputType | null
    _sum: RestaurantSumAggregateOutputType | null
    _min: RestaurantMinAggregateOutputType | null
    _max: RestaurantMaxAggregateOutputType | null
  }

  type GetRestaurantGroupByPayload<T extends RestaurantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RestaurantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RestaurantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RestaurantGroupByOutputType[P]>
            : GetScalarType<T[P], RestaurantGroupByOutputType[P]>
        }
      >
    >


  export type RestaurantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cityId?: boolean
    name?: boolean
    cuisineType?: boolean
    priceRange?: boolean
    avgMealCost?: boolean
    currency?: boolean
    rating?: boolean
    description?: boolean
    address?: boolean
    imageUrl?: boolean
    isVegetarian?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    city?: boolean | CityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["restaurant"]>

  export type RestaurantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cityId?: boolean
    name?: boolean
    cuisineType?: boolean
    priceRange?: boolean
    avgMealCost?: boolean
    currency?: boolean
    rating?: boolean
    description?: boolean
    address?: boolean
    imageUrl?: boolean
    isVegetarian?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    city?: boolean | CityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["restaurant"]>

  export type RestaurantSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cityId?: boolean
    name?: boolean
    cuisineType?: boolean
    priceRange?: boolean
    avgMealCost?: boolean
    currency?: boolean
    rating?: boolean
    description?: boolean
    address?: boolean
    imageUrl?: boolean
    isVegetarian?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    city?: boolean | CityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["restaurant"]>

  export type RestaurantSelectScalar = {
    id?: boolean
    cityId?: boolean
    name?: boolean
    cuisineType?: boolean
    priceRange?: boolean
    avgMealCost?: boolean
    currency?: boolean
    rating?: boolean
    description?: boolean
    address?: boolean
    imageUrl?: boolean
    isVegetarian?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type RestaurantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cityId" | "name" | "cuisineType" | "priceRange" | "avgMealCost" | "currency" | "rating" | "description" | "address" | "imageUrl" | "isVegetarian" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["restaurant"]>
  export type RestaurantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    city?: boolean | CityDefaultArgs<ExtArgs>
  }
  export type RestaurantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    city?: boolean | CityDefaultArgs<ExtArgs>
  }
  export type RestaurantIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    city?: boolean | CityDefaultArgs<ExtArgs>
  }

  export type $RestaurantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Restaurant"
    objects: {
      city: Prisma.$CityPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      cityId: string
      name: string
      cuisineType: string
      priceRange: string
      avgMealCost: number
      currency: string
      rating: number | null
      description: string | null
      address: string | null
      imageUrl: string | null
      isVegetarian: boolean
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["restaurant"]>
    composites: {}
  }

  type RestaurantGetPayload<S extends boolean | null | undefined | RestaurantDefaultArgs> = $Result.GetResult<Prisma.$RestaurantPayload, S>

  type RestaurantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RestaurantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RestaurantCountAggregateInputType | true
    }

  export interface RestaurantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Restaurant'], meta: { name: 'Restaurant' } }
    /**
     * Find zero or one Restaurant that matches the filter.
     * @param {RestaurantFindUniqueArgs} args - Arguments to find a Restaurant
     * @example
     * // Get one Restaurant
     * const restaurant = await prisma.restaurant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RestaurantFindUniqueArgs>(args: SelectSubset<T, RestaurantFindUniqueArgs<ExtArgs>>): Prisma__RestaurantClient<$Result.GetResult<Prisma.$RestaurantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Restaurant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RestaurantFindUniqueOrThrowArgs} args - Arguments to find a Restaurant
     * @example
     * // Get one Restaurant
     * const restaurant = await prisma.restaurant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RestaurantFindUniqueOrThrowArgs>(args: SelectSubset<T, RestaurantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RestaurantClient<$Result.GetResult<Prisma.$RestaurantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Restaurant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantFindFirstArgs} args - Arguments to find a Restaurant
     * @example
     * // Get one Restaurant
     * const restaurant = await prisma.restaurant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RestaurantFindFirstArgs>(args?: SelectSubset<T, RestaurantFindFirstArgs<ExtArgs>>): Prisma__RestaurantClient<$Result.GetResult<Prisma.$RestaurantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Restaurant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantFindFirstOrThrowArgs} args - Arguments to find a Restaurant
     * @example
     * // Get one Restaurant
     * const restaurant = await prisma.restaurant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RestaurantFindFirstOrThrowArgs>(args?: SelectSubset<T, RestaurantFindFirstOrThrowArgs<ExtArgs>>): Prisma__RestaurantClient<$Result.GetResult<Prisma.$RestaurantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Restaurants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Restaurants
     * const restaurants = await prisma.restaurant.findMany()
     * 
     * // Get first 10 Restaurants
     * const restaurants = await prisma.restaurant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const restaurantWithIdOnly = await prisma.restaurant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RestaurantFindManyArgs>(args?: SelectSubset<T, RestaurantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RestaurantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Restaurant.
     * @param {RestaurantCreateArgs} args - Arguments to create a Restaurant.
     * @example
     * // Create one Restaurant
     * const Restaurant = await prisma.restaurant.create({
     *   data: {
     *     // ... data to create a Restaurant
     *   }
     * })
     * 
     */
    create<T extends RestaurantCreateArgs>(args: SelectSubset<T, RestaurantCreateArgs<ExtArgs>>): Prisma__RestaurantClient<$Result.GetResult<Prisma.$RestaurantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Restaurants.
     * @param {RestaurantCreateManyArgs} args - Arguments to create many Restaurants.
     * @example
     * // Create many Restaurants
     * const restaurant = await prisma.restaurant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RestaurantCreateManyArgs>(args?: SelectSubset<T, RestaurantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Restaurants and returns the data saved in the database.
     * @param {RestaurantCreateManyAndReturnArgs} args - Arguments to create many Restaurants.
     * @example
     * // Create many Restaurants
     * const restaurant = await prisma.restaurant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Restaurants and only return the `id`
     * const restaurantWithIdOnly = await prisma.restaurant.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RestaurantCreateManyAndReturnArgs>(args?: SelectSubset<T, RestaurantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RestaurantPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Restaurant.
     * @param {RestaurantDeleteArgs} args - Arguments to delete one Restaurant.
     * @example
     * // Delete one Restaurant
     * const Restaurant = await prisma.restaurant.delete({
     *   where: {
     *     // ... filter to delete one Restaurant
     *   }
     * })
     * 
     */
    delete<T extends RestaurantDeleteArgs>(args: SelectSubset<T, RestaurantDeleteArgs<ExtArgs>>): Prisma__RestaurantClient<$Result.GetResult<Prisma.$RestaurantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Restaurant.
     * @param {RestaurantUpdateArgs} args - Arguments to update one Restaurant.
     * @example
     * // Update one Restaurant
     * const restaurant = await prisma.restaurant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RestaurantUpdateArgs>(args: SelectSubset<T, RestaurantUpdateArgs<ExtArgs>>): Prisma__RestaurantClient<$Result.GetResult<Prisma.$RestaurantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Restaurants.
     * @param {RestaurantDeleteManyArgs} args - Arguments to filter Restaurants to delete.
     * @example
     * // Delete a few Restaurants
     * const { count } = await prisma.restaurant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RestaurantDeleteManyArgs>(args?: SelectSubset<T, RestaurantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Restaurants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Restaurants
     * const restaurant = await prisma.restaurant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RestaurantUpdateManyArgs>(args: SelectSubset<T, RestaurantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Restaurants and returns the data updated in the database.
     * @param {RestaurantUpdateManyAndReturnArgs} args - Arguments to update many Restaurants.
     * @example
     * // Update many Restaurants
     * const restaurant = await prisma.restaurant.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Restaurants and only return the `id`
     * const restaurantWithIdOnly = await prisma.restaurant.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RestaurantUpdateManyAndReturnArgs>(args: SelectSubset<T, RestaurantUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RestaurantPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Restaurant.
     * @param {RestaurantUpsertArgs} args - Arguments to update or create a Restaurant.
     * @example
     * // Update or create a Restaurant
     * const restaurant = await prisma.restaurant.upsert({
     *   create: {
     *     // ... data to create a Restaurant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Restaurant we want to update
     *   }
     * })
     */
    upsert<T extends RestaurantUpsertArgs>(args: SelectSubset<T, RestaurantUpsertArgs<ExtArgs>>): Prisma__RestaurantClient<$Result.GetResult<Prisma.$RestaurantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Restaurants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantCountArgs} args - Arguments to filter Restaurants to count.
     * @example
     * // Count the number of Restaurants
     * const count = await prisma.restaurant.count({
     *   where: {
     *     // ... the filter for the Restaurants we want to count
     *   }
     * })
    **/
    count<T extends RestaurantCountArgs>(
      args?: Subset<T, RestaurantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RestaurantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Restaurant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RestaurantAggregateArgs>(args: Subset<T, RestaurantAggregateArgs>): Prisma.PrismaPromise<GetRestaurantAggregateType<T>>

    /**
     * Group by Restaurant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RestaurantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RestaurantGroupByArgs['orderBy'] }
        : { orderBy?: RestaurantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RestaurantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRestaurantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Restaurant model
   */
  readonly fields: RestaurantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Restaurant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RestaurantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    city<T extends CityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CityDefaultArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Restaurant model
   */
  interface RestaurantFieldRefs {
    readonly id: FieldRef<"Restaurant", 'String'>
    readonly cityId: FieldRef<"Restaurant", 'String'>
    readonly name: FieldRef<"Restaurant", 'String'>
    readonly cuisineType: FieldRef<"Restaurant", 'String'>
    readonly priceRange: FieldRef<"Restaurant", 'String'>
    readonly avgMealCost: FieldRef<"Restaurant", 'Float'>
    readonly currency: FieldRef<"Restaurant", 'String'>
    readonly rating: FieldRef<"Restaurant", 'Float'>
    readonly description: FieldRef<"Restaurant", 'String'>
    readonly address: FieldRef<"Restaurant", 'String'>
    readonly imageUrl: FieldRef<"Restaurant", 'String'>
    readonly isVegetarian: FieldRef<"Restaurant", 'Boolean'>
    readonly createdAt: FieldRef<"Restaurant", 'DateTime'>
    readonly updatedAt: FieldRef<"Restaurant", 'DateTime'>
    readonly deletedAt: FieldRef<"Restaurant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Restaurant findUnique
   */
  export type RestaurantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Restaurant
     */
    select?: RestaurantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Restaurant
     */
    omit?: RestaurantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantInclude<ExtArgs> | null
    /**
     * Filter, which Restaurant to fetch.
     */
    where: RestaurantWhereUniqueInput
  }

  /**
   * Restaurant findUniqueOrThrow
   */
  export type RestaurantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Restaurant
     */
    select?: RestaurantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Restaurant
     */
    omit?: RestaurantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantInclude<ExtArgs> | null
    /**
     * Filter, which Restaurant to fetch.
     */
    where: RestaurantWhereUniqueInput
  }

  /**
   * Restaurant findFirst
   */
  export type RestaurantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Restaurant
     */
    select?: RestaurantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Restaurant
     */
    omit?: RestaurantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantInclude<ExtArgs> | null
    /**
     * Filter, which Restaurant to fetch.
     */
    where?: RestaurantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Restaurants to fetch.
     */
    orderBy?: RestaurantOrderByWithRelationInput | RestaurantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Restaurants.
     */
    cursor?: RestaurantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Restaurants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Restaurants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Restaurants.
     */
    distinct?: RestaurantScalarFieldEnum | RestaurantScalarFieldEnum[]
  }

  /**
   * Restaurant findFirstOrThrow
   */
  export type RestaurantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Restaurant
     */
    select?: RestaurantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Restaurant
     */
    omit?: RestaurantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantInclude<ExtArgs> | null
    /**
     * Filter, which Restaurant to fetch.
     */
    where?: RestaurantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Restaurants to fetch.
     */
    orderBy?: RestaurantOrderByWithRelationInput | RestaurantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Restaurants.
     */
    cursor?: RestaurantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Restaurants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Restaurants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Restaurants.
     */
    distinct?: RestaurantScalarFieldEnum | RestaurantScalarFieldEnum[]
  }

  /**
   * Restaurant findMany
   */
  export type RestaurantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Restaurant
     */
    select?: RestaurantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Restaurant
     */
    omit?: RestaurantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantInclude<ExtArgs> | null
    /**
     * Filter, which Restaurants to fetch.
     */
    where?: RestaurantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Restaurants to fetch.
     */
    orderBy?: RestaurantOrderByWithRelationInput | RestaurantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Restaurants.
     */
    cursor?: RestaurantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Restaurants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Restaurants.
     */
    skip?: number
    distinct?: RestaurantScalarFieldEnum | RestaurantScalarFieldEnum[]
  }

  /**
   * Restaurant create
   */
  export type RestaurantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Restaurant
     */
    select?: RestaurantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Restaurant
     */
    omit?: RestaurantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantInclude<ExtArgs> | null
    /**
     * The data needed to create a Restaurant.
     */
    data: XOR<RestaurantCreateInput, RestaurantUncheckedCreateInput>
  }

  /**
   * Restaurant createMany
   */
  export type RestaurantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Restaurants.
     */
    data: RestaurantCreateManyInput | RestaurantCreateManyInput[]
  }

  /**
   * Restaurant createManyAndReturn
   */
  export type RestaurantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Restaurant
     */
    select?: RestaurantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Restaurant
     */
    omit?: RestaurantOmit<ExtArgs> | null
    /**
     * The data used to create many Restaurants.
     */
    data: RestaurantCreateManyInput | RestaurantCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Restaurant update
   */
  export type RestaurantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Restaurant
     */
    select?: RestaurantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Restaurant
     */
    omit?: RestaurantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantInclude<ExtArgs> | null
    /**
     * The data needed to update a Restaurant.
     */
    data: XOR<RestaurantUpdateInput, RestaurantUncheckedUpdateInput>
    /**
     * Choose, which Restaurant to update.
     */
    where: RestaurantWhereUniqueInput
  }

  /**
   * Restaurant updateMany
   */
  export type RestaurantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Restaurants.
     */
    data: XOR<RestaurantUpdateManyMutationInput, RestaurantUncheckedUpdateManyInput>
    /**
     * Filter which Restaurants to update
     */
    where?: RestaurantWhereInput
    /**
     * Limit how many Restaurants to update.
     */
    limit?: number
  }

  /**
   * Restaurant updateManyAndReturn
   */
  export type RestaurantUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Restaurant
     */
    select?: RestaurantSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Restaurant
     */
    omit?: RestaurantOmit<ExtArgs> | null
    /**
     * The data used to update Restaurants.
     */
    data: XOR<RestaurantUpdateManyMutationInput, RestaurantUncheckedUpdateManyInput>
    /**
     * Filter which Restaurants to update
     */
    where?: RestaurantWhereInput
    /**
     * Limit how many Restaurants to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Restaurant upsert
   */
  export type RestaurantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Restaurant
     */
    select?: RestaurantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Restaurant
     */
    omit?: RestaurantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantInclude<ExtArgs> | null
    /**
     * The filter to search for the Restaurant to update in case it exists.
     */
    where: RestaurantWhereUniqueInput
    /**
     * In case the Restaurant found by the `where` argument doesn't exist, create a new Restaurant with this data.
     */
    create: XOR<RestaurantCreateInput, RestaurantUncheckedCreateInput>
    /**
     * In case the Restaurant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RestaurantUpdateInput, RestaurantUncheckedUpdateInput>
  }

  /**
   * Restaurant delete
   */
  export type RestaurantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Restaurant
     */
    select?: RestaurantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Restaurant
     */
    omit?: RestaurantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantInclude<ExtArgs> | null
    /**
     * Filter which Restaurant to delete.
     */
    where: RestaurantWhereUniqueInput
  }

  /**
   * Restaurant deleteMany
   */
  export type RestaurantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Restaurants to delete
     */
    where?: RestaurantWhereInput
    /**
     * Limit how many Restaurants to delete.
     */
    limit?: number
  }

  /**
   * Restaurant without action
   */
  export type RestaurantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Restaurant
     */
    select?: RestaurantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Restaurant
     */
    omit?: RestaurantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantInclude<ExtArgs> | null
  }


  /**
   * Model Transport
   */

  export type AggregateTransport = {
    _count: TransportCountAggregateOutputType | null
    _avg: TransportAvgAggregateOutputType | null
    _sum: TransportSumAggregateOutputType | null
    _min: TransportMinAggregateOutputType | null
    _max: TransportMaxAggregateOutputType | null
  }

  export type TransportAvgAggregateOutputType = {
    durationMinutes: number | null
    price: number | null
  }

  export type TransportSumAggregateOutputType = {
    durationMinutes: number | null
    price: number | null
  }

  export type TransportMinAggregateOutputType = {
    id: string | null
    fromCityId: string | null
    toCityId: string | null
    transportType: string | null
    operatorName: string | null
    departureTime: string | null
    arrivalTime: string | null
    durationMinutes: number | null
    price: number | null
    currency: string | null
    classType: string | null
    frequency: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type TransportMaxAggregateOutputType = {
    id: string | null
    fromCityId: string | null
    toCityId: string | null
    transportType: string | null
    operatorName: string | null
    departureTime: string | null
    arrivalTime: string | null
    durationMinutes: number | null
    price: number | null
    currency: string | null
    classType: string | null
    frequency: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type TransportCountAggregateOutputType = {
    id: number
    fromCityId: number
    toCityId: number
    transportType: number
    operatorName: number
    departureTime: number
    arrivalTime: number
    durationMinutes: number
    price: number
    currency: number
    classType: number
    frequency: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type TransportAvgAggregateInputType = {
    durationMinutes?: true
    price?: true
  }

  export type TransportSumAggregateInputType = {
    durationMinutes?: true
    price?: true
  }

  export type TransportMinAggregateInputType = {
    id?: true
    fromCityId?: true
    toCityId?: true
    transportType?: true
    operatorName?: true
    departureTime?: true
    arrivalTime?: true
    durationMinutes?: true
    price?: true
    currency?: true
    classType?: true
    frequency?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type TransportMaxAggregateInputType = {
    id?: true
    fromCityId?: true
    toCityId?: true
    transportType?: true
    operatorName?: true
    departureTime?: true
    arrivalTime?: true
    durationMinutes?: true
    price?: true
    currency?: true
    classType?: true
    frequency?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type TransportCountAggregateInputType = {
    id?: true
    fromCityId?: true
    toCityId?: true
    transportType?: true
    operatorName?: true
    departureTime?: true
    arrivalTime?: true
    durationMinutes?: true
    price?: true
    currency?: true
    classType?: true
    frequency?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type TransportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transport to aggregate.
     */
    where?: TransportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transports to fetch.
     */
    orderBy?: TransportOrderByWithRelationInput | TransportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transports
    **/
    _count?: true | TransportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransportMaxAggregateInputType
  }

  export type GetTransportAggregateType<T extends TransportAggregateArgs> = {
        [P in keyof T & keyof AggregateTransport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransport[P]>
      : GetScalarType<T[P], AggregateTransport[P]>
  }




  export type TransportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransportWhereInput
    orderBy?: TransportOrderByWithAggregationInput | TransportOrderByWithAggregationInput[]
    by: TransportScalarFieldEnum[] | TransportScalarFieldEnum
    having?: TransportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransportCountAggregateInputType | true
    _avg?: TransportAvgAggregateInputType
    _sum?: TransportSumAggregateInputType
    _min?: TransportMinAggregateInputType
    _max?: TransportMaxAggregateInputType
  }

  export type TransportGroupByOutputType = {
    id: string
    fromCityId: string
    toCityId: string
    transportType: string
    operatorName: string
    departureTime: string
    arrivalTime: string
    durationMinutes: number
    price: number
    currency: string
    classType: string | null
    frequency: string | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: TransportCountAggregateOutputType | null
    _avg: TransportAvgAggregateOutputType | null
    _sum: TransportSumAggregateOutputType | null
    _min: TransportMinAggregateOutputType | null
    _max: TransportMaxAggregateOutputType | null
  }

  type GetTransportGroupByPayload<T extends TransportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransportGroupByOutputType[P]>
            : GetScalarType<T[P], TransportGroupByOutputType[P]>
        }
      >
    >


  export type TransportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fromCityId?: boolean
    toCityId?: boolean
    transportType?: boolean
    operatorName?: boolean
    departureTime?: boolean
    arrivalTime?: boolean
    durationMinutes?: boolean
    price?: boolean
    currency?: boolean
    classType?: boolean
    frequency?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    fromCity?: boolean | CityDefaultArgs<ExtArgs>
    toCity?: boolean | CityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transport"]>

  export type TransportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fromCityId?: boolean
    toCityId?: boolean
    transportType?: boolean
    operatorName?: boolean
    departureTime?: boolean
    arrivalTime?: boolean
    durationMinutes?: boolean
    price?: boolean
    currency?: boolean
    classType?: boolean
    frequency?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    fromCity?: boolean | CityDefaultArgs<ExtArgs>
    toCity?: boolean | CityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transport"]>

  export type TransportSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fromCityId?: boolean
    toCityId?: boolean
    transportType?: boolean
    operatorName?: boolean
    departureTime?: boolean
    arrivalTime?: boolean
    durationMinutes?: boolean
    price?: boolean
    currency?: boolean
    classType?: boolean
    frequency?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    fromCity?: boolean | CityDefaultArgs<ExtArgs>
    toCity?: boolean | CityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transport"]>

  export type TransportSelectScalar = {
    id?: boolean
    fromCityId?: boolean
    toCityId?: boolean
    transportType?: boolean
    operatorName?: boolean
    departureTime?: boolean
    arrivalTime?: boolean
    durationMinutes?: boolean
    price?: boolean
    currency?: boolean
    classType?: boolean
    frequency?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type TransportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "fromCityId" | "toCityId" | "transportType" | "operatorName" | "departureTime" | "arrivalTime" | "durationMinutes" | "price" | "currency" | "classType" | "frequency" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["transport"]>
  export type TransportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fromCity?: boolean | CityDefaultArgs<ExtArgs>
    toCity?: boolean | CityDefaultArgs<ExtArgs>
  }
  export type TransportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fromCity?: boolean | CityDefaultArgs<ExtArgs>
    toCity?: boolean | CityDefaultArgs<ExtArgs>
  }
  export type TransportIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fromCity?: boolean | CityDefaultArgs<ExtArgs>
    toCity?: boolean | CityDefaultArgs<ExtArgs>
  }

  export type $TransportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Transport"
    objects: {
      fromCity: Prisma.$CityPayload<ExtArgs>
      toCity: Prisma.$CityPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      fromCityId: string
      toCityId: string
      transportType: string
      operatorName: string
      departureTime: string
      arrivalTime: string
      durationMinutes: number
      price: number
      currency: string
      classType: string | null
      frequency: string | null
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["transport"]>
    composites: {}
  }

  type TransportGetPayload<S extends boolean | null | undefined | TransportDefaultArgs> = $Result.GetResult<Prisma.$TransportPayload, S>

  type TransportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransportCountAggregateInputType | true
    }

  export interface TransportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transport'], meta: { name: 'Transport' } }
    /**
     * Find zero or one Transport that matches the filter.
     * @param {TransportFindUniqueArgs} args - Arguments to find a Transport
     * @example
     * // Get one Transport
     * const transport = await prisma.transport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransportFindUniqueArgs>(args: SelectSubset<T, TransportFindUniqueArgs<ExtArgs>>): Prisma__TransportClient<$Result.GetResult<Prisma.$TransportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Transport that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransportFindUniqueOrThrowArgs} args - Arguments to find a Transport
     * @example
     * // Get one Transport
     * const transport = await prisma.transport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransportFindUniqueOrThrowArgs>(args: SelectSubset<T, TransportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransportClient<$Result.GetResult<Prisma.$TransportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransportFindFirstArgs} args - Arguments to find a Transport
     * @example
     * // Get one Transport
     * const transport = await prisma.transport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransportFindFirstArgs>(args?: SelectSubset<T, TransportFindFirstArgs<ExtArgs>>): Prisma__TransportClient<$Result.GetResult<Prisma.$TransportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransportFindFirstOrThrowArgs} args - Arguments to find a Transport
     * @example
     * // Get one Transport
     * const transport = await prisma.transport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransportFindFirstOrThrowArgs>(args?: SelectSubset<T, TransportFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransportClient<$Result.GetResult<Prisma.$TransportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Transports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transports
     * const transports = await prisma.transport.findMany()
     * 
     * // Get first 10 Transports
     * const transports = await prisma.transport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transportWithIdOnly = await prisma.transport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransportFindManyArgs>(args?: SelectSubset<T, TransportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Transport.
     * @param {TransportCreateArgs} args - Arguments to create a Transport.
     * @example
     * // Create one Transport
     * const Transport = await prisma.transport.create({
     *   data: {
     *     // ... data to create a Transport
     *   }
     * })
     * 
     */
    create<T extends TransportCreateArgs>(args: SelectSubset<T, TransportCreateArgs<ExtArgs>>): Prisma__TransportClient<$Result.GetResult<Prisma.$TransportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Transports.
     * @param {TransportCreateManyArgs} args - Arguments to create many Transports.
     * @example
     * // Create many Transports
     * const transport = await prisma.transport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransportCreateManyArgs>(args?: SelectSubset<T, TransportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transports and returns the data saved in the database.
     * @param {TransportCreateManyAndReturnArgs} args - Arguments to create many Transports.
     * @example
     * // Create many Transports
     * const transport = await prisma.transport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transports and only return the `id`
     * const transportWithIdOnly = await prisma.transport.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransportCreateManyAndReturnArgs>(args?: SelectSubset<T, TransportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransportPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Transport.
     * @param {TransportDeleteArgs} args - Arguments to delete one Transport.
     * @example
     * // Delete one Transport
     * const Transport = await prisma.transport.delete({
     *   where: {
     *     // ... filter to delete one Transport
     *   }
     * })
     * 
     */
    delete<T extends TransportDeleteArgs>(args: SelectSubset<T, TransportDeleteArgs<ExtArgs>>): Prisma__TransportClient<$Result.GetResult<Prisma.$TransportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Transport.
     * @param {TransportUpdateArgs} args - Arguments to update one Transport.
     * @example
     * // Update one Transport
     * const transport = await prisma.transport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransportUpdateArgs>(args: SelectSubset<T, TransportUpdateArgs<ExtArgs>>): Prisma__TransportClient<$Result.GetResult<Prisma.$TransportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Transports.
     * @param {TransportDeleteManyArgs} args - Arguments to filter Transports to delete.
     * @example
     * // Delete a few Transports
     * const { count } = await prisma.transport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransportDeleteManyArgs>(args?: SelectSubset<T, TransportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transports
     * const transport = await prisma.transport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransportUpdateManyArgs>(args: SelectSubset<T, TransportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transports and returns the data updated in the database.
     * @param {TransportUpdateManyAndReturnArgs} args - Arguments to update many Transports.
     * @example
     * // Update many Transports
     * const transport = await prisma.transport.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Transports and only return the `id`
     * const transportWithIdOnly = await prisma.transport.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TransportUpdateManyAndReturnArgs>(args: SelectSubset<T, TransportUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransportPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Transport.
     * @param {TransportUpsertArgs} args - Arguments to update or create a Transport.
     * @example
     * // Update or create a Transport
     * const transport = await prisma.transport.upsert({
     *   create: {
     *     // ... data to create a Transport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transport we want to update
     *   }
     * })
     */
    upsert<T extends TransportUpsertArgs>(args: SelectSubset<T, TransportUpsertArgs<ExtArgs>>): Prisma__TransportClient<$Result.GetResult<Prisma.$TransportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Transports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransportCountArgs} args - Arguments to filter Transports to count.
     * @example
     * // Count the number of Transports
     * const count = await prisma.transport.count({
     *   where: {
     *     // ... the filter for the Transports we want to count
     *   }
     * })
    **/
    count<T extends TransportCountArgs>(
      args?: Subset<T, TransportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransportAggregateArgs>(args: Subset<T, TransportAggregateArgs>): Prisma.PrismaPromise<GetTransportAggregateType<T>>

    /**
     * Group by Transport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransportGroupByArgs['orderBy'] }
        : { orderBy?: TransportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transport model
   */
  readonly fields: TransportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    fromCity<T extends CityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CityDefaultArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    toCity<T extends CityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CityDefaultArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Transport model
   */
  interface TransportFieldRefs {
    readonly id: FieldRef<"Transport", 'String'>
    readonly fromCityId: FieldRef<"Transport", 'String'>
    readonly toCityId: FieldRef<"Transport", 'String'>
    readonly transportType: FieldRef<"Transport", 'String'>
    readonly operatorName: FieldRef<"Transport", 'String'>
    readonly departureTime: FieldRef<"Transport", 'String'>
    readonly arrivalTime: FieldRef<"Transport", 'String'>
    readonly durationMinutes: FieldRef<"Transport", 'Int'>
    readonly price: FieldRef<"Transport", 'Float'>
    readonly currency: FieldRef<"Transport", 'String'>
    readonly classType: FieldRef<"Transport", 'String'>
    readonly frequency: FieldRef<"Transport", 'String'>
    readonly createdAt: FieldRef<"Transport", 'DateTime'>
    readonly updatedAt: FieldRef<"Transport", 'DateTime'>
    readonly deletedAt: FieldRef<"Transport", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Transport findUnique
   */
  export type TransportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transport
     */
    select?: TransportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transport
     */
    omit?: TransportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransportInclude<ExtArgs> | null
    /**
     * Filter, which Transport to fetch.
     */
    where: TransportWhereUniqueInput
  }

  /**
   * Transport findUniqueOrThrow
   */
  export type TransportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transport
     */
    select?: TransportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transport
     */
    omit?: TransportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransportInclude<ExtArgs> | null
    /**
     * Filter, which Transport to fetch.
     */
    where: TransportWhereUniqueInput
  }

  /**
   * Transport findFirst
   */
  export type TransportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transport
     */
    select?: TransportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transport
     */
    omit?: TransportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransportInclude<ExtArgs> | null
    /**
     * Filter, which Transport to fetch.
     */
    where?: TransportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transports to fetch.
     */
    orderBy?: TransportOrderByWithRelationInput | TransportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transports.
     */
    cursor?: TransportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transports.
     */
    distinct?: TransportScalarFieldEnum | TransportScalarFieldEnum[]
  }

  /**
   * Transport findFirstOrThrow
   */
  export type TransportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transport
     */
    select?: TransportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transport
     */
    omit?: TransportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransportInclude<ExtArgs> | null
    /**
     * Filter, which Transport to fetch.
     */
    where?: TransportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transports to fetch.
     */
    orderBy?: TransportOrderByWithRelationInput | TransportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transports.
     */
    cursor?: TransportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transports.
     */
    distinct?: TransportScalarFieldEnum | TransportScalarFieldEnum[]
  }

  /**
   * Transport findMany
   */
  export type TransportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transport
     */
    select?: TransportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transport
     */
    omit?: TransportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransportInclude<ExtArgs> | null
    /**
     * Filter, which Transports to fetch.
     */
    where?: TransportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transports to fetch.
     */
    orderBy?: TransportOrderByWithRelationInput | TransportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transports.
     */
    cursor?: TransportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transports.
     */
    skip?: number
    distinct?: TransportScalarFieldEnum | TransportScalarFieldEnum[]
  }

  /**
   * Transport create
   */
  export type TransportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transport
     */
    select?: TransportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transport
     */
    omit?: TransportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransportInclude<ExtArgs> | null
    /**
     * The data needed to create a Transport.
     */
    data: XOR<TransportCreateInput, TransportUncheckedCreateInput>
  }

  /**
   * Transport createMany
   */
  export type TransportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transports.
     */
    data: TransportCreateManyInput | TransportCreateManyInput[]
  }

  /**
   * Transport createManyAndReturn
   */
  export type TransportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transport
     */
    select?: TransportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transport
     */
    omit?: TransportOmit<ExtArgs> | null
    /**
     * The data used to create many Transports.
     */
    data: TransportCreateManyInput | TransportCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transport update
   */
  export type TransportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transport
     */
    select?: TransportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transport
     */
    omit?: TransportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransportInclude<ExtArgs> | null
    /**
     * The data needed to update a Transport.
     */
    data: XOR<TransportUpdateInput, TransportUncheckedUpdateInput>
    /**
     * Choose, which Transport to update.
     */
    where: TransportWhereUniqueInput
  }

  /**
   * Transport updateMany
   */
  export type TransportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transports.
     */
    data: XOR<TransportUpdateManyMutationInput, TransportUncheckedUpdateManyInput>
    /**
     * Filter which Transports to update
     */
    where?: TransportWhereInput
    /**
     * Limit how many Transports to update.
     */
    limit?: number
  }

  /**
   * Transport updateManyAndReturn
   */
  export type TransportUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transport
     */
    select?: TransportSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transport
     */
    omit?: TransportOmit<ExtArgs> | null
    /**
     * The data used to update Transports.
     */
    data: XOR<TransportUpdateManyMutationInput, TransportUncheckedUpdateManyInput>
    /**
     * Filter which Transports to update
     */
    where?: TransportWhereInput
    /**
     * Limit how many Transports to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransportIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transport upsert
   */
  export type TransportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transport
     */
    select?: TransportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transport
     */
    omit?: TransportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransportInclude<ExtArgs> | null
    /**
     * The filter to search for the Transport to update in case it exists.
     */
    where: TransportWhereUniqueInput
    /**
     * In case the Transport found by the `where` argument doesn't exist, create a new Transport with this data.
     */
    create: XOR<TransportCreateInput, TransportUncheckedCreateInput>
    /**
     * In case the Transport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransportUpdateInput, TransportUncheckedUpdateInput>
  }

  /**
   * Transport delete
   */
  export type TransportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transport
     */
    select?: TransportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transport
     */
    omit?: TransportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransportInclude<ExtArgs> | null
    /**
     * Filter which Transport to delete.
     */
    where: TransportWhereUniqueInput
  }

  /**
   * Transport deleteMany
   */
  export type TransportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transports to delete
     */
    where?: TransportWhereInput
    /**
     * Limit how many Transports to delete.
     */
    limit?: number
  }

  /**
   * Transport without action
   */
  export type TransportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transport
     */
    select?: TransportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transport
     */
    omit?: TransportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransportInclude<ExtArgs> | null
  }


  /**
   * Model Trip
   */

  export type AggregateTrip = {
    _count: TripCountAggregateOutputType | null
    _avg: TripAvgAggregateOutputType | null
    _sum: TripSumAggregateOutputType | null
    _min: TripMinAggregateOutputType | null
    _max: TripMaxAggregateOutputType | null
  }

  export type TripAvgAggregateOutputType = {
    totalEstimatedCost: number | null
    versionNumber: number | null
  }

  export type TripSumAggregateOutputType = {
    totalEstimatedCost: number | null
    versionNumber: number | null
  }

  export type TripMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    description: string | null
    startDate: Date | null
    endDate: Date | null
    coverPhotoUrl: string | null
    status: string | null
    isPublic: boolean | null
    totalEstimatedCost: number | null
    currency: string | null
    travelStyle: string | null
    versionNumber: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type TripMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    description: string | null
    startDate: Date | null
    endDate: Date | null
    coverPhotoUrl: string | null
    status: string | null
    isPublic: boolean | null
    totalEstimatedCost: number | null
    currency: string | null
    travelStyle: string | null
    versionNumber: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type TripCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    description: number
    startDate: number
    endDate: number
    coverPhotoUrl: number
    status: number
    isPublic: number
    totalEstimatedCost: number
    currency: number
    travelStyle: number
    versionNumber: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type TripAvgAggregateInputType = {
    totalEstimatedCost?: true
    versionNumber?: true
  }

  export type TripSumAggregateInputType = {
    totalEstimatedCost?: true
    versionNumber?: true
  }

  export type TripMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    description?: true
    startDate?: true
    endDate?: true
    coverPhotoUrl?: true
    status?: true
    isPublic?: true
    totalEstimatedCost?: true
    currency?: true
    travelStyle?: true
    versionNumber?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type TripMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    description?: true
    startDate?: true
    endDate?: true
    coverPhotoUrl?: true
    status?: true
    isPublic?: true
    totalEstimatedCost?: true
    currency?: true
    travelStyle?: true
    versionNumber?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type TripCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    description?: true
    startDate?: true
    endDate?: true
    coverPhotoUrl?: true
    status?: true
    isPublic?: true
    totalEstimatedCost?: true
    currency?: true
    travelStyle?: true
    versionNumber?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type TripAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Trip to aggregate.
     */
    where?: TripWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trips to fetch.
     */
    orderBy?: TripOrderByWithRelationInput | TripOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TripWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trips.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Trips
    **/
    _count?: true | TripCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TripAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TripSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TripMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TripMaxAggregateInputType
  }

  export type GetTripAggregateType<T extends TripAggregateArgs> = {
        [P in keyof T & keyof AggregateTrip]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrip[P]>
      : GetScalarType<T[P], AggregateTrip[P]>
  }




  export type TripGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TripWhereInput
    orderBy?: TripOrderByWithAggregationInput | TripOrderByWithAggregationInput[]
    by: TripScalarFieldEnum[] | TripScalarFieldEnum
    having?: TripScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TripCountAggregateInputType | true
    _avg?: TripAvgAggregateInputType
    _sum?: TripSumAggregateInputType
    _min?: TripMinAggregateInputType
    _max?: TripMaxAggregateInputType
  }

  export type TripGroupByOutputType = {
    id: string
    userId: string
    name: string
    description: string | null
    startDate: Date
    endDate: Date
    coverPhotoUrl: string | null
    status: string
    isPublic: boolean
    totalEstimatedCost: number
    currency: string
    travelStyle: string | null
    versionNumber: number
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: TripCountAggregateOutputType | null
    _avg: TripAvgAggregateOutputType | null
    _sum: TripSumAggregateOutputType | null
    _min: TripMinAggregateOutputType | null
    _max: TripMaxAggregateOutputType | null
  }

  type GetTripGroupByPayload<T extends TripGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TripGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TripGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TripGroupByOutputType[P]>
            : GetScalarType<T[P], TripGroupByOutputType[P]>
        }
      >
    >


  export type TripSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    coverPhotoUrl?: boolean
    status?: boolean
    isPublic?: boolean
    totalEstimatedCost?: boolean
    currency?: boolean
    travelStyle?: boolean
    versionNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    stops?: boolean | Trip$stopsArgs<ExtArgs>
    budgets?: boolean | Trip$budgetsArgs<ExtArgs>
    media?: boolean | Trip$mediaArgs<ExtArgs>
    shares?: boolean | Trip$sharesArgs<ExtArgs>
    versions?: boolean | Trip$versionsArgs<ExtArgs>
    _count?: boolean | TripCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trip"]>

  export type TripSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    coverPhotoUrl?: boolean
    status?: boolean
    isPublic?: boolean
    totalEstimatedCost?: boolean
    currency?: boolean
    travelStyle?: boolean
    versionNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trip"]>

  export type TripSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    coverPhotoUrl?: boolean
    status?: boolean
    isPublic?: boolean
    totalEstimatedCost?: boolean
    currency?: boolean
    travelStyle?: boolean
    versionNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trip"]>

  export type TripSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    coverPhotoUrl?: boolean
    status?: boolean
    isPublic?: boolean
    totalEstimatedCost?: boolean
    currency?: boolean
    travelStyle?: boolean
    versionNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type TripOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "name" | "description" | "startDate" | "endDate" | "coverPhotoUrl" | "status" | "isPublic" | "totalEstimatedCost" | "currency" | "travelStyle" | "versionNumber" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["trip"]>
  export type TripInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    stops?: boolean | Trip$stopsArgs<ExtArgs>
    budgets?: boolean | Trip$budgetsArgs<ExtArgs>
    media?: boolean | Trip$mediaArgs<ExtArgs>
    shares?: boolean | Trip$sharesArgs<ExtArgs>
    versions?: boolean | Trip$versionsArgs<ExtArgs>
    _count?: boolean | TripCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TripIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TripIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TripPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Trip"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      stops: Prisma.$TripStopPayload<ExtArgs>[]
      budgets: Prisma.$TripBudgetPayload<ExtArgs>[]
      media: Prisma.$TripMediaPayload<ExtArgs>[]
      shares: Prisma.$TripSharePayload<ExtArgs>[]
      versions: Prisma.$TripVersionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string
      description: string | null
      startDate: Date
      endDate: Date
      coverPhotoUrl: string | null
      status: string
      isPublic: boolean
      totalEstimatedCost: number
      currency: string
      travelStyle: string | null
      versionNumber: number
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["trip"]>
    composites: {}
  }

  type TripGetPayload<S extends boolean | null | undefined | TripDefaultArgs> = $Result.GetResult<Prisma.$TripPayload, S>

  type TripCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TripFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TripCountAggregateInputType | true
    }

  export interface TripDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Trip'], meta: { name: 'Trip' } }
    /**
     * Find zero or one Trip that matches the filter.
     * @param {TripFindUniqueArgs} args - Arguments to find a Trip
     * @example
     * // Get one Trip
     * const trip = await prisma.trip.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TripFindUniqueArgs>(args: SelectSubset<T, TripFindUniqueArgs<ExtArgs>>): Prisma__TripClient<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Trip that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TripFindUniqueOrThrowArgs} args - Arguments to find a Trip
     * @example
     * // Get one Trip
     * const trip = await prisma.trip.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TripFindUniqueOrThrowArgs>(args: SelectSubset<T, TripFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TripClient<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Trip that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripFindFirstArgs} args - Arguments to find a Trip
     * @example
     * // Get one Trip
     * const trip = await prisma.trip.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TripFindFirstArgs>(args?: SelectSubset<T, TripFindFirstArgs<ExtArgs>>): Prisma__TripClient<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Trip that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripFindFirstOrThrowArgs} args - Arguments to find a Trip
     * @example
     * // Get one Trip
     * const trip = await prisma.trip.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TripFindFirstOrThrowArgs>(args?: SelectSubset<T, TripFindFirstOrThrowArgs<ExtArgs>>): Prisma__TripClient<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Trips that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Trips
     * const trips = await prisma.trip.findMany()
     * 
     * // Get first 10 Trips
     * const trips = await prisma.trip.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tripWithIdOnly = await prisma.trip.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TripFindManyArgs>(args?: SelectSubset<T, TripFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Trip.
     * @param {TripCreateArgs} args - Arguments to create a Trip.
     * @example
     * // Create one Trip
     * const Trip = await prisma.trip.create({
     *   data: {
     *     // ... data to create a Trip
     *   }
     * })
     * 
     */
    create<T extends TripCreateArgs>(args: SelectSubset<T, TripCreateArgs<ExtArgs>>): Prisma__TripClient<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Trips.
     * @param {TripCreateManyArgs} args - Arguments to create many Trips.
     * @example
     * // Create many Trips
     * const trip = await prisma.trip.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TripCreateManyArgs>(args?: SelectSubset<T, TripCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Trips and returns the data saved in the database.
     * @param {TripCreateManyAndReturnArgs} args - Arguments to create many Trips.
     * @example
     * // Create many Trips
     * const trip = await prisma.trip.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Trips and only return the `id`
     * const tripWithIdOnly = await prisma.trip.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TripCreateManyAndReturnArgs>(args?: SelectSubset<T, TripCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Trip.
     * @param {TripDeleteArgs} args - Arguments to delete one Trip.
     * @example
     * // Delete one Trip
     * const Trip = await prisma.trip.delete({
     *   where: {
     *     // ... filter to delete one Trip
     *   }
     * })
     * 
     */
    delete<T extends TripDeleteArgs>(args: SelectSubset<T, TripDeleteArgs<ExtArgs>>): Prisma__TripClient<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Trip.
     * @param {TripUpdateArgs} args - Arguments to update one Trip.
     * @example
     * // Update one Trip
     * const trip = await prisma.trip.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TripUpdateArgs>(args: SelectSubset<T, TripUpdateArgs<ExtArgs>>): Prisma__TripClient<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Trips.
     * @param {TripDeleteManyArgs} args - Arguments to filter Trips to delete.
     * @example
     * // Delete a few Trips
     * const { count } = await prisma.trip.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TripDeleteManyArgs>(args?: SelectSubset<T, TripDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Trips.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Trips
     * const trip = await prisma.trip.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TripUpdateManyArgs>(args: SelectSubset<T, TripUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Trips and returns the data updated in the database.
     * @param {TripUpdateManyAndReturnArgs} args - Arguments to update many Trips.
     * @example
     * // Update many Trips
     * const trip = await prisma.trip.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Trips and only return the `id`
     * const tripWithIdOnly = await prisma.trip.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TripUpdateManyAndReturnArgs>(args: SelectSubset<T, TripUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Trip.
     * @param {TripUpsertArgs} args - Arguments to update or create a Trip.
     * @example
     * // Update or create a Trip
     * const trip = await prisma.trip.upsert({
     *   create: {
     *     // ... data to create a Trip
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Trip we want to update
     *   }
     * })
     */
    upsert<T extends TripUpsertArgs>(args: SelectSubset<T, TripUpsertArgs<ExtArgs>>): Prisma__TripClient<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Trips.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripCountArgs} args - Arguments to filter Trips to count.
     * @example
     * // Count the number of Trips
     * const count = await prisma.trip.count({
     *   where: {
     *     // ... the filter for the Trips we want to count
     *   }
     * })
    **/
    count<T extends TripCountArgs>(
      args?: Subset<T, TripCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TripCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Trip.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TripAggregateArgs>(args: Subset<T, TripAggregateArgs>): Prisma.PrismaPromise<GetTripAggregateType<T>>

    /**
     * Group by Trip.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TripGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TripGroupByArgs['orderBy'] }
        : { orderBy?: TripGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TripGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTripGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Trip model
   */
  readonly fields: TripFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Trip.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TripClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    stops<T extends Trip$stopsArgs<ExtArgs> = {}>(args?: Subset<T, Trip$stopsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TripStopPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    budgets<T extends Trip$budgetsArgs<ExtArgs> = {}>(args?: Subset<T, Trip$budgetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TripBudgetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    media<T extends Trip$mediaArgs<ExtArgs> = {}>(args?: Subset<T, Trip$mediaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TripMediaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    shares<T extends Trip$sharesArgs<ExtArgs> = {}>(args?: Subset<T, Trip$sharesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TripSharePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    versions<T extends Trip$versionsArgs<ExtArgs> = {}>(args?: Subset<T, Trip$versionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TripVersionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Trip model
   */
  interface TripFieldRefs {
    readonly id: FieldRef<"Trip", 'String'>
    readonly userId: FieldRef<"Trip", 'String'>
    readonly name: FieldRef<"Trip", 'String'>
    readonly description: FieldRef<"Trip", 'String'>
    readonly startDate: FieldRef<"Trip", 'DateTime'>
    readonly endDate: FieldRef<"Trip", 'DateTime'>
    readonly coverPhotoUrl: FieldRef<"Trip", 'String'>
    readonly status: FieldRef<"Trip", 'String'>
    readonly isPublic: FieldRef<"Trip", 'Boolean'>
    readonly totalEstimatedCost: FieldRef<"Trip", 'Float'>
    readonly currency: FieldRef<"Trip", 'String'>
    readonly travelStyle: FieldRef<"Trip", 'String'>
    readonly versionNumber: FieldRef<"Trip", 'Int'>
    readonly createdAt: FieldRef<"Trip", 'DateTime'>
    readonly updatedAt: FieldRef<"Trip", 'DateTime'>
    readonly deletedAt: FieldRef<"Trip", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Trip findUnique
   */
  export type TripFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trip
     */
    omit?: TripOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    /**
     * Filter, which Trip to fetch.
     */
    where: TripWhereUniqueInput
  }

  /**
   * Trip findUniqueOrThrow
   */
  export type TripFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trip
     */
    omit?: TripOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    /**
     * Filter, which Trip to fetch.
     */
    where: TripWhereUniqueInput
  }

  /**
   * Trip findFirst
   */
  export type TripFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trip
     */
    omit?: TripOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    /**
     * Filter, which Trip to fetch.
     */
    where?: TripWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trips to fetch.
     */
    orderBy?: TripOrderByWithRelationInput | TripOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Trips.
     */
    cursor?: TripWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trips.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Trips.
     */
    distinct?: TripScalarFieldEnum | TripScalarFieldEnum[]
  }

  /**
   * Trip findFirstOrThrow
   */
  export type TripFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trip
     */
    omit?: TripOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    /**
     * Filter, which Trip to fetch.
     */
    where?: TripWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trips to fetch.
     */
    orderBy?: TripOrderByWithRelationInput | TripOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Trips.
     */
    cursor?: TripWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trips.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Trips.
     */
    distinct?: TripScalarFieldEnum | TripScalarFieldEnum[]
  }

  /**
   * Trip findMany
   */
  export type TripFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trip
     */
    omit?: TripOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    /**
     * Filter, which Trips to fetch.
     */
    where?: TripWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trips to fetch.
     */
    orderBy?: TripOrderByWithRelationInput | TripOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Trips.
     */
    cursor?: TripWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trips.
     */
    skip?: number
    distinct?: TripScalarFieldEnum | TripScalarFieldEnum[]
  }

  /**
   * Trip create
   */
  export type TripCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trip
     */
    omit?: TripOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    /**
     * The data needed to create a Trip.
     */
    data: XOR<TripCreateInput, TripUncheckedCreateInput>
  }

  /**
   * Trip createMany
   */
  export type TripCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Trips.
     */
    data: TripCreateManyInput | TripCreateManyInput[]
  }

  /**
   * Trip createManyAndReturn
   */
  export type TripCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Trip
     */
    omit?: TripOmit<ExtArgs> | null
    /**
     * The data used to create many Trips.
     */
    data: TripCreateManyInput | TripCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Trip update
   */
  export type TripUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trip
     */
    omit?: TripOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    /**
     * The data needed to update a Trip.
     */
    data: XOR<TripUpdateInput, TripUncheckedUpdateInput>
    /**
     * Choose, which Trip to update.
     */
    where: TripWhereUniqueInput
  }

  /**
   * Trip updateMany
   */
  export type TripUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Trips.
     */
    data: XOR<TripUpdateManyMutationInput, TripUncheckedUpdateManyInput>
    /**
     * Filter which Trips to update
     */
    where?: TripWhereInput
    /**
     * Limit how many Trips to update.
     */
    limit?: number
  }

  /**
   * Trip updateManyAndReturn
   */
  export type TripUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Trip
     */
    omit?: TripOmit<ExtArgs> | null
    /**
     * The data used to update Trips.
     */
    data: XOR<TripUpdateManyMutationInput, TripUncheckedUpdateManyInput>
    /**
     * Filter which Trips to update
     */
    where?: TripWhereInput
    /**
     * Limit how many Trips to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Trip upsert
   */
  export type TripUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trip
     */
    omit?: TripOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    /**
     * The filter to search for the Trip to update in case it exists.
     */
    where: TripWhereUniqueInput
    /**
     * In case the Trip found by the `where` argument doesn't exist, create a new Trip with this data.
     */
    create: XOR<TripCreateInput, TripUncheckedCreateInput>
    /**
     * In case the Trip was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TripUpdateInput, TripUncheckedUpdateInput>
  }

  /**
   * Trip delete
   */
  export type TripDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trip
     */
    omit?: TripOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    /**
     * Filter which Trip to delete.
     */
    where: TripWhereUniqueInput
  }

  /**
   * Trip deleteMany
   */
  export type TripDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Trips to delete
     */
    where?: TripWhereInput
    /**
     * Limit how many Trips to delete.
     */
    limit?: number
  }

  /**
   * Trip.stops
   */
  export type Trip$stopsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripStop
     */
    select?: TripStopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TripStop
     */
    omit?: TripStopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripStopInclude<ExtArgs> | null
    where?: TripStopWhereInput
    orderBy?: TripStopOrderByWithRelationInput | TripStopOrderByWithRelationInput[]
    cursor?: TripStopWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TripStopScalarFieldEnum | TripStopScalarFieldEnum[]
  }

  /**
   * Trip.budgets
   */
  export type Trip$budgetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripBudget
     */
    select?: TripBudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TripBudget
     */
    omit?: TripBudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripBudgetInclude<ExtArgs> | null
    where?: TripBudgetWhereInput
    orderBy?: TripBudgetOrderByWithRelationInput | TripBudgetOrderByWithRelationInput[]
    cursor?: TripBudgetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TripBudgetScalarFieldEnum | TripBudgetScalarFieldEnum[]
  }

  /**
   * Trip.media
   */
  export type Trip$mediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripMedia
     */
    select?: TripMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TripMedia
     */
    omit?: TripMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripMediaInclude<ExtArgs> | null
    where?: TripMediaWhereInput
    orderBy?: TripMediaOrderByWithRelationInput | TripMediaOrderByWithRelationInput[]
    cursor?: TripMediaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TripMediaScalarFieldEnum | TripMediaScalarFieldEnum[]
  }

  /**
   * Trip.shares
   */
  export type Trip$sharesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripShare
     */
    select?: TripShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TripShare
     */
    omit?: TripShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripShareInclude<ExtArgs> | null
    where?: TripShareWhereInput
    orderBy?: TripShareOrderByWithRelationInput | TripShareOrderByWithRelationInput[]
    cursor?: TripShareWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TripShareScalarFieldEnum | TripShareScalarFieldEnum[]
  }

  /**
   * Trip.versions
   */
  export type Trip$versionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripVersion
     */
    select?: TripVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TripVersion
     */
    omit?: TripVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripVersionInclude<ExtArgs> | null
    where?: TripVersionWhereInput
    orderBy?: TripVersionOrderByWithRelationInput | TripVersionOrderByWithRelationInput[]
    cursor?: TripVersionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TripVersionScalarFieldEnum | TripVersionScalarFieldEnum[]
  }

  /**
   * Trip without action
   */
  export type TripDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trip
     */
    omit?: TripOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
  }


  /**
   * Model TripStop
   */

  export type AggregateTripStop = {
    _count: TripStopCountAggregateOutputType | null
    _avg: TripStopAvgAggregateOutputType | null
    _sum: TripStopSumAggregateOutputType | null
    _min: TripStopMinAggregateOutputType | null
    _max: TripStopMaxAggregateOutputType | null
  }

  export type TripStopAvgAggregateOutputType = {
    stopOrder: number | null
    accommodationCost: number | null
  }

  export type TripStopSumAggregateOutputType = {
    stopOrder: number | null
    accommodationCost: number | null
  }

  export type TripStopMinAggregateOutputType = {
    id: string | null
    tripId: string | null
    cityId: string | null
    stopOrder: number | null
    arrivalDate: Date | null
    departureDate: Date | null
    accommodationName: string | null
    accommodationCost: number | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type TripStopMaxAggregateOutputType = {
    id: string | null
    tripId: string | null
    cityId: string | null
    stopOrder: number | null
    arrivalDate: Date | null
    departureDate: Date | null
    accommodationName: string | null
    accommodationCost: number | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type TripStopCountAggregateOutputType = {
    id: number
    tripId: number
    cityId: number
    stopOrder: number
    arrivalDate: number
    departureDate: number
    accommodationName: number
    accommodationCost: number
    notes: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type TripStopAvgAggregateInputType = {
    stopOrder?: true
    accommodationCost?: true
  }

  export type TripStopSumAggregateInputType = {
    stopOrder?: true
    accommodationCost?: true
  }

  export type TripStopMinAggregateInputType = {
    id?: true
    tripId?: true
    cityId?: true
    stopOrder?: true
    arrivalDate?: true
    departureDate?: true
    accommodationName?: true
    accommodationCost?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type TripStopMaxAggregateInputType = {
    id?: true
    tripId?: true
    cityId?: true
    stopOrder?: true
    arrivalDate?: true
    departureDate?: true
    accommodationName?: true
    accommodationCost?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type TripStopCountAggregateInputType = {
    id?: true
    tripId?: true
    cityId?: true
    stopOrder?: true
    arrivalDate?: true
    departureDate?: true
    accommodationName?: true
    accommodationCost?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type TripStopAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TripStop to aggregate.
     */
    where?: TripStopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TripStops to fetch.
     */
    orderBy?: TripStopOrderByWithRelationInput | TripStopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TripStopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TripStops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TripStops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TripStops
    **/
    _count?: true | TripStopCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TripStopAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TripStopSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TripStopMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TripStopMaxAggregateInputType
  }

  export type GetTripStopAggregateType<T extends TripStopAggregateArgs> = {
        [P in keyof T & keyof AggregateTripStop]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTripStop[P]>
      : GetScalarType<T[P], AggregateTripStop[P]>
  }




  export type TripStopGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TripStopWhereInput
    orderBy?: TripStopOrderByWithAggregationInput | TripStopOrderByWithAggregationInput[]
    by: TripStopScalarFieldEnum[] | TripStopScalarFieldEnum
    having?: TripStopScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TripStopCountAggregateInputType | true
    _avg?: TripStopAvgAggregateInputType
    _sum?: TripStopSumAggregateInputType
    _min?: TripStopMinAggregateInputType
    _max?: TripStopMaxAggregateInputType
  }

  export type TripStopGroupByOutputType = {
    id: string
    tripId: string
    cityId: string
    stopOrder: number
    arrivalDate: Date
    departureDate: Date
    accommodationName: string | null
    accommodationCost: number | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: TripStopCountAggregateOutputType | null
    _avg: TripStopAvgAggregateOutputType | null
    _sum: TripStopSumAggregateOutputType | null
    _min: TripStopMinAggregateOutputType | null
    _max: TripStopMaxAggregateOutputType | null
  }

  type GetTripStopGroupByPayload<T extends TripStopGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TripStopGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TripStopGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TripStopGroupByOutputType[P]>
            : GetScalarType<T[P], TripStopGroupByOutputType[P]>
        }
      >
    >


  export type TripStopSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tripId?: boolean
    cityId?: boolean
    stopOrder?: boolean
    arrivalDate?: boolean
    departureDate?: boolean
    accommodationName?: boolean
    accommodationCost?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    trip?: boolean | TripDefaultArgs<ExtArgs>
    city?: boolean | CityDefaultArgs<ExtArgs>
    activities?: boolean | TripStop$activitiesArgs<ExtArgs>
    _count?: boolean | TripStopCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tripStop"]>

  export type TripStopSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tripId?: boolean
    cityId?: boolean
    stopOrder?: boolean
    arrivalDate?: boolean
    departureDate?: boolean
    accommodationName?: boolean
    accommodationCost?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    trip?: boolean | TripDefaultArgs<ExtArgs>
    city?: boolean | CityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tripStop"]>

  export type TripStopSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tripId?: boolean
    cityId?: boolean
    stopOrder?: boolean
    arrivalDate?: boolean
    departureDate?: boolean
    accommodationName?: boolean
    accommodationCost?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    trip?: boolean | TripDefaultArgs<ExtArgs>
    city?: boolean | CityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tripStop"]>

  export type TripStopSelectScalar = {
    id?: boolean
    tripId?: boolean
    cityId?: boolean
    stopOrder?: boolean
    arrivalDate?: boolean
    departureDate?: boolean
    accommodationName?: boolean
    accommodationCost?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type TripStopOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tripId" | "cityId" | "stopOrder" | "arrivalDate" | "departureDate" | "accommodationName" | "accommodationCost" | "notes" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["tripStop"]>
  export type TripStopInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trip?: boolean | TripDefaultArgs<ExtArgs>
    city?: boolean | CityDefaultArgs<ExtArgs>
    activities?: boolean | TripStop$activitiesArgs<ExtArgs>
    _count?: boolean | TripStopCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TripStopIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trip?: boolean | TripDefaultArgs<ExtArgs>
    city?: boolean | CityDefaultArgs<ExtArgs>
  }
  export type TripStopIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trip?: boolean | TripDefaultArgs<ExtArgs>
    city?: boolean | CityDefaultArgs<ExtArgs>
  }

  export type $TripStopPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TripStop"
    objects: {
      trip: Prisma.$TripPayload<ExtArgs>
      city: Prisma.$CityPayload<ExtArgs>
      activities: Prisma.$StopActivityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tripId: string
      cityId: string
      stopOrder: number
      arrivalDate: Date
      departureDate: Date
      accommodationName: string | null
      accommodationCost: number | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["tripStop"]>
    composites: {}
  }

  type TripStopGetPayload<S extends boolean | null | undefined | TripStopDefaultArgs> = $Result.GetResult<Prisma.$TripStopPayload, S>

  type TripStopCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TripStopFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TripStopCountAggregateInputType | true
    }

  export interface TripStopDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TripStop'], meta: { name: 'TripStop' } }
    /**
     * Find zero or one TripStop that matches the filter.
     * @param {TripStopFindUniqueArgs} args - Arguments to find a TripStop
     * @example
     * // Get one TripStop
     * const tripStop = await prisma.tripStop.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TripStopFindUniqueArgs>(args: SelectSubset<T, TripStopFindUniqueArgs<ExtArgs>>): Prisma__TripStopClient<$Result.GetResult<Prisma.$TripStopPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TripStop that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TripStopFindUniqueOrThrowArgs} args - Arguments to find a TripStop
     * @example
     * // Get one TripStop
     * const tripStop = await prisma.tripStop.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TripStopFindUniqueOrThrowArgs>(args: SelectSubset<T, TripStopFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TripStopClient<$Result.GetResult<Prisma.$TripStopPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TripStop that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripStopFindFirstArgs} args - Arguments to find a TripStop
     * @example
     * // Get one TripStop
     * const tripStop = await prisma.tripStop.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TripStopFindFirstArgs>(args?: SelectSubset<T, TripStopFindFirstArgs<ExtArgs>>): Prisma__TripStopClient<$Result.GetResult<Prisma.$TripStopPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TripStop that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripStopFindFirstOrThrowArgs} args - Arguments to find a TripStop
     * @example
     * // Get one TripStop
     * const tripStop = await prisma.tripStop.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TripStopFindFirstOrThrowArgs>(args?: SelectSubset<T, TripStopFindFirstOrThrowArgs<ExtArgs>>): Prisma__TripStopClient<$Result.GetResult<Prisma.$TripStopPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TripStops that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripStopFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TripStops
     * const tripStops = await prisma.tripStop.findMany()
     * 
     * // Get first 10 TripStops
     * const tripStops = await prisma.tripStop.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tripStopWithIdOnly = await prisma.tripStop.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TripStopFindManyArgs>(args?: SelectSubset<T, TripStopFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TripStopPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TripStop.
     * @param {TripStopCreateArgs} args - Arguments to create a TripStop.
     * @example
     * // Create one TripStop
     * const TripStop = await prisma.tripStop.create({
     *   data: {
     *     // ... data to create a TripStop
     *   }
     * })
     * 
     */
    create<T extends TripStopCreateArgs>(args: SelectSubset<T, TripStopCreateArgs<ExtArgs>>): Prisma__TripStopClient<$Result.GetResult<Prisma.$TripStopPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TripStops.
     * @param {TripStopCreateManyArgs} args - Arguments to create many TripStops.
     * @example
     * // Create many TripStops
     * const tripStop = await prisma.tripStop.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TripStopCreateManyArgs>(args?: SelectSubset<T, TripStopCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TripStops and returns the data saved in the database.
     * @param {TripStopCreateManyAndReturnArgs} args - Arguments to create many TripStops.
     * @example
     * // Create many TripStops
     * const tripStop = await prisma.tripStop.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TripStops and only return the `id`
     * const tripStopWithIdOnly = await prisma.tripStop.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TripStopCreateManyAndReturnArgs>(args?: SelectSubset<T, TripStopCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TripStopPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TripStop.
     * @param {TripStopDeleteArgs} args - Arguments to delete one TripStop.
     * @example
     * // Delete one TripStop
     * const TripStop = await prisma.tripStop.delete({
     *   where: {
     *     // ... filter to delete one TripStop
     *   }
     * })
     * 
     */
    delete<T extends TripStopDeleteArgs>(args: SelectSubset<T, TripStopDeleteArgs<ExtArgs>>): Prisma__TripStopClient<$Result.GetResult<Prisma.$TripStopPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TripStop.
     * @param {TripStopUpdateArgs} args - Arguments to update one TripStop.
     * @example
     * // Update one TripStop
     * const tripStop = await prisma.tripStop.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TripStopUpdateArgs>(args: SelectSubset<T, TripStopUpdateArgs<ExtArgs>>): Prisma__TripStopClient<$Result.GetResult<Prisma.$TripStopPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TripStops.
     * @param {TripStopDeleteManyArgs} args - Arguments to filter TripStops to delete.
     * @example
     * // Delete a few TripStops
     * const { count } = await prisma.tripStop.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TripStopDeleteManyArgs>(args?: SelectSubset<T, TripStopDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TripStops.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripStopUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TripStops
     * const tripStop = await prisma.tripStop.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TripStopUpdateManyArgs>(args: SelectSubset<T, TripStopUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TripStops and returns the data updated in the database.
     * @param {TripStopUpdateManyAndReturnArgs} args - Arguments to update many TripStops.
     * @example
     * // Update many TripStops
     * const tripStop = await prisma.tripStop.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TripStops and only return the `id`
     * const tripStopWithIdOnly = await prisma.tripStop.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TripStopUpdateManyAndReturnArgs>(args: SelectSubset<T, TripStopUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TripStopPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TripStop.
     * @param {TripStopUpsertArgs} args - Arguments to update or create a TripStop.
     * @example
     * // Update or create a TripStop
     * const tripStop = await prisma.tripStop.upsert({
     *   create: {
     *     // ... data to create a TripStop
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TripStop we want to update
     *   }
     * })
     */
    upsert<T extends TripStopUpsertArgs>(args: SelectSubset<T, TripStopUpsertArgs<ExtArgs>>): Prisma__TripStopClient<$Result.GetResult<Prisma.$TripStopPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TripStops.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripStopCountArgs} args - Arguments to filter TripStops to count.
     * @example
     * // Count the number of TripStops
     * const count = await prisma.tripStop.count({
     *   where: {
     *     // ... the filter for the TripStops we want to count
     *   }
     * })
    **/
    count<T extends TripStopCountArgs>(
      args?: Subset<T, TripStopCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TripStopCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TripStop.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripStopAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TripStopAggregateArgs>(args: Subset<T, TripStopAggregateArgs>): Prisma.PrismaPromise<GetTripStopAggregateType<T>>

    /**
     * Group by TripStop.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripStopGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TripStopGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TripStopGroupByArgs['orderBy'] }
        : { orderBy?: TripStopGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TripStopGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTripStopGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TripStop model
   */
  readonly fields: TripStopFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TripStop.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TripStopClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    trip<T extends TripDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TripDefaultArgs<ExtArgs>>): Prisma__TripClient<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    city<T extends CityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CityDefaultArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    activities<T extends TripStop$activitiesArgs<ExtArgs> = {}>(args?: Subset<T, TripStop$activitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StopActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TripStop model
   */
  interface TripStopFieldRefs {
    readonly id: FieldRef<"TripStop", 'String'>
    readonly tripId: FieldRef<"TripStop", 'String'>
    readonly cityId: FieldRef<"TripStop", 'String'>
    readonly stopOrder: FieldRef<"TripStop", 'Int'>
    readonly arrivalDate: FieldRef<"TripStop", 'DateTime'>
    readonly departureDate: FieldRef<"TripStop", 'DateTime'>
    readonly accommodationName: FieldRef<"TripStop", 'String'>
    readonly accommodationCost: FieldRef<"TripStop", 'Float'>
    readonly notes: FieldRef<"TripStop", 'String'>
    readonly createdAt: FieldRef<"TripStop", 'DateTime'>
    readonly updatedAt: FieldRef<"TripStop", 'DateTime'>
    readonly deletedAt: FieldRef<"TripStop", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TripStop findUnique
   */
  export type TripStopFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripStop
     */
    select?: TripStopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TripStop
     */
    omit?: TripStopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripStopInclude<ExtArgs> | null
    /**
     * Filter, which TripStop to fetch.
     */
    where: TripStopWhereUniqueInput
  }

  /**
   * TripStop findUniqueOrThrow
   */
  export type TripStopFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripStop
     */
    select?: TripStopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TripStop
     */
    omit?: TripStopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripStopInclude<ExtArgs> | null
    /**
     * Filter, which TripStop to fetch.
     */
    where: TripStopWhereUniqueInput
  }

  /**
   * TripStop findFirst
   */
  export type TripStopFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripStop
     */
    select?: TripStopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TripStop
     */
    omit?: TripStopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripStopInclude<ExtArgs> | null
    /**
     * Filter, which TripStop to fetch.
     */
    where?: TripStopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TripStops to fetch.
     */
    orderBy?: TripStopOrderByWithRelationInput | TripStopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TripStops.
     */
    cursor?: TripStopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TripStops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TripStops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TripStops.
     */
    distinct?: TripStopScalarFieldEnum | TripStopScalarFieldEnum[]
  }

  /**
   * TripStop findFirstOrThrow
   */
  export type TripStopFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripStop
     */
    select?: TripStopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TripStop
     */
    omit?: TripStopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripStopInclude<ExtArgs> | null
    /**
     * Filter, which TripStop to fetch.
     */
    where?: TripStopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TripStops to fetch.
     */
    orderBy?: TripStopOrderByWithRelationInput | TripStopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TripStops.
     */
    cursor?: TripStopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TripStops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TripStops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TripStops.
     */
    distinct?: TripStopScalarFieldEnum | TripStopScalarFieldEnum[]
  }

  /**
   * TripStop findMany
   */
  export type TripStopFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripStop
     */
    select?: TripStopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TripStop
     */
    omit?: TripStopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripStopInclude<ExtArgs> | null
    /**
     * Filter, which TripStops to fetch.
     */
    where?: TripStopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TripStops to fetch.
     */
    orderBy?: TripStopOrderByWithRelationInput | TripStopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TripStops.
     */
    cursor?: TripStopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TripStops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TripStops.
     */
    skip?: number
    distinct?: TripStopScalarFieldEnum | TripStopScalarFieldEnum[]
  }

  /**
   * TripStop create
   */
  export type TripStopCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripStop
     */
    select?: TripStopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TripStop
     */
    omit?: TripStopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripStopInclude<ExtArgs> | null
    /**
     * The data needed to create a TripStop.
     */
    data: XOR<TripStopCreateInput, TripStopUncheckedCreateInput>
  }

  /**
   * TripStop createMany
   */
  export type TripStopCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TripStops.
     */
    data: TripStopCreateManyInput | TripStopCreateManyInput[]
  }

  /**
   * TripStop createManyAndReturn
   */
  export type TripStopCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripStop
     */
    select?: TripStopSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TripStop
     */
    omit?: TripStopOmit<ExtArgs> | null
    /**
     * The data used to create many TripStops.
     */
    data: TripStopCreateManyInput | TripStopCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripStopIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TripStop update
   */
  export type TripStopUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripStop
     */
    select?: TripStopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TripStop
     */
    omit?: TripStopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripStopInclude<ExtArgs> | null
    /**
     * The data needed to update a TripStop.
     */
    data: XOR<TripStopUpdateInput, TripStopUncheckedUpdateInput>
    /**
     * Choose, which TripStop to update.
     */
    where: TripStopWhereUniqueInput
  }

  /**
   * TripStop updateMany
   */
  export type TripStopUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TripStops.
     */
    data: XOR<TripStopUpdateManyMutationInput, TripStopUncheckedUpdateManyInput>
    /**
     * Filter which TripStops to update
     */
    where?: TripStopWhereInput
    /**
     * Limit how many TripStops to update.
     */
    limit?: number
  }

  /**
   * TripStop updateManyAndReturn
   */
  export type TripStopUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripStop
     */
    select?: TripStopSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TripStop
     */
    omit?: TripStopOmit<ExtArgs> | null
    /**
     * The data used to update TripStops.
     */
    data: XOR<TripStopUpdateManyMutationInput, TripStopUncheckedUpdateManyInput>
    /**
     * Filter which TripStops to update
     */
    where?: TripStopWhereInput
    /**
     * Limit how many TripStops to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripStopIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TripStop upsert
   */
  export type TripStopUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripStop
     */
    select?: TripStopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TripStop
     */
    omit?: TripStopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripStopInclude<ExtArgs> | null
    /**
     * The filter to search for the TripStop to update in case it exists.
     */
    where: TripStopWhereUniqueInput
    /**
     * In case the TripStop found by the `where` argument doesn't exist, create a new TripStop with this data.
     */
    create: XOR<TripStopCreateInput, TripStopUncheckedCreateInput>
    /**
     * In case the TripStop was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TripStopUpdateInput, TripStopUncheckedUpdateInput>
  }

  /**
   * TripStop delete
   */
  export type TripStopDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripStop
     */
    select?: TripStopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TripStop
     */
    omit?: TripStopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripStopInclude<ExtArgs> | null
    /**
     * Filter which TripStop to delete.
     */
    where: TripStopWhereUniqueInput
  }

  /**
   * TripStop deleteMany
   */
  export type TripStopDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TripStops to delete
     */
    where?: TripStopWhereInput
    /**
     * Limit how many TripStops to delete.
     */
    limit?: number
  }

  /**
   * TripStop.activities
   */
  export type TripStop$activitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StopActivity
     */
    select?: StopActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StopActivity
     */
    omit?: StopActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StopActivityInclude<ExtArgs> | null
    where?: StopActivityWhereInput
    orderBy?: StopActivityOrderByWithRelationInput | StopActivityOrderByWithRelationInput[]
    cursor?: StopActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StopActivityScalarFieldEnum | StopActivityScalarFieldEnum[]
  }

  /**
   * TripStop without action
   */
  export type TripStopDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripStop
     */
    select?: TripStopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TripStop
     */
    omit?: TripStopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripStopInclude<ExtArgs> | null
  }


  /**
   * Model StopActivity
   */

  export type AggregateStopActivity = {
    _count: StopActivityCountAggregateOutputType | null
    _avg: StopActivityAvgAggregateOutputType | null
    _sum: StopActivitySumAggregateOutputType | null
    _min: StopActivityMinAggregateOutputType | null
    _max: StopActivityMaxAggregateOutputType | null
  }

  export type StopActivityAvgAggregateOutputType = {
    actualCost: number | null
  }

  export type StopActivitySumAggregateOutputType = {
    actualCost: number | null
  }

  export type StopActivityMinAggregateOutputType = {
    id: string | null
    tripStopId: string | null
    activityId: string | null
    scheduledDate: Date | null
    scheduledTime: string | null
    actualCost: number | null
    notes: string | null
    isCompleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type StopActivityMaxAggregateOutputType = {
    id: string | null
    tripStopId: string | null
    activityId: string | null
    scheduledDate: Date | null
    scheduledTime: string | null
    actualCost: number | null
    notes: string | null
    isCompleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type StopActivityCountAggregateOutputType = {
    id: number
    tripStopId: number
    activityId: number
    scheduledDate: number
    scheduledTime: number
    actualCost: number
    notes: number
    isCompleted: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type StopActivityAvgAggregateInputType = {
    actualCost?: true
  }

  export type StopActivitySumAggregateInputType = {
    actualCost?: true
  }

  export type StopActivityMinAggregateInputType = {
    id?: true
    tripStopId?: true
    activityId?: true
    scheduledDate?: true
    scheduledTime?: true
    actualCost?: true
    notes?: true
    isCompleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type StopActivityMaxAggregateInputType = {
    id?: true
    tripStopId?: true
    activityId?: true
    scheduledDate?: true
    scheduledTime?: true
    actualCost?: true
    notes?: true
    isCompleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type StopActivityCountAggregateInputType = {
    id?: true
    tripStopId?: true
    activityId?: true
    scheduledDate?: true
    scheduledTime?: true
    actualCost?: true
    notes?: true
    isCompleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type StopActivityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StopActivity to aggregate.
     */
    where?: StopActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StopActivities to fetch.
     */
    orderBy?: StopActivityOrderByWithRelationInput | StopActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StopActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StopActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StopActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StopActivities
    **/
    _count?: true | StopActivityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StopActivityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StopActivitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StopActivityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StopActivityMaxAggregateInputType
  }

  export type GetStopActivityAggregateType<T extends StopActivityAggregateArgs> = {
        [P in keyof T & keyof AggregateStopActivity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStopActivity[P]>
      : GetScalarType<T[P], AggregateStopActivity[P]>
  }




  export type StopActivityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StopActivityWhereInput
    orderBy?: StopActivityOrderByWithAggregationInput | StopActivityOrderByWithAggregationInput[]
    by: StopActivityScalarFieldEnum[] | StopActivityScalarFieldEnum
    having?: StopActivityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StopActivityCountAggregateInputType | true
    _avg?: StopActivityAvgAggregateInputType
    _sum?: StopActivitySumAggregateInputType
    _min?: StopActivityMinAggregateInputType
    _max?: StopActivityMaxAggregateInputType
  }

  export type StopActivityGroupByOutputType = {
    id: string
    tripStopId: string
    activityId: string
    scheduledDate: Date
    scheduledTime: string | null
    actualCost: number | null
    notes: string | null
    isCompleted: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: StopActivityCountAggregateOutputType | null
    _avg: StopActivityAvgAggregateOutputType | null
    _sum: StopActivitySumAggregateOutputType | null
    _min: StopActivityMinAggregateOutputType | null
    _max: StopActivityMaxAggregateOutputType | null
  }

  type GetStopActivityGroupByPayload<T extends StopActivityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StopActivityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StopActivityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StopActivityGroupByOutputType[P]>
            : GetScalarType<T[P], StopActivityGroupByOutputType[P]>
        }
      >
    >


  export type StopActivitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tripStopId?: boolean
    activityId?: boolean
    scheduledDate?: boolean
    scheduledTime?: boolean
    actualCost?: boolean
    notes?: boolean
    isCompleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    tripStop?: boolean | TripStopDefaultArgs<ExtArgs>
    activity?: boolean | ActivityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stopActivity"]>

  export type StopActivitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tripStopId?: boolean
    activityId?: boolean
    scheduledDate?: boolean
    scheduledTime?: boolean
    actualCost?: boolean
    notes?: boolean
    isCompleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    tripStop?: boolean | TripStopDefaultArgs<ExtArgs>
    activity?: boolean | ActivityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stopActivity"]>

  export type StopActivitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tripStopId?: boolean
    activityId?: boolean
    scheduledDate?: boolean
    scheduledTime?: boolean
    actualCost?: boolean
    notes?: boolean
    isCompleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    tripStop?: boolean | TripStopDefaultArgs<ExtArgs>
    activity?: boolean | ActivityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stopActivity"]>

  export type StopActivitySelectScalar = {
    id?: boolean
    tripStopId?: boolean
    activityId?: boolean
    scheduledDate?: boolean
    scheduledTime?: boolean
    actualCost?: boolean
    notes?: boolean
    isCompleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type StopActivityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tripStopId" | "activityId" | "scheduledDate" | "scheduledTime" | "actualCost" | "notes" | "isCompleted" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["stopActivity"]>
  export type StopActivityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tripStop?: boolean | TripStopDefaultArgs<ExtArgs>
    activity?: boolean | ActivityDefaultArgs<ExtArgs>
  }
  export type StopActivityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tripStop?: boolean | TripStopDefaultArgs<ExtArgs>
    activity?: boolean | ActivityDefaultArgs<ExtArgs>
  }
  export type StopActivityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tripStop?: boolean | TripStopDefaultArgs<ExtArgs>
    activity?: boolean | ActivityDefaultArgs<ExtArgs>
  }

  export type $StopActivityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StopActivity"
    objects: {
      tripStop: Prisma.$TripStopPayload<ExtArgs>
      activity: Prisma.$ActivityPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tripStopId: string
      activityId: string
      scheduledDate: Date
      scheduledTime: string | null
      actualCost: number | null
      notes: string | null
      isCompleted: boolean
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["stopActivity"]>
    composites: {}
  }

  type StopActivityGetPayload<S extends boolean | null | undefined | StopActivityDefaultArgs> = $Result.GetResult<Prisma.$StopActivityPayload, S>

  type StopActivityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StopActivityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StopActivityCountAggregateInputType | true
    }

  export interface StopActivityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StopActivity'], meta: { name: 'StopActivity' } }
    /**
     * Find zero or one StopActivity that matches the filter.
     * @param {StopActivityFindUniqueArgs} args - Arguments to find a StopActivity
     * @example
     * // Get one StopActivity
     * const stopActivity = await prisma.stopActivity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StopActivityFindUniqueArgs>(args: SelectSubset<T, StopActivityFindUniqueArgs<ExtArgs>>): Prisma__StopActivityClient<$Result.GetResult<Prisma.$StopActivityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StopActivity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StopActivityFindUniqueOrThrowArgs} args - Arguments to find a StopActivity
     * @example
     * // Get one StopActivity
     * const stopActivity = await prisma.stopActivity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StopActivityFindUniqueOrThrowArgs>(args: SelectSubset<T, StopActivityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StopActivityClient<$Result.GetResult<Prisma.$StopActivityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StopActivity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StopActivityFindFirstArgs} args - Arguments to find a StopActivity
     * @example
     * // Get one StopActivity
     * const stopActivity = await prisma.stopActivity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StopActivityFindFirstArgs>(args?: SelectSubset<T, StopActivityFindFirstArgs<ExtArgs>>): Prisma__StopActivityClient<$Result.GetResult<Prisma.$StopActivityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StopActivity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StopActivityFindFirstOrThrowArgs} args - Arguments to find a StopActivity
     * @example
     * // Get one StopActivity
     * const stopActivity = await prisma.stopActivity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StopActivityFindFirstOrThrowArgs>(args?: SelectSubset<T, StopActivityFindFirstOrThrowArgs<ExtArgs>>): Prisma__StopActivityClient<$Result.GetResult<Prisma.$StopActivityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StopActivities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StopActivityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StopActivities
     * const stopActivities = await prisma.stopActivity.findMany()
     * 
     * // Get first 10 StopActivities
     * const stopActivities = await prisma.stopActivity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stopActivityWithIdOnly = await prisma.stopActivity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StopActivityFindManyArgs>(args?: SelectSubset<T, StopActivityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StopActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StopActivity.
     * @param {StopActivityCreateArgs} args - Arguments to create a StopActivity.
     * @example
     * // Create one StopActivity
     * const StopActivity = await prisma.stopActivity.create({
     *   data: {
     *     // ... data to create a StopActivity
     *   }
     * })
     * 
     */
    create<T extends StopActivityCreateArgs>(args: SelectSubset<T, StopActivityCreateArgs<ExtArgs>>): Prisma__StopActivityClient<$Result.GetResult<Prisma.$StopActivityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StopActivities.
     * @param {StopActivityCreateManyArgs} args - Arguments to create many StopActivities.
     * @example
     * // Create many StopActivities
     * const stopActivity = await prisma.stopActivity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StopActivityCreateManyArgs>(args?: SelectSubset<T, StopActivityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StopActivities and returns the data saved in the database.
     * @param {StopActivityCreateManyAndReturnArgs} args - Arguments to create many StopActivities.
     * @example
     * // Create many StopActivities
     * const stopActivity = await prisma.stopActivity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StopActivities and only return the `id`
     * const stopActivityWithIdOnly = await prisma.stopActivity.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StopActivityCreateManyAndReturnArgs>(args?: SelectSubset<T, StopActivityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StopActivityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StopActivity.
     * @param {StopActivityDeleteArgs} args - Arguments to delete one StopActivity.
     * @example
     * // Delete one StopActivity
     * const StopActivity = await prisma.stopActivity.delete({
     *   where: {
     *     // ... filter to delete one StopActivity
     *   }
     * })
     * 
     */
    delete<T extends StopActivityDeleteArgs>(args: SelectSubset<T, StopActivityDeleteArgs<ExtArgs>>): Prisma__StopActivityClient<$Result.GetResult<Prisma.$StopActivityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StopActivity.
     * @param {StopActivityUpdateArgs} args - Arguments to update one StopActivity.
     * @example
     * // Update one StopActivity
     * const stopActivity = await prisma.stopActivity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StopActivityUpdateArgs>(args: SelectSubset<T, StopActivityUpdateArgs<ExtArgs>>): Prisma__StopActivityClient<$Result.GetResult<Prisma.$StopActivityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StopActivities.
     * @param {StopActivityDeleteManyArgs} args - Arguments to filter StopActivities to delete.
     * @example
     * // Delete a few StopActivities
     * const { count } = await prisma.stopActivity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StopActivityDeleteManyArgs>(args?: SelectSubset<T, StopActivityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StopActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StopActivityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StopActivities
     * const stopActivity = await prisma.stopActivity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StopActivityUpdateManyArgs>(args: SelectSubset<T, StopActivityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StopActivities and returns the data updated in the database.
     * @param {StopActivityUpdateManyAndReturnArgs} args - Arguments to update many StopActivities.
     * @example
     * // Update many StopActivities
     * const stopActivity = await prisma.stopActivity.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StopActivities and only return the `id`
     * const stopActivityWithIdOnly = await prisma.stopActivity.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StopActivityUpdateManyAndReturnArgs>(args: SelectSubset<T, StopActivityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StopActivityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StopActivity.
     * @param {StopActivityUpsertArgs} args - Arguments to update or create a StopActivity.
     * @example
     * // Update or create a StopActivity
     * const stopActivity = await prisma.stopActivity.upsert({
     *   create: {
     *     // ... data to create a StopActivity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StopActivity we want to update
     *   }
     * })
     */
    upsert<T extends StopActivityUpsertArgs>(args: SelectSubset<T, StopActivityUpsertArgs<ExtArgs>>): Prisma__StopActivityClient<$Result.GetResult<Prisma.$StopActivityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StopActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StopActivityCountArgs} args - Arguments to filter StopActivities to count.
     * @example
     * // Count the number of StopActivities
     * const count = await prisma.stopActivity.count({
     *   where: {
     *     // ... the filter for the StopActivities we want to count
     *   }
     * })
    **/
    count<T extends StopActivityCountArgs>(
      args?: Subset<T, StopActivityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StopActivityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StopActivity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StopActivityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StopActivityAggregateArgs>(args: Subset<T, StopActivityAggregateArgs>): Prisma.PrismaPromise<GetStopActivityAggregateType<T>>

    /**
     * Group by StopActivity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StopActivityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StopActivityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StopActivityGroupByArgs['orderBy'] }
        : { orderBy?: StopActivityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StopActivityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStopActivityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StopActivity model
   */
  readonly fields: StopActivityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StopActivity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StopActivityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tripStop<T extends TripStopDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TripStopDefaultArgs<ExtArgs>>): Prisma__TripStopClient<$Result.GetResult<Prisma.$TripStopPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    activity<T extends ActivityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ActivityDefaultArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StopActivity model
   */
  interface StopActivityFieldRefs {
    readonly id: FieldRef<"StopActivity", 'String'>
    readonly tripStopId: FieldRef<"StopActivity", 'String'>
    readonly activityId: FieldRef<"StopActivity", 'String'>
    readonly scheduledDate: FieldRef<"StopActivity", 'DateTime'>
    readonly scheduledTime: FieldRef<"StopActivity", 'String'>
    readonly actualCost: FieldRef<"StopActivity", 'Float'>
    readonly notes: FieldRef<"StopActivity", 'String'>
    readonly isCompleted: FieldRef<"StopActivity", 'Boolean'>
    readonly createdAt: FieldRef<"StopActivity", 'DateTime'>
    readonly updatedAt: FieldRef<"StopActivity", 'DateTime'>
    readonly deletedAt: FieldRef<"StopActivity", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StopActivity findUnique
   */
  export type StopActivityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StopActivity
     */
    select?: StopActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StopActivity
     */
    omit?: StopActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StopActivityInclude<ExtArgs> | null
    /**
     * Filter, which StopActivity to fetch.
     */
    where: StopActivityWhereUniqueInput
  }

  /**
   * StopActivity findUniqueOrThrow
   */
  export type StopActivityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StopActivity
     */
    select?: StopActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StopActivity
     */
    omit?: StopActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StopActivityInclude<ExtArgs> | null
    /**
     * Filter, which StopActivity to fetch.
     */
    where: StopActivityWhereUniqueInput
  }

  /**
   * StopActivity findFirst
   */
  export type StopActivityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StopActivity
     */
    select?: StopActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StopActivity
     */
    omit?: StopActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StopActivityInclude<ExtArgs> | null
    /**
     * Filter, which StopActivity to fetch.
     */
    where?: StopActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StopActivities to fetch.
     */
    orderBy?: StopActivityOrderByWithRelationInput | StopActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StopActivities.
     */
    cursor?: StopActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StopActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StopActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StopActivities.
     */
    distinct?: StopActivityScalarFieldEnum | StopActivityScalarFieldEnum[]
  }

  /**
   * StopActivity findFirstOrThrow
   */
  export type StopActivityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StopActivity
     */
    select?: StopActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StopActivity
     */
    omit?: StopActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StopActivityInclude<ExtArgs> | null
    /**
     * Filter, which StopActivity to fetch.
     */
    where?: StopActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StopActivities to fetch.
     */
    orderBy?: StopActivityOrderByWithRelationInput | StopActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StopActivities.
     */
    cursor?: StopActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StopActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StopActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StopActivities.
     */
    distinct?: StopActivityScalarFieldEnum | StopActivityScalarFieldEnum[]
  }

  /**
   * StopActivity findMany
   */
  export type StopActivityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StopActivity
     */
    select?: StopActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StopActivity
     */
    omit?: StopActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StopActivityInclude<ExtArgs> | null
    /**
     * Filter, which StopActivities to fetch.
     */
    where?: StopActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StopActivities to fetch.
     */
    orderBy?: StopActivityOrderByWithRelationInput | StopActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StopActivities.
     */
    cursor?: StopActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StopActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StopActivities.
     */
    skip?: number
    distinct?: StopActivityScalarFieldEnum | StopActivityScalarFieldEnum[]
  }

  /**
   * StopActivity create
   */
  export type StopActivityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StopActivity
     */
    select?: StopActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StopActivity
     */
    omit?: StopActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StopActivityInclude<ExtArgs> | null
    /**
     * The data needed to create a StopActivity.
     */
    data: XOR<StopActivityCreateInput, StopActivityUncheckedCreateInput>
  }

  /**
   * StopActivity createMany
   */
  export type StopActivityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StopActivities.
     */
    data: StopActivityCreateManyInput | StopActivityCreateManyInput[]
  }

  /**
   * StopActivity createManyAndReturn
   */
  export type StopActivityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StopActivity
     */
    select?: StopActivitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StopActivity
     */
    omit?: StopActivityOmit<ExtArgs> | null
    /**
     * The data used to create many StopActivities.
     */
    data: StopActivityCreateManyInput | StopActivityCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StopActivityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StopActivity update
   */
  export type StopActivityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StopActivity
     */
    select?: StopActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StopActivity
     */
    omit?: StopActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StopActivityInclude<ExtArgs> | null
    /**
     * The data needed to update a StopActivity.
     */
    data: XOR<StopActivityUpdateInput, StopActivityUncheckedUpdateInput>
    /**
     * Choose, which StopActivity to update.
     */
    where: StopActivityWhereUniqueInput
  }

  /**
   * StopActivity updateMany
   */
  export type StopActivityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StopActivities.
     */
    data: XOR<StopActivityUpdateManyMutationInput, StopActivityUncheckedUpdateManyInput>
    /**
     * Filter which StopActivities to update
     */
    where?: StopActivityWhereInput
    /**
     * Limit how many StopActivities to update.
     */
    limit?: number
  }

  /**
   * StopActivity updateManyAndReturn
   */
  export type StopActivityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StopActivity
     */
    select?: StopActivitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StopActivity
     */
    omit?: StopActivityOmit<ExtArgs> | null
    /**
     * The data used to update StopActivities.
     */
    data: XOR<StopActivityUpdateManyMutationInput, StopActivityUncheckedUpdateManyInput>
    /**
     * Filter which StopActivities to update
     */
    where?: StopActivityWhereInput
    /**
     * Limit how many StopActivities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StopActivityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StopActivity upsert
   */
  export type StopActivityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StopActivity
     */
    select?: StopActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StopActivity
     */
    omit?: StopActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StopActivityInclude<ExtArgs> | null
    /**
     * The filter to search for the StopActivity to update in case it exists.
     */
    where: StopActivityWhereUniqueInput
    /**
     * In case the StopActivity found by the `where` argument doesn't exist, create a new StopActivity with this data.
     */
    create: XOR<StopActivityCreateInput, StopActivityUncheckedCreateInput>
    /**
     * In case the StopActivity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StopActivityUpdateInput, StopActivityUncheckedUpdateInput>
  }

  /**
   * StopActivity delete
   */
  export type StopActivityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StopActivity
     */
    select?: StopActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StopActivity
     */
    omit?: StopActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StopActivityInclude<ExtArgs> | null
    /**
     * Filter which StopActivity to delete.
     */
    where: StopActivityWhereUniqueInput
  }

  /**
   * StopActivity deleteMany
   */
  export type StopActivityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StopActivities to delete
     */
    where?: StopActivityWhereInput
    /**
     * Limit how many StopActivities to delete.
     */
    limit?: number
  }

  /**
   * StopActivity without action
   */
  export type StopActivityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StopActivity
     */
    select?: StopActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StopActivity
     */
    omit?: StopActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StopActivityInclude<ExtArgs> | null
  }


  /**
   * Model TripBudget
   */

  export type AggregateTripBudget = {
    _count: TripBudgetCountAggregateOutputType | null
    _avg: TripBudgetAvgAggregateOutputType | null
    _sum: TripBudgetSumAggregateOutputType | null
    _min: TripBudgetMinAggregateOutputType | null
    _max: TripBudgetMaxAggregateOutputType | null
  }

  export type TripBudgetAvgAggregateOutputType = {
    estimatedAmount: number | null
    actualAmount: number | null
  }

  export type TripBudgetSumAggregateOutputType = {
    estimatedAmount: number | null
    actualAmount: number | null
  }

  export type TripBudgetMinAggregateOutputType = {
    id: string | null
    tripId: string | null
    category: string | null
    estimatedAmount: number | null
    actualAmount: number | null
    currency: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type TripBudgetMaxAggregateOutputType = {
    id: string | null
    tripId: string | null
    category: string | null
    estimatedAmount: number | null
    actualAmount: number | null
    currency: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type TripBudgetCountAggregateOutputType = {
    id: number
    tripId: number
    category: number
    estimatedAmount: number
    actualAmount: number
    currency: number
    notes: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type TripBudgetAvgAggregateInputType = {
    estimatedAmount?: true
    actualAmount?: true
  }

  export type TripBudgetSumAggregateInputType = {
    estimatedAmount?: true
    actualAmount?: true
  }

  export type TripBudgetMinAggregateInputType = {
    id?: true
    tripId?: true
    category?: true
    estimatedAmount?: true
    actualAmount?: true
    currency?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type TripBudgetMaxAggregateInputType = {
    id?: true
    tripId?: true
    category?: true
    estimatedAmount?: true
    actualAmount?: true
    currency?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type TripBudgetCountAggregateInputType = {
    id?: true
    tripId?: true
    category?: true
    estimatedAmount?: true
    actualAmount?: true
    currency?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type TripBudgetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TripBudget to aggregate.
     */
    where?: TripBudgetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TripBudgets to fetch.
     */
    orderBy?: TripBudgetOrderByWithRelationInput | TripBudgetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TripBudgetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TripBudgets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TripBudgets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TripBudgets
    **/
    _count?: true | TripBudgetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TripBudgetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TripBudgetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TripBudgetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TripBudgetMaxAggregateInputType
  }

  export type GetTripBudgetAggregateType<T extends TripBudgetAggregateArgs> = {
        [P in keyof T & keyof AggregateTripBudget]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTripBudget[P]>
      : GetScalarType<T[P], AggregateTripBudget[P]>
  }




  export type TripBudgetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TripBudgetWhereInput
    orderBy?: TripBudgetOrderByWithAggregationInput | TripBudgetOrderByWithAggregationInput[]
    by: TripBudgetScalarFieldEnum[] | TripBudgetScalarFieldEnum
    having?: TripBudgetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TripBudgetCountAggregateInputType | true
    _avg?: TripBudgetAvgAggregateInputType
    _sum?: TripBudgetSumAggregateInputType
    _min?: TripBudgetMinAggregateInputType
    _max?: TripBudgetMaxAggregateInputType
  }

  export type TripBudgetGroupByOutputType = {
    id: string
    tripId: string
    category: string
    estimatedAmount: number
    actualAmount: number | null
    currency: string
    notes: string | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: TripBudgetCountAggregateOutputType | null
    _avg: TripBudgetAvgAggregateOutputType | null
    _sum: TripBudgetSumAggregateOutputType | null
    _min: TripBudgetMinAggregateOutputType | null
    _max: TripBudgetMaxAggregateOutputType | null
  }

  type GetTripBudgetGroupByPayload<T extends TripBudgetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TripBudgetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TripBudgetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TripBudgetGroupByOutputType[P]>
            : GetScalarType<T[P], TripBudgetGroupByOutputType[P]>
        }
      >
    >


  export type TripBudgetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tripId?: boolean
    category?: boolean
    estimatedAmount?: boolean
    actualAmount?: boolean
    currency?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    trip?: boolean | TripDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tripBudget"]>

  export type TripBudgetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tripId?: boolean
    category?: boolean
    estimatedAmount?: boolean
    actualAmount?: boolean
    currency?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    trip?: boolean | TripDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tripBudget"]>

  export type TripBudgetSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tripId?: boolean
    category?: boolean
    estimatedAmount?: boolean
    actualAmount?: boolean
    currency?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    trip?: boolean | TripDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tripBudget"]>

  export type TripBudgetSelectScalar = {
    id?: boolean
    tripId?: boolean
    category?: boolean
    estimatedAmount?: boolean
    actualAmount?: boolean
    currency?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type TripBudgetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tripId" | "category" | "estimatedAmount" | "actualAmount" | "currency" | "notes" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["tripBudget"]>
  export type TripBudgetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trip?: boolean | TripDefaultArgs<ExtArgs>
  }
  export type TripBudgetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trip?: boolean | TripDefaultArgs<ExtArgs>
  }
  export type TripBudgetIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trip?: boolean | TripDefaultArgs<ExtArgs>
  }

  export type $TripBudgetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TripBudget"
    objects: {
      trip: Prisma.$TripPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tripId: string
      category: string
      estimatedAmount: number
      actualAmount: number | null
      currency: string
      notes: string | null
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["tripBudget"]>
    composites: {}
  }

  type TripBudgetGetPayload<S extends boolean | null | undefined | TripBudgetDefaultArgs> = $Result.GetResult<Prisma.$TripBudgetPayload, S>

  type TripBudgetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TripBudgetFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TripBudgetCountAggregateInputType | true
    }

  export interface TripBudgetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TripBudget'], meta: { name: 'TripBudget' } }
    /**
     * Find zero or one TripBudget that matches the filter.
     * @param {TripBudgetFindUniqueArgs} args - Arguments to find a TripBudget
     * @example
     * // Get one TripBudget
     * const tripBudget = await prisma.tripBudget.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TripBudgetFindUniqueArgs>(args: SelectSubset<T, TripBudgetFindUniqueArgs<ExtArgs>>): Prisma__TripBudgetClient<$Result.GetResult<Prisma.$TripBudgetPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TripBudget that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TripBudgetFindUniqueOrThrowArgs} args - Arguments to find a TripBudget
     * @example
     * // Get one TripBudget
     * const tripBudget = await prisma.tripBudget.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TripBudgetFindUniqueOrThrowArgs>(args: SelectSubset<T, TripBudgetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TripBudgetClient<$Result.GetResult<Prisma.$TripBudgetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TripBudget that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripBudgetFindFirstArgs} args - Arguments to find a TripBudget
     * @example
     * // Get one TripBudget
     * const tripBudget = await prisma.tripBudget.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TripBudgetFindFirstArgs>(args?: SelectSubset<T, TripBudgetFindFirstArgs<ExtArgs>>): Prisma__TripBudgetClient<$Result.GetResult<Prisma.$TripBudgetPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TripBudget that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripBudgetFindFirstOrThrowArgs} args - Arguments to find a TripBudget
     * @example
     * // Get one TripBudget
     * const tripBudget = await prisma.tripBudget.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TripBudgetFindFirstOrThrowArgs>(args?: SelectSubset<T, TripBudgetFindFirstOrThrowArgs<ExtArgs>>): Prisma__TripBudgetClient<$Result.GetResult<Prisma.$TripBudgetPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TripBudgets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripBudgetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TripBudgets
     * const tripBudgets = await prisma.tripBudget.findMany()
     * 
     * // Get first 10 TripBudgets
     * const tripBudgets = await prisma.tripBudget.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tripBudgetWithIdOnly = await prisma.tripBudget.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TripBudgetFindManyArgs>(args?: SelectSubset<T, TripBudgetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TripBudgetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TripBudget.
     * @param {TripBudgetCreateArgs} args - Arguments to create a TripBudget.
     * @example
     * // Create one TripBudget
     * const TripBudget = await prisma.tripBudget.create({
     *   data: {
     *     // ... data to create a TripBudget
     *   }
     * })
     * 
     */
    create<T extends TripBudgetCreateArgs>(args: SelectSubset<T, TripBudgetCreateArgs<ExtArgs>>): Prisma__TripBudgetClient<$Result.GetResult<Prisma.$TripBudgetPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TripBudgets.
     * @param {TripBudgetCreateManyArgs} args - Arguments to create many TripBudgets.
     * @example
     * // Create many TripBudgets
     * const tripBudget = await prisma.tripBudget.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TripBudgetCreateManyArgs>(args?: SelectSubset<T, TripBudgetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TripBudgets and returns the data saved in the database.
     * @param {TripBudgetCreateManyAndReturnArgs} args - Arguments to create many TripBudgets.
     * @example
     * // Create many TripBudgets
     * const tripBudget = await prisma.tripBudget.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TripBudgets and only return the `id`
     * const tripBudgetWithIdOnly = await prisma.tripBudget.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TripBudgetCreateManyAndReturnArgs>(args?: SelectSubset<T, TripBudgetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TripBudgetPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TripBudget.
     * @param {TripBudgetDeleteArgs} args - Arguments to delete one TripBudget.
     * @example
     * // Delete one TripBudget
     * const TripBudget = await prisma.tripBudget.delete({
     *   where: {
     *     // ... filter to delete one TripBudget
     *   }
     * })
     * 
     */
    delete<T extends TripBudgetDeleteArgs>(args: SelectSubset<T, TripBudgetDeleteArgs<ExtArgs>>): Prisma__TripBudgetClient<$Result.GetResult<Prisma.$TripBudgetPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TripBudget.
     * @param {TripBudgetUpdateArgs} args - Arguments to update one TripBudget.
     * @example
     * // Update one TripBudget
     * const tripBudget = await prisma.tripBudget.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TripBudgetUpdateArgs>(args: SelectSubset<T, TripBudgetUpdateArgs<ExtArgs>>): Prisma__TripBudgetClient<$Result.GetResult<Prisma.$TripBudgetPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TripBudgets.
     * @param {TripBudgetDeleteManyArgs} args - Arguments to filter TripBudgets to delete.
     * @example
     * // Delete a few TripBudgets
     * const { count } = await prisma.tripBudget.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TripBudgetDeleteManyArgs>(args?: SelectSubset<T, TripBudgetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TripBudgets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripBudgetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TripBudgets
     * const tripBudget = await prisma.tripBudget.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TripBudgetUpdateManyArgs>(args: SelectSubset<T, TripBudgetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TripBudgets and returns the data updated in the database.
     * @param {TripBudgetUpdateManyAndReturnArgs} args - Arguments to update many TripBudgets.
     * @example
     * // Update many TripBudgets
     * const tripBudget = await prisma.tripBudget.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TripBudgets and only return the `id`
     * const tripBudgetWithIdOnly = await prisma.tripBudget.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TripBudgetUpdateManyAndReturnArgs>(args: SelectSubset<T, TripBudgetUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TripBudgetPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TripBudget.
     * @param {TripBudgetUpsertArgs} args - Arguments to update or create a TripBudget.
     * @example
     * // Update or create a TripBudget
     * const tripBudget = await prisma.tripBudget.upsert({
     *   create: {
     *     // ... data to create a TripBudget
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TripBudget we want to update
     *   }
     * })
     */
    upsert<T extends TripBudgetUpsertArgs>(args: SelectSubset<T, TripBudgetUpsertArgs<ExtArgs>>): Prisma__TripBudgetClient<$Result.GetResult<Prisma.$TripBudgetPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TripBudgets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripBudgetCountArgs} args - Arguments to filter TripBudgets to count.
     * @example
     * // Count the number of TripBudgets
     * const count = await prisma.tripBudget.count({
     *   where: {
     *     // ... the filter for the TripBudgets we want to count
     *   }
     * })
    **/
    count<T extends TripBudgetCountArgs>(
      args?: Subset<T, TripBudgetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TripBudgetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TripBudget.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripBudgetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TripBudgetAggregateArgs>(args: Subset<T, TripBudgetAggregateArgs>): Prisma.PrismaPromise<GetTripBudgetAggregateType<T>>

    /**
     * Group by TripBudget.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripBudgetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TripBudgetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TripBudgetGroupByArgs['orderBy'] }
        : { orderBy?: TripBudgetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TripBudgetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTripBudgetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TripBudget model
   */
  readonly fields: TripBudgetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TripBudget.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TripBudgetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    trip<T extends TripDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TripDefaultArgs<ExtArgs>>): Prisma__TripClient<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TripBudget model
   */
  interface TripBudgetFieldRefs {
    readonly id: FieldRef<"TripBudget", 'String'>
    readonly tripId: FieldRef<"TripBudget", 'String'>
    readonly category: FieldRef<"TripBudget", 'String'>
    readonly estimatedAmount: FieldRef<"TripBudget", 'Float'>
    readonly actualAmount: FieldRef<"TripBudget", 'Float'>
    readonly currency: FieldRef<"TripBudget", 'String'>
    readonly notes: FieldRef<"TripBudget", 'String'>
    readonly createdAt: FieldRef<"TripBudget", 'DateTime'>
    readonly updatedAt: FieldRef<"TripBudget", 'DateTime'>
    readonly deletedAt: FieldRef<"TripBudget", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TripBudget findUnique
   */
  export type TripBudgetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripBudget
     */
    select?: TripBudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TripBudget
     */
    omit?: TripBudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripBudgetInclude<ExtArgs> | null
    /**
     * Filter, which TripBudget to fetch.
     */
    where: TripBudgetWhereUniqueInput
  }

  /**
   * TripBudget findUniqueOrThrow
   */
  export type TripBudgetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripBudget
     */
    select?: TripBudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TripBudget
     */
    omit?: TripBudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripBudgetInclude<ExtArgs> | null
    /**
     * Filter, which TripBudget to fetch.
     */
    where: TripBudgetWhereUniqueInput
  }

  /**
   * TripBudget findFirst
   */
  export type TripBudgetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripBudget
     */
    select?: TripBudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TripBudget
     */
    omit?: TripBudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripBudgetInclude<ExtArgs> | null
    /**
     * Filter, which TripBudget to fetch.
     */
    where?: TripBudgetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TripBudgets to fetch.
     */
    orderBy?: TripBudgetOrderByWithRelationInput | TripBudgetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TripBudgets.
     */
    cursor?: TripBudgetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TripBudgets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TripBudgets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TripBudgets.
     */
    distinct?: TripBudgetScalarFieldEnum | TripBudgetScalarFieldEnum[]
  }

  /**
   * TripBudget findFirstOrThrow
   */
  export type TripBudgetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripBudget
     */
    select?: TripBudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TripBudget
     */
    omit?: TripBudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripBudgetInclude<ExtArgs> | null
    /**
     * Filter, which TripBudget to fetch.
     */
    where?: TripBudgetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TripBudgets to fetch.
     */
    orderBy?: TripBudgetOrderByWithRelationInput | TripBudgetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TripBudgets.
     */
    cursor?: TripBudgetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TripBudgets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TripBudgets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TripBudgets.
     */
    distinct?: TripBudgetScalarFieldEnum | TripBudgetScalarFieldEnum[]
  }

  /**
   * TripBudget findMany
   */
  export type TripBudgetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripBudget
     */
    select?: TripBudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TripBudget
     */
    omit?: TripBudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripBudgetInclude<ExtArgs> | null
    /**
     * Filter, which TripBudgets to fetch.
     */
    where?: TripBudgetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TripBudgets to fetch.
     */
    orderBy?: TripBudgetOrderByWithRelationInput | TripBudgetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TripBudgets.
     */
    cursor?: TripBudgetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TripBudgets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TripBudgets.
     */
    skip?: number
    distinct?: TripBudgetScalarFieldEnum | TripBudgetScalarFieldEnum[]
  }

  /**
   * TripBudget create
   */
  export type TripBudgetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripBudget
     */
    select?: TripBudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TripBudget
     */
    omit?: TripBudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripBudgetInclude<ExtArgs> | null
    /**
     * The data needed to create a TripBudget.
     */
    data: XOR<TripBudgetCreateInput, TripBudgetUncheckedCreateInput>
  }

  /**
   * TripBudget createMany
   */
  export type TripBudgetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TripBudgets.
     */
    data: TripBudgetCreateManyInput | TripBudgetCreateManyInput[]
  }

  /**
   * TripBudget createManyAndReturn
   */
  export type TripBudgetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripBudget
     */
    select?: TripBudgetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TripBudget
     */
    omit?: TripBudgetOmit<ExtArgs> | null
    /**
     * The data used to create many TripBudgets.
     */
    data: TripBudgetCreateManyInput | TripBudgetCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripBudgetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TripBudget update
   */
  export type TripBudgetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripBudget
     */
    select?: TripBudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TripBudget
     */
    omit?: TripBudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripBudgetInclude<ExtArgs> | null
    /**
     * The data needed to update a TripBudget.
     */
    data: XOR<TripBudgetUpdateInput, TripBudgetUncheckedUpdateInput>
    /**
     * Choose, which TripBudget to update.
     */
    where: TripBudgetWhereUniqueInput
  }

  /**
   * TripBudget updateMany
   */
  export type TripBudgetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TripBudgets.
     */
    data: XOR<TripBudgetUpdateManyMutationInput, TripBudgetUncheckedUpdateManyInput>
    /**
     * Filter which TripBudgets to update
     */
    where?: TripBudgetWhereInput
    /**
     * Limit how many TripBudgets to update.
     */
    limit?: number
  }

  /**
   * TripBudget updateManyAndReturn
   */
  export type TripBudgetUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripBudget
     */
    select?: TripBudgetSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TripBudget
     */
    omit?: TripBudgetOmit<ExtArgs> | null
    /**
     * The data used to update TripBudgets.
     */
    data: XOR<TripBudgetUpdateManyMutationInput, TripBudgetUncheckedUpdateManyInput>
    /**
     * Filter which TripBudgets to update
     */
    where?: TripBudgetWhereInput
    /**
     * Limit how many TripBudgets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripBudgetIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TripBudget upsert
   */
  export type TripBudgetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripBudget
     */
    select?: TripBudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TripBudget
     */
    omit?: TripBudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripBudgetInclude<ExtArgs> | null
    /**
     * The filter to search for the TripBudget to update in case it exists.
     */
    where: TripBudgetWhereUniqueInput
    /**
     * In case the TripBudget found by the `where` argument doesn't exist, create a new TripBudget with this data.
     */
    create: XOR<TripBudgetCreateInput, TripBudgetUncheckedCreateInput>
    /**
     * In case the TripBudget was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TripBudgetUpdateInput, TripBudgetUncheckedUpdateInput>
  }

  /**
   * TripBudget delete
   */
  export type TripBudgetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripBudget
     */
    select?: TripBudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TripBudget
     */
    omit?: TripBudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripBudgetInclude<ExtArgs> | null
    /**
     * Filter which TripBudget to delete.
     */
    where: TripBudgetWhereUniqueInput
  }

  /**
   * TripBudget deleteMany
   */
  export type TripBudgetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TripBudgets to delete
     */
    where?: TripBudgetWhereInput
    /**
     * Limit how many TripBudgets to delete.
     */
    limit?: number
  }

  /**
   * TripBudget without action
   */
  export type TripBudgetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripBudget
     */
    select?: TripBudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TripBudget
     */
    omit?: TripBudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripBudgetInclude<ExtArgs> | null
  }


  /**
   * Model TripMedia
   */

  export type AggregateTripMedia = {
    _count: TripMediaCountAggregateOutputType | null
    _avg: TripMediaAvgAggregateOutputType | null
    _sum: TripMediaSumAggregateOutputType | null
    _min: TripMediaMinAggregateOutputType | null
    _max: TripMediaMaxAggregateOutputType | null
  }

  export type TripMediaAvgAggregateOutputType = {
    displayOrder: number | null
  }

  export type TripMediaSumAggregateOutputType = {
    displayOrder: number | null
  }

  export type TripMediaMinAggregateOutputType = {
    id: string | null
    tripId: string | null
    mediaType: string | null
    mediaUrl: string | null
    thumbnailUrl: string | null
    caption: string | null
    displayOrder: number | null
    uploadedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type TripMediaMaxAggregateOutputType = {
    id: string | null
    tripId: string | null
    mediaType: string | null
    mediaUrl: string | null
    thumbnailUrl: string | null
    caption: string | null
    displayOrder: number | null
    uploadedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type TripMediaCountAggregateOutputType = {
    id: number
    tripId: number
    mediaType: number
    mediaUrl: number
    thumbnailUrl: number
    caption: number
    displayOrder: number
    uploadedAt: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type TripMediaAvgAggregateInputType = {
    displayOrder?: true
  }

  export type TripMediaSumAggregateInputType = {
    displayOrder?: true
  }

  export type TripMediaMinAggregateInputType = {
    id?: true
    tripId?: true
    mediaType?: true
    mediaUrl?: true
    thumbnailUrl?: true
    caption?: true
    displayOrder?: true
    uploadedAt?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type TripMediaMaxAggregateInputType = {
    id?: true
    tripId?: true
    mediaType?: true
    mediaUrl?: true
    thumbnailUrl?: true
    caption?: true
    displayOrder?: true
    uploadedAt?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type TripMediaCountAggregateInputType = {
    id?: true
    tripId?: true
    mediaType?: true
    mediaUrl?: true
    thumbnailUrl?: true
    caption?: true
    displayOrder?: true
    uploadedAt?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type TripMediaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TripMedia to aggregate.
     */
    where?: TripMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TripMedias to fetch.
     */
    orderBy?: TripMediaOrderByWithRelationInput | TripMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TripMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TripMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TripMedias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TripMedias
    **/
    _count?: true | TripMediaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TripMediaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TripMediaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TripMediaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TripMediaMaxAggregateInputType
  }

  export type GetTripMediaAggregateType<T extends TripMediaAggregateArgs> = {
        [P in keyof T & keyof AggregateTripMedia]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTripMedia[P]>
      : GetScalarType<T[P], AggregateTripMedia[P]>
  }




  export type TripMediaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TripMediaWhereInput
    orderBy?: TripMediaOrderByWithAggregationInput | TripMediaOrderByWithAggregationInput[]
    by: TripMediaScalarFieldEnum[] | TripMediaScalarFieldEnum
    having?: TripMediaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TripMediaCountAggregateInputType | true
    _avg?: TripMediaAvgAggregateInputType
    _sum?: TripMediaSumAggregateInputType
    _min?: TripMediaMinAggregateInputType
    _max?: TripMediaMaxAggregateInputType
  }

  export type TripMediaGroupByOutputType = {
    id: string
    tripId: string
    mediaType: string
    mediaUrl: string
    thumbnailUrl: string | null
    caption: string | null
    displayOrder: number | null
    uploadedAt: Date
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: TripMediaCountAggregateOutputType | null
    _avg: TripMediaAvgAggregateOutputType | null
    _sum: TripMediaSumAggregateOutputType | null
    _min: TripMediaMinAggregateOutputType | null
    _max: TripMediaMaxAggregateOutputType | null
  }

  type GetTripMediaGroupByPayload<T extends TripMediaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TripMediaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TripMediaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TripMediaGroupByOutputType[P]>
            : GetScalarType<T[P], TripMediaGroupByOutputType[P]>
        }
      >
    >


  export type TripMediaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tripId?: boolean
    mediaType?: boolean
    mediaUrl?: boolean
    thumbnailUrl?: boolean
    caption?: boolean
    displayOrder?: boolean
    uploadedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    trip?: boolean | TripDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tripMedia"]>

  export type TripMediaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tripId?: boolean
    mediaType?: boolean
    mediaUrl?: boolean
    thumbnailUrl?: boolean
    caption?: boolean
    displayOrder?: boolean
    uploadedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    trip?: boolean | TripDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tripMedia"]>

  export type TripMediaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tripId?: boolean
    mediaType?: boolean
    mediaUrl?: boolean
    thumbnailUrl?: boolean
    caption?: boolean
    displayOrder?: boolean
    uploadedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    trip?: boolean | TripDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tripMedia"]>

  export type TripMediaSelectScalar = {
    id?: boolean
    tripId?: boolean
    mediaType?: boolean
    mediaUrl?: boolean
    thumbnailUrl?: boolean
    caption?: boolean
    displayOrder?: boolean
    uploadedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type TripMediaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tripId" | "mediaType" | "mediaUrl" | "thumbnailUrl" | "caption" | "displayOrder" | "uploadedAt" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["tripMedia"]>
  export type TripMediaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trip?: boolean | TripDefaultArgs<ExtArgs>
  }
  export type TripMediaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trip?: boolean | TripDefaultArgs<ExtArgs>
  }
  export type TripMediaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trip?: boolean | TripDefaultArgs<ExtArgs>
  }

  export type $TripMediaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TripMedia"
    objects: {
      trip: Prisma.$TripPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tripId: string
      mediaType: string
      mediaUrl: string
      thumbnailUrl: string | null
      caption: string | null
      displayOrder: number | null
      uploadedAt: Date
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["tripMedia"]>
    composites: {}
  }

  type TripMediaGetPayload<S extends boolean | null | undefined | TripMediaDefaultArgs> = $Result.GetResult<Prisma.$TripMediaPayload, S>

  type TripMediaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TripMediaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TripMediaCountAggregateInputType | true
    }

  export interface TripMediaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TripMedia'], meta: { name: 'TripMedia' } }
    /**
     * Find zero or one TripMedia that matches the filter.
     * @param {TripMediaFindUniqueArgs} args - Arguments to find a TripMedia
     * @example
     * // Get one TripMedia
     * const tripMedia = await prisma.tripMedia.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TripMediaFindUniqueArgs>(args: SelectSubset<T, TripMediaFindUniqueArgs<ExtArgs>>): Prisma__TripMediaClient<$Result.GetResult<Prisma.$TripMediaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TripMedia that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TripMediaFindUniqueOrThrowArgs} args - Arguments to find a TripMedia
     * @example
     * // Get one TripMedia
     * const tripMedia = await prisma.tripMedia.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TripMediaFindUniqueOrThrowArgs>(args: SelectSubset<T, TripMediaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TripMediaClient<$Result.GetResult<Prisma.$TripMediaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TripMedia that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripMediaFindFirstArgs} args - Arguments to find a TripMedia
     * @example
     * // Get one TripMedia
     * const tripMedia = await prisma.tripMedia.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TripMediaFindFirstArgs>(args?: SelectSubset<T, TripMediaFindFirstArgs<ExtArgs>>): Prisma__TripMediaClient<$Result.GetResult<Prisma.$TripMediaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TripMedia that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripMediaFindFirstOrThrowArgs} args - Arguments to find a TripMedia
     * @example
     * // Get one TripMedia
     * const tripMedia = await prisma.tripMedia.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TripMediaFindFirstOrThrowArgs>(args?: SelectSubset<T, TripMediaFindFirstOrThrowArgs<ExtArgs>>): Prisma__TripMediaClient<$Result.GetResult<Prisma.$TripMediaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TripMedias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripMediaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TripMedias
     * const tripMedias = await prisma.tripMedia.findMany()
     * 
     * // Get first 10 TripMedias
     * const tripMedias = await prisma.tripMedia.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tripMediaWithIdOnly = await prisma.tripMedia.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TripMediaFindManyArgs>(args?: SelectSubset<T, TripMediaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TripMediaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TripMedia.
     * @param {TripMediaCreateArgs} args - Arguments to create a TripMedia.
     * @example
     * // Create one TripMedia
     * const TripMedia = await prisma.tripMedia.create({
     *   data: {
     *     // ... data to create a TripMedia
     *   }
     * })
     * 
     */
    create<T extends TripMediaCreateArgs>(args: SelectSubset<T, TripMediaCreateArgs<ExtArgs>>): Prisma__TripMediaClient<$Result.GetResult<Prisma.$TripMediaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TripMedias.
     * @param {TripMediaCreateManyArgs} args - Arguments to create many TripMedias.
     * @example
     * // Create many TripMedias
     * const tripMedia = await prisma.tripMedia.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TripMediaCreateManyArgs>(args?: SelectSubset<T, TripMediaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TripMedias and returns the data saved in the database.
     * @param {TripMediaCreateManyAndReturnArgs} args - Arguments to create many TripMedias.
     * @example
     * // Create many TripMedias
     * const tripMedia = await prisma.tripMedia.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TripMedias and only return the `id`
     * const tripMediaWithIdOnly = await prisma.tripMedia.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TripMediaCreateManyAndReturnArgs>(args?: SelectSubset<T, TripMediaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TripMediaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TripMedia.
     * @param {TripMediaDeleteArgs} args - Arguments to delete one TripMedia.
     * @example
     * // Delete one TripMedia
     * const TripMedia = await prisma.tripMedia.delete({
     *   where: {
     *     // ... filter to delete one TripMedia
     *   }
     * })
     * 
     */
    delete<T extends TripMediaDeleteArgs>(args: SelectSubset<T, TripMediaDeleteArgs<ExtArgs>>): Prisma__TripMediaClient<$Result.GetResult<Prisma.$TripMediaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TripMedia.
     * @param {TripMediaUpdateArgs} args - Arguments to update one TripMedia.
     * @example
     * // Update one TripMedia
     * const tripMedia = await prisma.tripMedia.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TripMediaUpdateArgs>(args: SelectSubset<T, TripMediaUpdateArgs<ExtArgs>>): Prisma__TripMediaClient<$Result.GetResult<Prisma.$TripMediaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TripMedias.
     * @param {TripMediaDeleteManyArgs} args - Arguments to filter TripMedias to delete.
     * @example
     * // Delete a few TripMedias
     * const { count } = await prisma.tripMedia.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TripMediaDeleteManyArgs>(args?: SelectSubset<T, TripMediaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TripMedias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripMediaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TripMedias
     * const tripMedia = await prisma.tripMedia.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TripMediaUpdateManyArgs>(args: SelectSubset<T, TripMediaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TripMedias and returns the data updated in the database.
     * @param {TripMediaUpdateManyAndReturnArgs} args - Arguments to update many TripMedias.
     * @example
     * // Update many TripMedias
     * const tripMedia = await prisma.tripMedia.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TripMedias and only return the `id`
     * const tripMediaWithIdOnly = await prisma.tripMedia.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TripMediaUpdateManyAndReturnArgs>(args: SelectSubset<T, TripMediaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TripMediaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TripMedia.
     * @param {TripMediaUpsertArgs} args - Arguments to update or create a TripMedia.
     * @example
     * // Update or create a TripMedia
     * const tripMedia = await prisma.tripMedia.upsert({
     *   create: {
     *     // ... data to create a TripMedia
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TripMedia we want to update
     *   }
     * })
     */
    upsert<T extends TripMediaUpsertArgs>(args: SelectSubset<T, TripMediaUpsertArgs<ExtArgs>>): Prisma__TripMediaClient<$Result.GetResult<Prisma.$TripMediaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TripMedias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripMediaCountArgs} args - Arguments to filter TripMedias to count.
     * @example
     * // Count the number of TripMedias
     * const count = await prisma.tripMedia.count({
     *   where: {
     *     // ... the filter for the TripMedias we want to count
     *   }
     * })
    **/
    count<T extends TripMediaCountArgs>(
      args?: Subset<T, TripMediaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TripMediaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TripMedia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripMediaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TripMediaAggregateArgs>(args: Subset<T, TripMediaAggregateArgs>): Prisma.PrismaPromise<GetTripMediaAggregateType<T>>

    /**
     * Group by TripMedia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripMediaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TripMediaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TripMediaGroupByArgs['orderBy'] }
        : { orderBy?: TripMediaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TripMediaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTripMediaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TripMedia model
   */
  readonly fields: TripMediaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TripMedia.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TripMediaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    trip<T extends TripDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TripDefaultArgs<ExtArgs>>): Prisma__TripClient<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TripMedia model
   */
  interface TripMediaFieldRefs {
    readonly id: FieldRef<"TripMedia", 'String'>
    readonly tripId: FieldRef<"TripMedia", 'String'>
    readonly mediaType: FieldRef<"TripMedia", 'String'>
    readonly mediaUrl: FieldRef<"TripMedia", 'String'>
    readonly thumbnailUrl: FieldRef<"TripMedia", 'String'>
    readonly caption: FieldRef<"TripMedia", 'String'>
    readonly displayOrder: FieldRef<"TripMedia", 'Int'>
    readonly uploadedAt: FieldRef<"TripMedia", 'DateTime'>
    readonly createdAt: FieldRef<"TripMedia", 'DateTime'>
    readonly updatedAt: FieldRef<"TripMedia", 'DateTime'>
    readonly deletedAt: FieldRef<"TripMedia", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TripMedia findUnique
   */
  export type TripMediaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripMedia
     */
    select?: TripMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TripMedia
     */
    omit?: TripMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripMediaInclude<ExtArgs> | null
    /**
     * Filter, which TripMedia to fetch.
     */
    where: TripMediaWhereUniqueInput
  }

  /**
   * TripMedia findUniqueOrThrow
   */
  export type TripMediaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripMedia
     */
    select?: TripMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TripMedia
     */
    omit?: TripMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripMediaInclude<ExtArgs> | null
    /**
     * Filter, which TripMedia to fetch.
     */
    where: TripMediaWhereUniqueInput
  }

  /**
   * TripMedia findFirst
   */
  export type TripMediaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripMedia
     */
    select?: TripMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TripMedia
     */
    omit?: TripMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripMediaInclude<ExtArgs> | null
    /**
     * Filter, which TripMedia to fetch.
     */
    where?: TripMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TripMedias to fetch.
     */
    orderBy?: TripMediaOrderByWithRelationInput | TripMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TripMedias.
     */
    cursor?: TripMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TripMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TripMedias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TripMedias.
     */
    distinct?: TripMediaScalarFieldEnum | TripMediaScalarFieldEnum[]
  }

  /**
   * TripMedia findFirstOrThrow
   */
  export type TripMediaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripMedia
     */
    select?: TripMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TripMedia
     */
    omit?: TripMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripMediaInclude<ExtArgs> | null
    /**
     * Filter, which TripMedia to fetch.
     */
    where?: TripMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TripMedias to fetch.
     */
    orderBy?: TripMediaOrderByWithRelationInput | TripMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TripMedias.
     */
    cursor?: TripMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TripMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TripMedias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TripMedias.
     */
    distinct?: TripMediaScalarFieldEnum | TripMediaScalarFieldEnum[]
  }

  /**
   * TripMedia findMany
   */
  export type TripMediaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripMedia
     */
    select?: TripMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TripMedia
     */
    omit?: TripMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripMediaInclude<ExtArgs> | null
    /**
     * Filter, which TripMedias to fetch.
     */
    where?: TripMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TripMedias to fetch.
     */
    orderBy?: TripMediaOrderByWithRelationInput | TripMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TripMedias.
     */
    cursor?: TripMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TripMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TripMedias.
     */
    skip?: number
    distinct?: TripMediaScalarFieldEnum | TripMediaScalarFieldEnum[]
  }

  /**
   * TripMedia create
   */
  export type TripMediaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripMedia
     */
    select?: TripMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TripMedia
     */
    omit?: TripMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripMediaInclude<ExtArgs> | null
    /**
     * The data needed to create a TripMedia.
     */
    data: XOR<TripMediaCreateInput, TripMediaUncheckedCreateInput>
  }

  /**
   * TripMedia createMany
   */
  export type TripMediaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TripMedias.
     */
    data: TripMediaCreateManyInput | TripMediaCreateManyInput[]
  }

  /**
   * TripMedia createManyAndReturn
   */
  export type TripMediaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripMedia
     */
    select?: TripMediaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TripMedia
     */
    omit?: TripMediaOmit<ExtArgs> | null
    /**
     * The data used to create many TripMedias.
     */
    data: TripMediaCreateManyInput | TripMediaCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripMediaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TripMedia update
   */
  export type TripMediaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripMedia
     */
    select?: TripMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TripMedia
     */
    omit?: TripMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripMediaInclude<ExtArgs> | null
    /**
     * The data needed to update a TripMedia.
     */
    data: XOR<TripMediaUpdateInput, TripMediaUncheckedUpdateInput>
    /**
     * Choose, which TripMedia to update.
     */
    where: TripMediaWhereUniqueInput
  }

  /**
   * TripMedia updateMany
   */
  export type TripMediaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TripMedias.
     */
    data: XOR<TripMediaUpdateManyMutationInput, TripMediaUncheckedUpdateManyInput>
    /**
     * Filter which TripMedias to update
     */
    where?: TripMediaWhereInput
    /**
     * Limit how many TripMedias to update.
     */
    limit?: number
  }

  /**
   * TripMedia updateManyAndReturn
   */
  export type TripMediaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripMedia
     */
    select?: TripMediaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TripMedia
     */
    omit?: TripMediaOmit<ExtArgs> | null
    /**
     * The data used to update TripMedias.
     */
    data: XOR<TripMediaUpdateManyMutationInput, TripMediaUncheckedUpdateManyInput>
    /**
     * Filter which TripMedias to update
     */
    where?: TripMediaWhereInput
    /**
     * Limit how many TripMedias to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripMediaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TripMedia upsert
   */
  export type TripMediaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripMedia
     */
    select?: TripMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TripMedia
     */
    omit?: TripMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripMediaInclude<ExtArgs> | null
    /**
     * The filter to search for the TripMedia to update in case it exists.
     */
    where: TripMediaWhereUniqueInput
    /**
     * In case the TripMedia found by the `where` argument doesn't exist, create a new TripMedia with this data.
     */
    create: XOR<TripMediaCreateInput, TripMediaUncheckedCreateInput>
    /**
     * In case the TripMedia was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TripMediaUpdateInput, TripMediaUncheckedUpdateInput>
  }

  /**
   * TripMedia delete
   */
  export type TripMediaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripMedia
     */
    select?: TripMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TripMedia
     */
    omit?: TripMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripMediaInclude<ExtArgs> | null
    /**
     * Filter which TripMedia to delete.
     */
    where: TripMediaWhereUniqueInput
  }

  /**
   * TripMedia deleteMany
   */
  export type TripMediaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TripMedias to delete
     */
    where?: TripMediaWhereInput
    /**
     * Limit how many TripMedias to delete.
     */
    limit?: number
  }

  /**
   * TripMedia without action
   */
  export type TripMediaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripMedia
     */
    select?: TripMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TripMedia
     */
    omit?: TripMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripMediaInclude<ExtArgs> | null
  }


  /**
   * Model TripShare
   */

  export type AggregateTripShare = {
    _count: TripShareCountAggregateOutputType | null
    _avg: TripShareAvgAggregateOutputType | null
    _sum: TripShareSumAggregateOutputType | null
    _min: TripShareMinAggregateOutputType | null
    _max: TripShareMaxAggregateOutputType | null
  }

  export type TripShareAvgAggregateOutputType = {
    viewCount: number | null
  }

  export type TripShareSumAggregateOutputType = {
    viewCount: number | null
  }

  export type TripShareMinAggregateOutputType = {
    id: string | null
    tripId: string | null
    shareToken: string | null
    shareType: string | null
    sharedWithEmail: string | null
    viewCount: number | null
    lastViewedAt: Date | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type TripShareMaxAggregateOutputType = {
    id: string | null
    tripId: string | null
    shareToken: string | null
    shareType: string | null
    sharedWithEmail: string | null
    viewCount: number | null
    lastViewedAt: Date | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type TripShareCountAggregateOutputType = {
    id: number
    tripId: number
    shareToken: number
    shareType: number
    sharedWithEmail: number
    viewCount: number
    lastViewedAt: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type TripShareAvgAggregateInputType = {
    viewCount?: true
  }

  export type TripShareSumAggregateInputType = {
    viewCount?: true
  }

  export type TripShareMinAggregateInputType = {
    id?: true
    tripId?: true
    shareToken?: true
    shareType?: true
    sharedWithEmail?: true
    viewCount?: true
    lastViewedAt?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type TripShareMaxAggregateInputType = {
    id?: true
    tripId?: true
    shareToken?: true
    shareType?: true
    sharedWithEmail?: true
    viewCount?: true
    lastViewedAt?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type TripShareCountAggregateInputType = {
    id?: true
    tripId?: true
    shareToken?: true
    shareType?: true
    sharedWithEmail?: true
    viewCount?: true
    lastViewedAt?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type TripShareAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TripShare to aggregate.
     */
    where?: TripShareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TripShares to fetch.
     */
    orderBy?: TripShareOrderByWithRelationInput | TripShareOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TripShareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TripShares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TripShares.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TripShares
    **/
    _count?: true | TripShareCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TripShareAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TripShareSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TripShareMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TripShareMaxAggregateInputType
  }

  export type GetTripShareAggregateType<T extends TripShareAggregateArgs> = {
        [P in keyof T & keyof AggregateTripShare]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTripShare[P]>
      : GetScalarType<T[P], AggregateTripShare[P]>
  }




  export type TripShareGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TripShareWhereInput
    orderBy?: TripShareOrderByWithAggregationInput | TripShareOrderByWithAggregationInput[]
    by: TripShareScalarFieldEnum[] | TripShareScalarFieldEnum
    having?: TripShareScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TripShareCountAggregateInputType | true
    _avg?: TripShareAvgAggregateInputType
    _sum?: TripShareSumAggregateInputType
    _min?: TripShareMinAggregateInputType
    _max?: TripShareMaxAggregateInputType
  }

  export type TripShareGroupByOutputType = {
    id: string
    tripId: string
    shareToken: string
    shareType: string
    sharedWithEmail: string | null
    viewCount: number
    lastViewedAt: Date | null
    expiresAt: Date | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: TripShareCountAggregateOutputType | null
    _avg: TripShareAvgAggregateOutputType | null
    _sum: TripShareSumAggregateOutputType | null
    _min: TripShareMinAggregateOutputType | null
    _max: TripShareMaxAggregateOutputType | null
  }

  type GetTripShareGroupByPayload<T extends TripShareGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TripShareGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TripShareGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TripShareGroupByOutputType[P]>
            : GetScalarType<T[P], TripShareGroupByOutputType[P]>
        }
      >
    >


  export type TripShareSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tripId?: boolean
    shareToken?: boolean
    shareType?: boolean
    sharedWithEmail?: boolean
    viewCount?: boolean
    lastViewedAt?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    trip?: boolean | TripDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tripShare"]>

  export type TripShareSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tripId?: boolean
    shareToken?: boolean
    shareType?: boolean
    sharedWithEmail?: boolean
    viewCount?: boolean
    lastViewedAt?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    trip?: boolean | TripDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tripShare"]>

  export type TripShareSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tripId?: boolean
    shareToken?: boolean
    shareType?: boolean
    sharedWithEmail?: boolean
    viewCount?: boolean
    lastViewedAt?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    trip?: boolean | TripDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tripShare"]>

  export type TripShareSelectScalar = {
    id?: boolean
    tripId?: boolean
    shareToken?: boolean
    shareType?: boolean
    sharedWithEmail?: boolean
    viewCount?: boolean
    lastViewedAt?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type TripShareOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tripId" | "shareToken" | "shareType" | "sharedWithEmail" | "viewCount" | "lastViewedAt" | "expiresAt" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["tripShare"]>
  export type TripShareInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trip?: boolean | TripDefaultArgs<ExtArgs>
  }
  export type TripShareIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trip?: boolean | TripDefaultArgs<ExtArgs>
  }
  export type TripShareIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trip?: boolean | TripDefaultArgs<ExtArgs>
  }

  export type $TripSharePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TripShare"
    objects: {
      trip: Prisma.$TripPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tripId: string
      shareToken: string
      shareType: string
      sharedWithEmail: string | null
      viewCount: number
      lastViewedAt: Date | null
      expiresAt: Date | null
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["tripShare"]>
    composites: {}
  }

  type TripShareGetPayload<S extends boolean | null | undefined | TripShareDefaultArgs> = $Result.GetResult<Prisma.$TripSharePayload, S>

  type TripShareCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TripShareFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TripShareCountAggregateInputType | true
    }

  export interface TripShareDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TripShare'], meta: { name: 'TripShare' } }
    /**
     * Find zero or one TripShare that matches the filter.
     * @param {TripShareFindUniqueArgs} args - Arguments to find a TripShare
     * @example
     * // Get one TripShare
     * const tripShare = await prisma.tripShare.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TripShareFindUniqueArgs>(args: SelectSubset<T, TripShareFindUniqueArgs<ExtArgs>>): Prisma__TripShareClient<$Result.GetResult<Prisma.$TripSharePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TripShare that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TripShareFindUniqueOrThrowArgs} args - Arguments to find a TripShare
     * @example
     * // Get one TripShare
     * const tripShare = await prisma.tripShare.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TripShareFindUniqueOrThrowArgs>(args: SelectSubset<T, TripShareFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TripShareClient<$Result.GetResult<Prisma.$TripSharePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TripShare that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripShareFindFirstArgs} args - Arguments to find a TripShare
     * @example
     * // Get one TripShare
     * const tripShare = await prisma.tripShare.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TripShareFindFirstArgs>(args?: SelectSubset<T, TripShareFindFirstArgs<ExtArgs>>): Prisma__TripShareClient<$Result.GetResult<Prisma.$TripSharePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TripShare that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripShareFindFirstOrThrowArgs} args - Arguments to find a TripShare
     * @example
     * // Get one TripShare
     * const tripShare = await prisma.tripShare.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TripShareFindFirstOrThrowArgs>(args?: SelectSubset<T, TripShareFindFirstOrThrowArgs<ExtArgs>>): Prisma__TripShareClient<$Result.GetResult<Prisma.$TripSharePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TripShares that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripShareFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TripShares
     * const tripShares = await prisma.tripShare.findMany()
     * 
     * // Get first 10 TripShares
     * const tripShares = await prisma.tripShare.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tripShareWithIdOnly = await prisma.tripShare.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TripShareFindManyArgs>(args?: SelectSubset<T, TripShareFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TripSharePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TripShare.
     * @param {TripShareCreateArgs} args - Arguments to create a TripShare.
     * @example
     * // Create one TripShare
     * const TripShare = await prisma.tripShare.create({
     *   data: {
     *     // ... data to create a TripShare
     *   }
     * })
     * 
     */
    create<T extends TripShareCreateArgs>(args: SelectSubset<T, TripShareCreateArgs<ExtArgs>>): Prisma__TripShareClient<$Result.GetResult<Prisma.$TripSharePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TripShares.
     * @param {TripShareCreateManyArgs} args - Arguments to create many TripShares.
     * @example
     * // Create many TripShares
     * const tripShare = await prisma.tripShare.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TripShareCreateManyArgs>(args?: SelectSubset<T, TripShareCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TripShares and returns the data saved in the database.
     * @param {TripShareCreateManyAndReturnArgs} args - Arguments to create many TripShares.
     * @example
     * // Create many TripShares
     * const tripShare = await prisma.tripShare.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TripShares and only return the `id`
     * const tripShareWithIdOnly = await prisma.tripShare.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TripShareCreateManyAndReturnArgs>(args?: SelectSubset<T, TripShareCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TripSharePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TripShare.
     * @param {TripShareDeleteArgs} args - Arguments to delete one TripShare.
     * @example
     * // Delete one TripShare
     * const TripShare = await prisma.tripShare.delete({
     *   where: {
     *     // ... filter to delete one TripShare
     *   }
     * })
     * 
     */
    delete<T extends TripShareDeleteArgs>(args: SelectSubset<T, TripShareDeleteArgs<ExtArgs>>): Prisma__TripShareClient<$Result.GetResult<Prisma.$TripSharePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TripShare.
     * @param {TripShareUpdateArgs} args - Arguments to update one TripShare.
     * @example
     * // Update one TripShare
     * const tripShare = await prisma.tripShare.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TripShareUpdateArgs>(args: SelectSubset<T, TripShareUpdateArgs<ExtArgs>>): Prisma__TripShareClient<$Result.GetResult<Prisma.$TripSharePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TripShares.
     * @param {TripShareDeleteManyArgs} args - Arguments to filter TripShares to delete.
     * @example
     * // Delete a few TripShares
     * const { count } = await prisma.tripShare.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TripShareDeleteManyArgs>(args?: SelectSubset<T, TripShareDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TripShares.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripShareUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TripShares
     * const tripShare = await prisma.tripShare.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TripShareUpdateManyArgs>(args: SelectSubset<T, TripShareUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TripShares and returns the data updated in the database.
     * @param {TripShareUpdateManyAndReturnArgs} args - Arguments to update many TripShares.
     * @example
     * // Update many TripShares
     * const tripShare = await prisma.tripShare.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TripShares and only return the `id`
     * const tripShareWithIdOnly = await prisma.tripShare.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TripShareUpdateManyAndReturnArgs>(args: SelectSubset<T, TripShareUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TripSharePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TripShare.
     * @param {TripShareUpsertArgs} args - Arguments to update or create a TripShare.
     * @example
     * // Update or create a TripShare
     * const tripShare = await prisma.tripShare.upsert({
     *   create: {
     *     // ... data to create a TripShare
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TripShare we want to update
     *   }
     * })
     */
    upsert<T extends TripShareUpsertArgs>(args: SelectSubset<T, TripShareUpsertArgs<ExtArgs>>): Prisma__TripShareClient<$Result.GetResult<Prisma.$TripSharePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TripShares.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripShareCountArgs} args - Arguments to filter TripShares to count.
     * @example
     * // Count the number of TripShares
     * const count = await prisma.tripShare.count({
     *   where: {
     *     // ... the filter for the TripShares we want to count
     *   }
     * })
    **/
    count<T extends TripShareCountArgs>(
      args?: Subset<T, TripShareCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TripShareCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TripShare.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripShareAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TripShareAggregateArgs>(args: Subset<T, TripShareAggregateArgs>): Prisma.PrismaPromise<GetTripShareAggregateType<T>>

    /**
     * Group by TripShare.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripShareGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TripShareGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TripShareGroupByArgs['orderBy'] }
        : { orderBy?: TripShareGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TripShareGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTripShareGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TripShare model
   */
  readonly fields: TripShareFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TripShare.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TripShareClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    trip<T extends TripDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TripDefaultArgs<ExtArgs>>): Prisma__TripClient<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TripShare model
   */
  interface TripShareFieldRefs {
    readonly id: FieldRef<"TripShare", 'String'>
    readonly tripId: FieldRef<"TripShare", 'String'>
    readonly shareToken: FieldRef<"TripShare", 'String'>
    readonly shareType: FieldRef<"TripShare", 'String'>
    readonly sharedWithEmail: FieldRef<"TripShare", 'String'>
    readonly viewCount: FieldRef<"TripShare", 'Int'>
    readonly lastViewedAt: FieldRef<"TripShare", 'DateTime'>
    readonly expiresAt: FieldRef<"TripShare", 'DateTime'>
    readonly createdAt: FieldRef<"TripShare", 'DateTime'>
    readonly updatedAt: FieldRef<"TripShare", 'DateTime'>
    readonly deletedAt: FieldRef<"TripShare", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TripShare findUnique
   */
  export type TripShareFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripShare
     */
    select?: TripShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TripShare
     */
    omit?: TripShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripShareInclude<ExtArgs> | null
    /**
     * Filter, which TripShare to fetch.
     */
    where: TripShareWhereUniqueInput
  }

  /**
   * TripShare findUniqueOrThrow
   */
  export type TripShareFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripShare
     */
    select?: TripShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TripShare
     */
    omit?: TripShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripShareInclude<ExtArgs> | null
    /**
     * Filter, which TripShare to fetch.
     */
    where: TripShareWhereUniqueInput
  }

  /**
   * TripShare findFirst
   */
  export type TripShareFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripShare
     */
    select?: TripShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TripShare
     */
    omit?: TripShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripShareInclude<ExtArgs> | null
    /**
     * Filter, which TripShare to fetch.
     */
    where?: TripShareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TripShares to fetch.
     */
    orderBy?: TripShareOrderByWithRelationInput | TripShareOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TripShares.
     */
    cursor?: TripShareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TripShares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TripShares.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TripShares.
     */
    distinct?: TripShareScalarFieldEnum | TripShareScalarFieldEnum[]
  }

  /**
   * TripShare findFirstOrThrow
   */
  export type TripShareFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripShare
     */
    select?: TripShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TripShare
     */
    omit?: TripShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripShareInclude<ExtArgs> | null
    /**
     * Filter, which TripShare to fetch.
     */
    where?: TripShareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TripShares to fetch.
     */
    orderBy?: TripShareOrderByWithRelationInput | TripShareOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TripShares.
     */
    cursor?: TripShareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TripShares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TripShares.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TripShares.
     */
    distinct?: TripShareScalarFieldEnum | TripShareScalarFieldEnum[]
  }

  /**
   * TripShare findMany
   */
  export type TripShareFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripShare
     */
    select?: TripShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TripShare
     */
    omit?: TripShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripShareInclude<ExtArgs> | null
    /**
     * Filter, which TripShares to fetch.
     */
    where?: TripShareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TripShares to fetch.
     */
    orderBy?: TripShareOrderByWithRelationInput | TripShareOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TripShares.
     */
    cursor?: TripShareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TripShares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TripShares.
     */
    skip?: number
    distinct?: TripShareScalarFieldEnum | TripShareScalarFieldEnum[]
  }

  /**
   * TripShare create
   */
  export type TripShareCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripShare
     */
    select?: TripShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TripShare
     */
    omit?: TripShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripShareInclude<ExtArgs> | null
    /**
     * The data needed to create a TripShare.
     */
    data: XOR<TripShareCreateInput, TripShareUncheckedCreateInput>
  }

  /**
   * TripShare createMany
   */
  export type TripShareCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TripShares.
     */
    data: TripShareCreateManyInput | TripShareCreateManyInput[]
  }

  /**
   * TripShare createManyAndReturn
   */
  export type TripShareCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripShare
     */
    select?: TripShareSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TripShare
     */
    omit?: TripShareOmit<ExtArgs> | null
    /**
     * The data used to create many TripShares.
     */
    data: TripShareCreateManyInput | TripShareCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripShareIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TripShare update
   */
  export type TripShareUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripShare
     */
    select?: TripShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TripShare
     */
    omit?: TripShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripShareInclude<ExtArgs> | null
    /**
     * The data needed to update a TripShare.
     */
    data: XOR<TripShareUpdateInput, TripShareUncheckedUpdateInput>
    /**
     * Choose, which TripShare to update.
     */
    where: TripShareWhereUniqueInput
  }

  /**
   * TripShare updateMany
   */
  export type TripShareUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TripShares.
     */
    data: XOR<TripShareUpdateManyMutationInput, TripShareUncheckedUpdateManyInput>
    /**
     * Filter which TripShares to update
     */
    where?: TripShareWhereInput
    /**
     * Limit how many TripShares to update.
     */
    limit?: number
  }

  /**
   * TripShare updateManyAndReturn
   */
  export type TripShareUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripShare
     */
    select?: TripShareSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TripShare
     */
    omit?: TripShareOmit<ExtArgs> | null
    /**
     * The data used to update TripShares.
     */
    data: XOR<TripShareUpdateManyMutationInput, TripShareUncheckedUpdateManyInput>
    /**
     * Filter which TripShares to update
     */
    where?: TripShareWhereInput
    /**
     * Limit how many TripShares to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripShareIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TripShare upsert
   */
  export type TripShareUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripShare
     */
    select?: TripShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TripShare
     */
    omit?: TripShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripShareInclude<ExtArgs> | null
    /**
     * The filter to search for the TripShare to update in case it exists.
     */
    where: TripShareWhereUniqueInput
    /**
     * In case the TripShare found by the `where` argument doesn't exist, create a new TripShare with this data.
     */
    create: XOR<TripShareCreateInput, TripShareUncheckedCreateInput>
    /**
     * In case the TripShare was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TripShareUpdateInput, TripShareUncheckedUpdateInput>
  }

  /**
   * TripShare delete
   */
  export type TripShareDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripShare
     */
    select?: TripShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TripShare
     */
    omit?: TripShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripShareInclude<ExtArgs> | null
    /**
     * Filter which TripShare to delete.
     */
    where: TripShareWhereUniqueInput
  }

  /**
   * TripShare deleteMany
   */
  export type TripShareDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TripShares to delete
     */
    where?: TripShareWhereInput
    /**
     * Limit how many TripShares to delete.
     */
    limit?: number
  }

  /**
   * TripShare without action
   */
  export type TripShareDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripShare
     */
    select?: TripShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TripShare
     */
    omit?: TripShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripShareInclude<ExtArgs> | null
  }


  /**
   * Model TripVersion
   */

  export type AggregateTripVersion = {
    _count: TripVersionCountAggregateOutputType | null
    _avg: TripVersionAvgAggregateOutputType | null
    _sum: TripVersionSumAggregateOutputType | null
    _min: TripVersionMinAggregateOutputType | null
    _max: TripVersionMaxAggregateOutputType | null
  }

  export type TripVersionAvgAggregateOutputType = {
    versionNumber: number | null
  }

  export type TripVersionSumAggregateOutputType = {
    versionNumber: number | null
  }

  export type TripVersionMinAggregateOutputType = {
    id: string | null
    tripId: string | null
    versionNumber: number | null
    snapshotData: string | null
    changeSummary: string | null
    createdBy: string | null
    createdAt: Date | null
  }

  export type TripVersionMaxAggregateOutputType = {
    id: string | null
    tripId: string | null
    versionNumber: number | null
    snapshotData: string | null
    changeSummary: string | null
    createdBy: string | null
    createdAt: Date | null
  }

  export type TripVersionCountAggregateOutputType = {
    id: number
    tripId: number
    versionNumber: number
    snapshotData: number
    changeSummary: number
    createdBy: number
    createdAt: number
    _all: number
  }


  export type TripVersionAvgAggregateInputType = {
    versionNumber?: true
  }

  export type TripVersionSumAggregateInputType = {
    versionNumber?: true
  }

  export type TripVersionMinAggregateInputType = {
    id?: true
    tripId?: true
    versionNumber?: true
    snapshotData?: true
    changeSummary?: true
    createdBy?: true
    createdAt?: true
  }

  export type TripVersionMaxAggregateInputType = {
    id?: true
    tripId?: true
    versionNumber?: true
    snapshotData?: true
    changeSummary?: true
    createdBy?: true
    createdAt?: true
  }

  export type TripVersionCountAggregateInputType = {
    id?: true
    tripId?: true
    versionNumber?: true
    snapshotData?: true
    changeSummary?: true
    createdBy?: true
    createdAt?: true
    _all?: true
  }

  export type TripVersionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TripVersion to aggregate.
     */
    where?: TripVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TripVersions to fetch.
     */
    orderBy?: TripVersionOrderByWithRelationInput | TripVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TripVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TripVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TripVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TripVersions
    **/
    _count?: true | TripVersionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TripVersionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TripVersionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TripVersionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TripVersionMaxAggregateInputType
  }

  export type GetTripVersionAggregateType<T extends TripVersionAggregateArgs> = {
        [P in keyof T & keyof AggregateTripVersion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTripVersion[P]>
      : GetScalarType<T[P], AggregateTripVersion[P]>
  }




  export type TripVersionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TripVersionWhereInput
    orderBy?: TripVersionOrderByWithAggregationInput | TripVersionOrderByWithAggregationInput[]
    by: TripVersionScalarFieldEnum[] | TripVersionScalarFieldEnum
    having?: TripVersionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TripVersionCountAggregateInputType | true
    _avg?: TripVersionAvgAggregateInputType
    _sum?: TripVersionSumAggregateInputType
    _min?: TripVersionMinAggregateInputType
    _max?: TripVersionMaxAggregateInputType
  }

  export type TripVersionGroupByOutputType = {
    id: string
    tripId: string
    versionNumber: number
    snapshotData: string
    changeSummary: string | null
    createdBy: string
    createdAt: Date
    _count: TripVersionCountAggregateOutputType | null
    _avg: TripVersionAvgAggregateOutputType | null
    _sum: TripVersionSumAggregateOutputType | null
    _min: TripVersionMinAggregateOutputType | null
    _max: TripVersionMaxAggregateOutputType | null
  }

  type GetTripVersionGroupByPayload<T extends TripVersionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TripVersionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TripVersionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TripVersionGroupByOutputType[P]>
            : GetScalarType<T[P], TripVersionGroupByOutputType[P]>
        }
      >
    >


  export type TripVersionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tripId?: boolean
    versionNumber?: boolean
    snapshotData?: boolean
    changeSummary?: boolean
    createdBy?: boolean
    createdAt?: boolean
    trip?: boolean | TripDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tripVersion"]>

  export type TripVersionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tripId?: boolean
    versionNumber?: boolean
    snapshotData?: boolean
    changeSummary?: boolean
    createdBy?: boolean
    createdAt?: boolean
    trip?: boolean | TripDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tripVersion"]>

  export type TripVersionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tripId?: boolean
    versionNumber?: boolean
    snapshotData?: boolean
    changeSummary?: boolean
    createdBy?: boolean
    createdAt?: boolean
    trip?: boolean | TripDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tripVersion"]>

  export type TripVersionSelectScalar = {
    id?: boolean
    tripId?: boolean
    versionNumber?: boolean
    snapshotData?: boolean
    changeSummary?: boolean
    createdBy?: boolean
    createdAt?: boolean
  }

  export type TripVersionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tripId" | "versionNumber" | "snapshotData" | "changeSummary" | "createdBy" | "createdAt", ExtArgs["result"]["tripVersion"]>
  export type TripVersionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trip?: boolean | TripDefaultArgs<ExtArgs>
  }
  export type TripVersionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trip?: boolean | TripDefaultArgs<ExtArgs>
  }
  export type TripVersionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trip?: boolean | TripDefaultArgs<ExtArgs>
  }

  export type $TripVersionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TripVersion"
    objects: {
      trip: Prisma.$TripPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tripId: string
      versionNumber: number
      snapshotData: string
      changeSummary: string | null
      createdBy: string
      createdAt: Date
    }, ExtArgs["result"]["tripVersion"]>
    composites: {}
  }

  type TripVersionGetPayload<S extends boolean | null | undefined | TripVersionDefaultArgs> = $Result.GetResult<Prisma.$TripVersionPayload, S>

  type TripVersionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TripVersionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TripVersionCountAggregateInputType | true
    }

  export interface TripVersionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TripVersion'], meta: { name: 'TripVersion' } }
    /**
     * Find zero or one TripVersion that matches the filter.
     * @param {TripVersionFindUniqueArgs} args - Arguments to find a TripVersion
     * @example
     * // Get one TripVersion
     * const tripVersion = await prisma.tripVersion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TripVersionFindUniqueArgs>(args: SelectSubset<T, TripVersionFindUniqueArgs<ExtArgs>>): Prisma__TripVersionClient<$Result.GetResult<Prisma.$TripVersionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TripVersion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TripVersionFindUniqueOrThrowArgs} args - Arguments to find a TripVersion
     * @example
     * // Get one TripVersion
     * const tripVersion = await prisma.tripVersion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TripVersionFindUniqueOrThrowArgs>(args: SelectSubset<T, TripVersionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TripVersionClient<$Result.GetResult<Prisma.$TripVersionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TripVersion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripVersionFindFirstArgs} args - Arguments to find a TripVersion
     * @example
     * // Get one TripVersion
     * const tripVersion = await prisma.tripVersion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TripVersionFindFirstArgs>(args?: SelectSubset<T, TripVersionFindFirstArgs<ExtArgs>>): Prisma__TripVersionClient<$Result.GetResult<Prisma.$TripVersionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TripVersion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripVersionFindFirstOrThrowArgs} args - Arguments to find a TripVersion
     * @example
     * // Get one TripVersion
     * const tripVersion = await prisma.tripVersion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TripVersionFindFirstOrThrowArgs>(args?: SelectSubset<T, TripVersionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TripVersionClient<$Result.GetResult<Prisma.$TripVersionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TripVersions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripVersionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TripVersions
     * const tripVersions = await prisma.tripVersion.findMany()
     * 
     * // Get first 10 TripVersions
     * const tripVersions = await prisma.tripVersion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tripVersionWithIdOnly = await prisma.tripVersion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TripVersionFindManyArgs>(args?: SelectSubset<T, TripVersionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TripVersionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TripVersion.
     * @param {TripVersionCreateArgs} args - Arguments to create a TripVersion.
     * @example
     * // Create one TripVersion
     * const TripVersion = await prisma.tripVersion.create({
     *   data: {
     *     // ... data to create a TripVersion
     *   }
     * })
     * 
     */
    create<T extends TripVersionCreateArgs>(args: SelectSubset<T, TripVersionCreateArgs<ExtArgs>>): Prisma__TripVersionClient<$Result.GetResult<Prisma.$TripVersionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TripVersions.
     * @param {TripVersionCreateManyArgs} args - Arguments to create many TripVersions.
     * @example
     * // Create many TripVersions
     * const tripVersion = await prisma.tripVersion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TripVersionCreateManyArgs>(args?: SelectSubset<T, TripVersionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TripVersions and returns the data saved in the database.
     * @param {TripVersionCreateManyAndReturnArgs} args - Arguments to create many TripVersions.
     * @example
     * // Create many TripVersions
     * const tripVersion = await prisma.tripVersion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TripVersions and only return the `id`
     * const tripVersionWithIdOnly = await prisma.tripVersion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TripVersionCreateManyAndReturnArgs>(args?: SelectSubset<T, TripVersionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TripVersionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TripVersion.
     * @param {TripVersionDeleteArgs} args - Arguments to delete one TripVersion.
     * @example
     * // Delete one TripVersion
     * const TripVersion = await prisma.tripVersion.delete({
     *   where: {
     *     // ... filter to delete one TripVersion
     *   }
     * })
     * 
     */
    delete<T extends TripVersionDeleteArgs>(args: SelectSubset<T, TripVersionDeleteArgs<ExtArgs>>): Prisma__TripVersionClient<$Result.GetResult<Prisma.$TripVersionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TripVersion.
     * @param {TripVersionUpdateArgs} args - Arguments to update one TripVersion.
     * @example
     * // Update one TripVersion
     * const tripVersion = await prisma.tripVersion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TripVersionUpdateArgs>(args: SelectSubset<T, TripVersionUpdateArgs<ExtArgs>>): Prisma__TripVersionClient<$Result.GetResult<Prisma.$TripVersionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TripVersions.
     * @param {TripVersionDeleteManyArgs} args - Arguments to filter TripVersions to delete.
     * @example
     * // Delete a few TripVersions
     * const { count } = await prisma.tripVersion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TripVersionDeleteManyArgs>(args?: SelectSubset<T, TripVersionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TripVersions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripVersionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TripVersions
     * const tripVersion = await prisma.tripVersion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TripVersionUpdateManyArgs>(args: SelectSubset<T, TripVersionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TripVersions and returns the data updated in the database.
     * @param {TripVersionUpdateManyAndReturnArgs} args - Arguments to update many TripVersions.
     * @example
     * // Update many TripVersions
     * const tripVersion = await prisma.tripVersion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TripVersions and only return the `id`
     * const tripVersionWithIdOnly = await prisma.tripVersion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TripVersionUpdateManyAndReturnArgs>(args: SelectSubset<T, TripVersionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TripVersionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TripVersion.
     * @param {TripVersionUpsertArgs} args - Arguments to update or create a TripVersion.
     * @example
     * // Update or create a TripVersion
     * const tripVersion = await prisma.tripVersion.upsert({
     *   create: {
     *     // ... data to create a TripVersion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TripVersion we want to update
     *   }
     * })
     */
    upsert<T extends TripVersionUpsertArgs>(args: SelectSubset<T, TripVersionUpsertArgs<ExtArgs>>): Prisma__TripVersionClient<$Result.GetResult<Prisma.$TripVersionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TripVersions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripVersionCountArgs} args - Arguments to filter TripVersions to count.
     * @example
     * // Count the number of TripVersions
     * const count = await prisma.tripVersion.count({
     *   where: {
     *     // ... the filter for the TripVersions we want to count
     *   }
     * })
    **/
    count<T extends TripVersionCountArgs>(
      args?: Subset<T, TripVersionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TripVersionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TripVersion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripVersionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TripVersionAggregateArgs>(args: Subset<T, TripVersionAggregateArgs>): Prisma.PrismaPromise<GetTripVersionAggregateType<T>>

    /**
     * Group by TripVersion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripVersionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TripVersionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TripVersionGroupByArgs['orderBy'] }
        : { orderBy?: TripVersionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TripVersionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTripVersionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TripVersion model
   */
  readonly fields: TripVersionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TripVersion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TripVersionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    trip<T extends TripDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TripDefaultArgs<ExtArgs>>): Prisma__TripClient<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TripVersion model
   */
  interface TripVersionFieldRefs {
    readonly id: FieldRef<"TripVersion", 'String'>
    readonly tripId: FieldRef<"TripVersion", 'String'>
    readonly versionNumber: FieldRef<"TripVersion", 'Int'>
    readonly snapshotData: FieldRef<"TripVersion", 'String'>
    readonly changeSummary: FieldRef<"TripVersion", 'String'>
    readonly createdBy: FieldRef<"TripVersion", 'String'>
    readonly createdAt: FieldRef<"TripVersion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TripVersion findUnique
   */
  export type TripVersionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripVersion
     */
    select?: TripVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TripVersion
     */
    omit?: TripVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripVersionInclude<ExtArgs> | null
    /**
     * Filter, which TripVersion to fetch.
     */
    where: TripVersionWhereUniqueInput
  }

  /**
   * TripVersion findUniqueOrThrow
   */
  export type TripVersionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripVersion
     */
    select?: TripVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TripVersion
     */
    omit?: TripVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripVersionInclude<ExtArgs> | null
    /**
     * Filter, which TripVersion to fetch.
     */
    where: TripVersionWhereUniqueInput
  }

  /**
   * TripVersion findFirst
   */
  export type TripVersionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripVersion
     */
    select?: TripVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TripVersion
     */
    omit?: TripVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripVersionInclude<ExtArgs> | null
    /**
     * Filter, which TripVersion to fetch.
     */
    where?: TripVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TripVersions to fetch.
     */
    orderBy?: TripVersionOrderByWithRelationInput | TripVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TripVersions.
     */
    cursor?: TripVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TripVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TripVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TripVersions.
     */
    distinct?: TripVersionScalarFieldEnum | TripVersionScalarFieldEnum[]
  }

  /**
   * TripVersion findFirstOrThrow
   */
  export type TripVersionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripVersion
     */
    select?: TripVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TripVersion
     */
    omit?: TripVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripVersionInclude<ExtArgs> | null
    /**
     * Filter, which TripVersion to fetch.
     */
    where?: TripVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TripVersions to fetch.
     */
    orderBy?: TripVersionOrderByWithRelationInput | TripVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TripVersions.
     */
    cursor?: TripVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TripVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TripVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TripVersions.
     */
    distinct?: TripVersionScalarFieldEnum | TripVersionScalarFieldEnum[]
  }

  /**
   * TripVersion findMany
   */
  export type TripVersionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripVersion
     */
    select?: TripVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TripVersion
     */
    omit?: TripVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripVersionInclude<ExtArgs> | null
    /**
     * Filter, which TripVersions to fetch.
     */
    where?: TripVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TripVersions to fetch.
     */
    orderBy?: TripVersionOrderByWithRelationInput | TripVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TripVersions.
     */
    cursor?: TripVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TripVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TripVersions.
     */
    skip?: number
    distinct?: TripVersionScalarFieldEnum | TripVersionScalarFieldEnum[]
  }

  /**
   * TripVersion create
   */
  export type TripVersionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripVersion
     */
    select?: TripVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TripVersion
     */
    omit?: TripVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripVersionInclude<ExtArgs> | null
    /**
     * The data needed to create a TripVersion.
     */
    data: XOR<TripVersionCreateInput, TripVersionUncheckedCreateInput>
  }

  /**
   * TripVersion createMany
   */
  export type TripVersionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TripVersions.
     */
    data: TripVersionCreateManyInput | TripVersionCreateManyInput[]
  }

  /**
   * TripVersion createManyAndReturn
   */
  export type TripVersionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripVersion
     */
    select?: TripVersionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TripVersion
     */
    omit?: TripVersionOmit<ExtArgs> | null
    /**
     * The data used to create many TripVersions.
     */
    data: TripVersionCreateManyInput | TripVersionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripVersionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TripVersion update
   */
  export type TripVersionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripVersion
     */
    select?: TripVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TripVersion
     */
    omit?: TripVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripVersionInclude<ExtArgs> | null
    /**
     * The data needed to update a TripVersion.
     */
    data: XOR<TripVersionUpdateInput, TripVersionUncheckedUpdateInput>
    /**
     * Choose, which TripVersion to update.
     */
    where: TripVersionWhereUniqueInput
  }

  /**
   * TripVersion updateMany
   */
  export type TripVersionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TripVersions.
     */
    data: XOR<TripVersionUpdateManyMutationInput, TripVersionUncheckedUpdateManyInput>
    /**
     * Filter which TripVersions to update
     */
    where?: TripVersionWhereInput
    /**
     * Limit how many TripVersions to update.
     */
    limit?: number
  }

  /**
   * TripVersion updateManyAndReturn
   */
  export type TripVersionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripVersion
     */
    select?: TripVersionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TripVersion
     */
    omit?: TripVersionOmit<ExtArgs> | null
    /**
     * The data used to update TripVersions.
     */
    data: XOR<TripVersionUpdateManyMutationInput, TripVersionUncheckedUpdateManyInput>
    /**
     * Filter which TripVersions to update
     */
    where?: TripVersionWhereInput
    /**
     * Limit how many TripVersions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripVersionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TripVersion upsert
   */
  export type TripVersionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripVersion
     */
    select?: TripVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TripVersion
     */
    omit?: TripVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripVersionInclude<ExtArgs> | null
    /**
     * The filter to search for the TripVersion to update in case it exists.
     */
    where: TripVersionWhereUniqueInput
    /**
     * In case the TripVersion found by the `where` argument doesn't exist, create a new TripVersion with this data.
     */
    create: XOR<TripVersionCreateInput, TripVersionUncheckedCreateInput>
    /**
     * In case the TripVersion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TripVersionUpdateInput, TripVersionUncheckedUpdateInput>
  }

  /**
   * TripVersion delete
   */
  export type TripVersionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripVersion
     */
    select?: TripVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TripVersion
     */
    omit?: TripVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripVersionInclude<ExtArgs> | null
    /**
     * Filter which TripVersion to delete.
     */
    where: TripVersionWhereUniqueInput
  }

  /**
   * TripVersion deleteMany
   */
  export type TripVersionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TripVersions to delete
     */
    where?: TripVersionWhereInput
    /**
     * Limit how many TripVersions to delete.
     */
    limit?: number
  }

  /**
   * TripVersion without action
   */
  export type TripVersionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripVersion
     */
    select?: TripVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TripVersion
     */
    omit?: TripVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripVersionInclude<ExtArgs> | null
  }


  /**
   * Model UserSavedDestination
   */

  export type AggregateUserSavedDestination = {
    _count: UserSavedDestinationCountAggregateOutputType | null
    _min: UserSavedDestinationMinAggregateOutputType | null
    _max: UserSavedDestinationMaxAggregateOutputType | null
  }

  export type UserSavedDestinationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    cityId: string | null
    notes: string | null
    savedAt: Date | null
  }

  export type UserSavedDestinationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    cityId: string | null
    notes: string | null
    savedAt: Date | null
  }

  export type UserSavedDestinationCountAggregateOutputType = {
    id: number
    userId: number
    cityId: number
    notes: number
    savedAt: number
    _all: number
  }


  export type UserSavedDestinationMinAggregateInputType = {
    id?: true
    userId?: true
    cityId?: true
    notes?: true
    savedAt?: true
  }

  export type UserSavedDestinationMaxAggregateInputType = {
    id?: true
    userId?: true
    cityId?: true
    notes?: true
    savedAt?: true
  }

  export type UserSavedDestinationCountAggregateInputType = {
    id?: true
    userId?: true
    cityId?: true
    notes?: true
    savedAt?: true
    _all?: true
  }

  export type UserSavedDestinationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSavedDestination to aggregate.
     */
    where?: UserSavedDestinationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSavedDestinations to fetch.
     */
    orderBy?: UserSavedDestinationOrderByWithRelationInput | UserSavedDestinationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserSavedDestinationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSavedDestinations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSavedDestinations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserSavedDestinations
    **/
    _count?: true | UserSavedDestinationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserSavedDestinationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserSavedDestinationMaxAggregateInputType
  }

  export type GetUserSavedDestinationAggregateType<T extends UserSavedDestinationAggregateArgs> = {
        [P in keyof T & keyof AggregateUserSavedDestination]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserSavedDestination[P]>
      : GetScalarType<T[P], AggregateUserSavedDestination[P]>
  }




  export type UserSavedDestinationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSavedDestinationWhereInput
    orderBy?: UserSavedDestinationOrderByWithAggregationInput | UserSavedDestinationOrderByWithAggregationInput[]
    by: UserSavedDestinationScalarFieldEnum[] | UserSavedDestinationScalarFieldEnum
    having?: UserSavedDestinationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserSavedDestinationCountAggregateInputType | true
    _min?: UserSavedDestinationMinAggregateInputType
    _max?: UserSavedDestinationMaxAggregateInputType
  }

  export type UserSavedDestinationGroupByOutputType = {
    id: string
    userId: string
    cityId: string
    notes: string | null
    savedAt: Date
    _count: UserSavedDestinationCountAggregateOutputType | null
    _min: UserSavedDestinationMinAggregateOutputType | null
    _max: UserSavedDestinationMaxAggregateOutputType | null
  }

  type GetUserSavedDestinationGroupByPayload<T extends UserSavedDestinationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserSavedDestinationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserSavedDestinationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserSavedDestinationGroupByOutputType[P]>
            : GetScalarType<T[P], UserSavedDestinationGroupByOutputType[P]>
        }
      >
    >


  export type UserSavedDestinationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    cityId?: boolean
    notes?: boolean
    savedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    city?: boolean | CityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSavedDestination"]>

  export type UserSavedDestinationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    cityId?: boolean
    notes?: boolean
    savedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    city?: boolean | CityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSavedDestination"]>

  export type UserSavedDestinationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    cityId?: boolean
    notes?: boolean
    savedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    city?: boolean | CityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSavedDestination"]>

  export type UserSavedDestinationSelectScalar = {
    id?: boolean
    userId?: boolean
    cityId?: boolean
    notes?: boolean
    savedAt?: boolean
  }

  export type UserSavedDestinationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "cityId" | "notes" | "savedAt", ExtArgs["result"]["userSavedDestination"]>
  export type UserSavedDestinationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    city?: boolean | CityDefaultArgs<ExtArgs>
  }
  export type UserSavedDestinationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    city?: boolean | CityDefaultArgs<ExtArgs>
  }
  export type UserSavedDestinationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    city?: boolean | CityDefaultArgs<ExtArgs>
  }

  export type $UserSavedDestinationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserSavedDestination"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      city: Prisma.$CityPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      cityId: string
      notes: string | null
      savedAt: Date
    }, ExtArgs["result"]["userSavedDestination"]>
    composites: {}
  }

  type UserSavedDestinationGetPayload<S extends boolean | null | undefined | UserSavedDestinationDefaultArgs> = $Result.GetResult<Prisma.$UserSavedDestinationPayload, S>

  type UserSavedDestinationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserSavedDestinationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserSavedDestinationCountAggregateInputType | true
    }

  export interface UserSavedDestinationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserSavedDestination'], meta: { name: 'UserSavedDestination' } }
    /**
     * Find zero or one UserSavedDestination that matches the filter.
     * @param {UserSavedDestinationFindUniqueArgs} args - Arguments to find a UserSavedDestination
     * @example
     * // Get one UserSavedDestination
     * const userSavedDestination = await prisma.userSavedDestination.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserSavedDestinationFindUniqueArgs>(args: SelectSubset<T, UserSavedDestinationFindUniqueArgs<ExtArgs>>): Prisma__UserSavedDestinationClient<$Result.GetResult<Prisma.$UserSavedDestinationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserSavedDestination that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserSavedDestinationFindUniqueOrThrowArgs} args - Arguments to find a UserSavedDestination
     * @example
     * // Get one UserSavedDestination
     * const userSavedDestination = await prisma.userSavedDestination.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserSavedDestinationFindUniqueOrThrowArgs>(args: SelectSubset<T, UserSavedDestinationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserSavedDestinationClient<$Result.GetResult<Prisma.$UserSavedDestinationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSavedDestination that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSavedDestinationFindFirstArgs} args - Arguments to find a UserSavedDestination
     * @example
     * // Get one UserSavedDestination
     * const userSavedDestination = await prisma.userSavedDestination.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserSavedDestinationFindFirstArgs>(args?: SelectSubset<T, UserSavedDestinationFindFirstArgs<ExtArgs>>): Prisma__UserSavedDestinationClient<$Result.GetResult<Prisma.$UserSavedDestinationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSavedDestination that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSavedDestinationFindFirstOrThrowArgs} args - Arguments to find a UserSavedDestination
     * @example
     * // Get one UserSavedDestination
     * const userSavedDestination = await prisma.userSavedDestination.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserSavedDestinationFindFirstOrThrowArgs>(args?: SelectSubset<T, UserSavedDestinationFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserSavedDestinationClient<$Result.GetResult<Prisma.$UserSavedDestinationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserSavedDestinations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSavedDestinationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserSavedDestinations
     * const userSavedDestinations = await prisma.userSavedDestination.findMany()
     * 
     * // Get first 10 UserSavedDestinations
     * const userSavedDestinations = await prisma.userSavedDestination.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userSavedDestinationWithIdOnly = await prisma.userSavedDestination.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserSavedDestinationFindManyArgs>(args?: SelectSubset<T, UserSavedDestinationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSavedDestinationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserSavedDestination.
     * @param {UserSavedDestinationCreateArgs} args - Arguments to create a UserSavedDestination.
     * @example
     * // Create one UserSavedDestination
     * const UserSavedDestination = await prisma.userSavedDestination.create({
     *   data: {
     *     // ... data to create a UserSavedDestination
     *   }
     * })
     * 
     */
    create<T extends UserSavedDestinationCreateArgs>(args: SelectSubset<T, UserSavedDestinationCreateArgs<ExtArgs>>): Prisma__UserSavedDestinationClient<$Result.GetResult<Prisma.$UserSavedDestinationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserSavedDestinations.
     * @param {UserSavedDestinationCreateManyArgs} args - Arguments to create many UserSavedDestinations.
     * @example
     * // Create many UserSavedDestinations
     * const userSavedDestination = await prisma.userSavedDestination.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserSavedDestinationCreateManyArgs>(args?: SelectSubset<T, UserSavedDestinationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserSavedDestinations and returns the data saved in the database.
     * @param {UserSavedDestinationCreateManyAndReturnArgs} args - Arguments to create many UserSavedDestinations.
     * @example
     * // Create many UserSavedDestinations
     * const userSavedDestination = await prisma.userSavedDestination.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserSavedDestinations and only return the `id`
     * const userSavedDestinationWithIdOnly = await prisma.userSavedDestination.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserSavedDestinationCreateManyAndReturnArgs>(args?: SelectSubset<T, UserSavedDestinationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSavedDestinationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserSavedDestination.
     * @param {UserSavedDestinationDeleteArgs} args - Arguments to delete one UserSavedDestination.
     * @example
     * // Delete one UserSavedDestination
     * const UserSavedDestination = await prisma.userSavedDestination.delete({
     *   where: {
     *     // ... filter to delete one UserSavedDestination
     *   }
     * })
     * 
     */
    delete<T extends UserSavedDestinationDeleteArgs>(args: SelectSubset<T, UserSavedDestinationDeleteArgs<ExtArgs>>): Prisma__UserSavedDestinationClient<$Result.GetResult<Prisma.$UserSavedDestinationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserSavedDestination.
     * @param {UserSavedDestinationUpdateArgs} args - Arguments to update one UserSavedDestination.
     * @example
     * // Update one UserSavedDestination
     * const userSavedDestination = await prisma.userSavedDestination.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserSavedDestinationUpdateArgs>(args: SelectSubset<T, UserSavedDestinationUpdateArgs<ExtArgs>>): Prisma__UserSavedDestinationClient<$Result.GetResult<Prisma.$UserSavedDestinationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserSavedDestinations.
     * @param {UserSavedDestinationDeleteManyArgs} args - Arguments to filter UserSavedDestinations to delete.
     * @example
     * // Delete a few UserSavedDestinations
     * const { count } = await prisma.userSavedDestination.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserSavedDestinationDeleteManyArgs>(args?: SelectSubset<T, UserSavedDestinationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSavedDestinations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSavedDestinationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserSavedDestinations
     * const userSavedDestination = await prisma.userSavedDestination.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserSavedDestinationUpdateManyArgs>(args: SelectSubset<T, UserSavedDestinationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSavedDestinations and returns the data updated in the database.
     * @param {UserSavedDestinationUpdateManyAndReturnArgs} args - Arguments to update many UserSavedDestinations.
     * @example
     * // Update many UserSavedDestinations
     * const userSavedDestination = await prisma.userSavedDestination.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserSavedDestinations and only return the `id`
     * const userSavedDestinationWithIdOnly = await prisma.userSavedDestination.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserSavedDestinationUpdateManyAndReturnArgs>(args: SelectSubset<T, UserSavedDestinationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSavedDestinationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserSavedDestination.
     * @param {UserSavedDestinationUpsertArgs} args - Arguments to update or create a UserSavedDestination.
     * @example
     * // Update or create a UserSavedDestination
     * const userSavedDestination = await prisma.userSavedDestination.upsert({
     *   create: {
     *     // ... data to create a UserSavedDestination
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserSavedDestination we want to update
     *   }
     * })
     */
    upsert<T extends UserSavedDestinationUpsertArgs>(args: SelectSubset<T, UserSavedDestinationUpsertArgs<ExtArgs>>): Prisma__UserSavedDestinationClient<$Result.GetResult<Prisma.$UserSavedDestinationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserSavedDestinations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSavedDestinationCountArgs} args - Arguments to filter UserSavedDestinations to count.
     * @example
     * // Count the number of UserSavedDestinations
     * const count = await prisma.userSavedDestination.count({
     *   where: {
     *     // ... the filter for the UserSavedDestinations we want to count
     *   }
     * })
    **/
    count<T extends UserSavedDestinationCountArgs>(
      args?: Subset<T, UserSavedDestinationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserSavedDestinationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserSavedDestination.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSavedDestinationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserSavedDestinationAggregateArgs>(args: Subset<T, UserSavedDestinationAggregateArgs>): Prisma.PrismaPromise<GetUserSavedDestinationAggregateType<T>>

    /**
     * Group by UserSavedDestination.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSavedDestinationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserSavedDestinationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserSavedDestinationGroupByArgs['orderBy'] }
        : { orderBy?: UserSavedDestinationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserSavedDestinationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserSavedDestinationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserSavedDestination model
   */
  readonly fields: UserSavedDestinationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserSavedDestination.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserSavedDestinationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    city<T extends CityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CityDefaultArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserSavedDestination model
   */
  interface UserSavedDestinationFieldRefs {
    readonly id: FieldRef<"UserSavedDestination", 'String'>
    readonly userId: FieldRef<"UserSavedDestination", 'String'>
    readonly cityId: FieldRef<"UserSavedDestination", 'String'>
    readonly notes: FieldRef<"UserSavedDestination", 'String'>
    readonly savedAt: FieldRef<"UserSavedDestination", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserSavedDestination findUnique
   */
  export type UserSavedDestinationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSavedDestination
     */
    select?: UserSavedDestinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSavedDestination
     */
    omit?: UserSavedDestinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSavedDestinationInclude<ExtArgs> | null
    /**
     * Filter, which UserSavedDestination to fetch.
     */
    where: UserSavedDestinationWhereUniqueInput
  }

  /**
   * UserSavedDestination findUniqueOrThrow
   */
  export type UserSavedDestinationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSavedDestination
     */
    select?: UserSavedDestinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSavedDestination
     */
    omit?: UserSavedDestinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSavedDestinationInclude<ExtArgs> | null
    /**
     * Filter, which UserSavedDestination to fetch.
     */
    where: UserSavedDestinationWhereUniqueInput
  }

  /**
   * UserSavedDestination findFirst
   */
  export type UserSavedDestinationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSavedDestination
     */
    select?: UserSavedDestinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSavedDestination
     */
    omit?: UserSavedDestinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSavedDestinationInclude<ExtArgs> | null
    /**
     * Filter, which UserSavedDestination to fetch.
     */
    where?: UserSavedDestinationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSavedDestinations to fetch.
     */
    orderBy?: UserSavedDestinationOrderByWithRelationInput | UserSavedDestinationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSavedDestinations.
     */
    cursor?: UserSavedDestinationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSavedDestinations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSavedDestinations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSavedDestinations.
     */
    distinct?: UserSavedDestinationScalarFieldEnum | UserSavedDestinationScalarFieldEnum[]
  }

  /**
   * UserSavedDestination findFirstOrThrow
   */
  export type UserSavedDestinationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSavedDestination
     */
    select?: UserSavedDestinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSavedDestination
     */
    omit?: UserSavedDestinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSavedDestinationInclude<ExtArgs> | null
    /**
     * Filter, which UserSavedDestination to fetch.
     */
    where?: UserSavedDestinationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSavedDestinations to fetch.
     */
    orderBy?: UserSavedDestinationOrderByWithRelationInput | UserSavedDestinationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSavedDestinations.
     */
    cursor?: UserSavedDestinationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSavedDestinations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSavedDestinations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSavedDestinations.
     */
    distinct?: UserSavedDestinationScalarFieldEnum | UserSavedDestinationScalarFieldEnum[]
  }

  /**
   * UserSavedDestination findMany
   */
  export type UserSavedDestinationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSavedDestination
     */
    select?: UserSavedDestinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSavedDestination
     */
    omit?: UserSavedDestinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSavedDestinationInclude<ExtArgs> | null
    /**
     * Filter, which UserSavedDestinations to fetch.
     */
    where?: UserSavedDestinationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSavedDestinations to fetch.
     */
    orderBy?: UserSavedDestinationOrderByWithRelationInput | UserSavedDestinationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserSavedDestinations.
     */
    cursor?: UserSavedDestinationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSavedDestinations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSavedDestinations.
     */
    skip?: number
    distinct?: UserSavedDestinationScalarFieldEnum | UserSavedDestinationScalarFieldEnum[]
  }

  /**
   * UserSavedDestination create
   */
  export type UserSavedDestinationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSavedDestination
     */
    select?: UserSavedDestinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSavedDestination
     */
    omit?: UserSavedDestinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSavedDestinationInclude<ExtArgs> | null
    /**
     * The data needed to create a UserSavedDestination.
     */
    data: XOR<UserSavedDestinationCreateInput, UserSavedDestinationUncheckedCreateInput>
  }

  /**
   * UserSavedDestination createMany
   */
  export type UserSavedDestinationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserSavedDestinations.
     */
    data: UserSavedDestinationCreateManyInput | UserSavedDestinationCreateManyInput[]
  }

  /**
   * UserSavedDestination createManyAndReturn
   */
  export type UserSavedDestinationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSavedDestination
     */
    select?: UserSavedDestinationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSavedDestination
     */
    omit?: UserSavedDestinationOmit<ExtArgs> | null
    /**
     * The data used to create many UserSavedDestinations.
     */
    data: UserSavedDestinationCreateManyInput | UserSavedDestinationCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSavedDestinationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSavedDestination update
   */
  export type UserSavedDestinationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSavedDestination
     */
    select?: UserSavedDestinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSavedDestination
     */
    omit?: UserSavedDestinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSavedDestinationInclude<ExtArgs> | null
    /**
     * The data needed to update a UserSavedDestination.
     */
    data: XOR<UserSavedDestinationUpdateInput, UserSavedDestinationUncheckedUpdateInput>
    /**
     * Choose, which UserSavedDestination to update.
     */
    where: UserSavedDestinationWhereUniqueInput
  }

  /**
   * UserSavedDestination updateMany
   */
  export type UserSavedDestinationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserSavedDestinations.
     */
    data: XOR<UserSavedDestinationUpdateManyMutationInput, UserSavedDestinationUncheckedUpdateManyInput>
    /**
     * Filter which UserSavedDestinations to update
     */
    where?: UserSavedDestinationWhereInput
    /**
     * Limit how many UserSavedDestinations to update.
     */
    limit?: number
  }

  /**
   * UserSavedDestination updateManyAndReturn
   */
  export type UserSavedDestinationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSavedDestination
     */
    select?: UserSavedDestinationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSavedDestination
     */
    omit?: UserSavedDestinationOmit<ExtArgs> | null
    /**
     * The data used to update UserSavedDestinations.
     */
    data: XOR<UserSavedDestinationUpdateManyMutationInput, UserSavedDestinationUncheckedUpdateManyInput>
    /**
     * Filter which UserSavedDestinations to update
     */
    where?: UserSavedDestinationWhereInput
    /**
     * Limit how many UserSavedDestinations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSavedDestinationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSavedDestination upsert
   */
  export type UserSavedDestinationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSavedDestination
     */
    select?: UserSavedDestinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSavedDestination
     */
    omit?: UserSavedDestinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSavedDestinationInclude<ExtArgs> | null
    /**
     * The filter to search for the UserSavedDestination to update in case it exists.
     */
    where: UserSavedDestinationWhereUniqueInput
    /**
     * In case the UserSavedDestination found by the `where` argument doesn't exist, create a new UserSavedDestination with this data.
     */
    create: XOR<UserSavedDestinationCreateInput, UserSavedDestinationUncheckedCreateInput>
    /**
     * In case the UserSavedDestination was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserSavedDestinationUpdateInput, UserSavedDestinationUncheckedUpdateInput>
  }

  /**
   * UserSavedDestination delete
   */
  export type UserSavedDestinationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSavedDestination
     */
    select?: UserSavedDestinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSavedDestination
     */
    omit?: UserSavedDestinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSavedDestinationInclude<ExtArgs> | null
    /**
     * Filter which UserSavedDestination to delete.
     */
    where: UserSavedDestinationWhereUniqueInput
  }

  /**
   * UserSavedDestination deleteMany
   */
  export type UserSavedDestinationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSavedDestinations to delete
     */
    where?: UserSavedDestinationWhereInput
    /**
     * Limit how many UserSavedDestinations to delete.
     */
    limit?: number
  }

  /**
   * UserSavedDestination without action
   */
  export type UserSavedDestinationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSavedDestination
     */
    select?: UserSavedDestinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSavedDestination
     */
    omit?: UserSavedDestinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSavedDestinationInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    entityType: string | null
    entityId: string | null
    changes: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    entityType: string | null
    entityId: string | null
    changes: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    userId: number
    action: number
    entityType: number
    entityId: number
    changes: number
    ipAddress: number
    userAgent: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entityType?: true
    entityId?: true
    changes?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entityType?: true
    entityId?: true
    changes?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entityType?: true
    entityId?: true
    changes?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    userId: string | null
    action: string
    entityType: string
    entityId: string
    changes: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    changes?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    changes?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    changes?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    userId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    changes?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
  }

  export type AuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "action" | "entityType" | "entityId" | "changes" | "ipAddress" | "userAgent" | "createdAt", ExtArgs["result"]["auditLog"]>
  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }
  export type AuditLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      action: string
      entityType: string
      entityId: string
      changes: string | null
      ipAddress: string | null
      userAgent: string | null
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs and returns the data updated in the database.
     * @param {AuditLogUpdateManyAndReturnArgs} args - Arguments to update many AuditLogs.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends AuditLog$userArgs<ExtArgs> = {}>(args?: Subset<T, AuditLog$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly userId: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly entityType: FieldRef<"AuditLog", 'String'>
    readonly entityId: FieldRef<"AuditLog", 'String'>
    readonly changes: FieldRef<"AuditLog", 'String'>
    readonly ipAddress: FieldRef<"AuditLog", 'String'>
    readonly userAgent: FieldRef<"AuditLog", 'String'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog updateManyAndReturn
   */
  export type AuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number
  }

  /**
   * AuditLog.user
   */
  export type AuditLog$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model Weather
   */

  export type AggregateWeather = {
    _count: WeatherCountAggregateOutputType | null
    _min: WeatherMinAggregateOutputType | null
    _max: WeatherMaxAggregateOutputType | null
  }

  export type WeatherMinAggregateOutputType = {
    id: string | null
    cityId: string | null
    city: string | null
    date: string | null
    current: string | null
    forecast: string | null
    hourlyForecast: string | null
    recommendation: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WeatherMaxAggregateOutputType = {
    id: string | null
    cityId: string | null
    city: string | null
    date: string | null
    current: string | null
    forecast: string | null
    hourlyForecast: string | null
    recommendation: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WeatherCountAggregateOutputType = {
    id: number
    cityId: number
    city: number
    date: number
    current: number
    forecast: number
    hourlyForecast: number
    recommendation: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WeatherMinAggregateInputType = {
    id?: true
    cityId?: true
    city?: true
    date?: true
    current?: true
    forecast?: true
    hourlyForecast?: true
    recommendation?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WeatherMaxAggregateInputType = {
    id?: true
    cityId?: true
    city?: true
    date?: true
    current?: true
    forecast?: true
    hourlyForecast?: true
    recommendation?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WeatherCountAggregateInputType = {
    id?: true
    cityId?: true
    city?: true
    date?: true
    current?: true
    forecast?: true
    hourlyForecast?: true
    recommendation?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WeatherAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Weather to aggregate.
     */
    where?: WeatherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Weathers to fetch.
     */
    orderBy?: WeatherOrderByWithRelationInput | WeatherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WeatherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Weathers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Weathers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Weathers
    **/
    _count?: true | WeatherCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WeatherMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WeatherMaxAggregateInputType
  }

  export type GetWeatherAggregateType<T extends WeatherAggregateArgs> = {
        [P in keyof T & keyof AggregateWeather]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWeather[P]>
      : GetScalarType<T[P], AggregateWeather[P]>
  }




  export type WeatherGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WeatherWhereInput
    orderBy?: WeatherOrderByWithAggregationInput | WeatherOrderByWithAggregationInput[]
    by: WeatherScalarFieldEnum[] | WeatherScalarFieldEnum
    having?: WeatherScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WeatherCountAggregateInputType | true
    _min?: WeatherMinAggregateInputType
    _max?: WeatherMaxAggregateInputType
  }

  export type WeatherGroupByOutputType = {
    id: string
    cityId: string | null
    city: string
    date: string
    current: string
    forecast: string
    hourlyForecast: string
    recommendation: string | null
    createdAt: Date
    updatedAt: Date
    _count: WeatherCountAggregateOutputType | null
    _min: WeatherMinAggregateOutputType | null
    _max: WeatherMaxAggregateOutputType | null
  }

  type GetWeatherGroupByPayload<T extends WeatherGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WeatherGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WeatherGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WeatherGroupByOutputType[P]>
            : GetScalarType<T[P], WeatherGroupByOutputType[P]>
        }
      >
    >


  export type WeatherSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cityId?: boolean
    city?: boolean
    date?: boolean
    current?: boolean
    forecast?: boolean
    hourlyForecast?: boolean
    recommendation?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["weather"]>

  export type WeatherSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cityId?: boolean
    city?: boolean
    date?: boolean
    current?: boolean
    forecast?: boolean
    hourlyForecast?: boolean
    recommendation?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["weather"]>

  export type WeatherSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cityId?: boolean
    city?: boolean
    date?: boolean
    current?: boolean
    forecast?: boolean
    hourlyForecast?: boolean
    recommendation?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["weather"]>

  export type WeatherSelectScalar = {
    id?: boolean
    cityId?: boolean
    city?: boolean
    date?: boolean
    current?: boolean
    forecast?: boolean
    hourlyForecast?: boolean
    recommendation?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WeatherOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cityId" | "city" | "date" | "current" | "forecast" | "hourlyForecast" | "recommendation" | "createdAt" | "updatedAt", ExtArgs["result"]["weather"]>

  export type $WeatherPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Weather"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      cityId: string | null
      city: string
      date: string
      current: string
      forecast: string
      hourlyForecast: string
      recommendation: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["weather"]>
    composites: {}
  }

  type WeatherGetPayload<S extends boolean | null | undefined | WeatherDefaultArgs> = $Result.GetResult<Prisma.$WeatherPayload, S>

  type WeatherCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WeatherFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WeatherCountAggregateInputType | true
    }

  export interface WeatherDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Weather'], meta: { name: 'Weather' } }
    /**
     * Find zero or one Weather that matches the filter.
     * @param {WeatherFindUniqueArgs} args - Arguments to find a Weather
     * @example
     * // Get one Weather
     * const weather = await prisma.weather.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WeatherFindUniqueArgs>(args: SelectSubset<T, WeatherFindUniqueArgs<ExtArgs>>): Prisma__WeatherClient<$Result.GetResult<Prisma.$WeatherPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Weather that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WeatherFindUniqueOrThrowArgs} args - Arguments to find a Weather
     * @example
     * // Get one Weather
     * const weather = await prisma.weather.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WeatherFindUniqueOrThrowArgs>(args: SelectSubset<T, WeatherFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WeatherClient<$Result.GetResult<Prisma.$WeatherPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Weather that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherFindFirstArgs} args - Arguments to find a Weather
     * @example
     * // Get one Weather
     * const weather = await prisma.weather.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WeatherFindFirstArgs>(args?: SelectSubset<T, WeatherFindFirstArgs<ExtArgs>>): Prisma__WeatherClient<$Result.GetResult<Prisma.$WeatherPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Weather that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherFindFirstOrThrowArgs} args - Arguments to find a Weather
     * @example
     * // Get one Weather
     * const weather = await prisma.weather.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WeatherFindFirstOrThrowArgs>(args?: SelectSubset<T, WeatherFindFirstOrThrowArgs<ExtArgs>>): Prisma__WeatherClient<$Result.GetResult<Prisma.$WeatherPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Weathers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Weathers
     * const weathers = await prisma.weather.findMany()
     * 
     * // Get first 10 Weathers
     * const weathers = await prisma.weather.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const weatherWithIdOnly = await prisma.weather.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WeatherFindManyArgs>(args?: SelectSubset<T, WeatherFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeatherPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Weather.
     * @param {WeatherCreateArgs} args - Arguments to create a Weather.
     * @example
     * // Create one Weather
     * const Weather = await prisma.weather.create({
     *   data: {
     *     // ... data to create a Weather
     *   }
     * })
     * 
     */
    create<T extends WeatherCreateArgs>(args: SelectSubset<T, WeatherCreateArgs<ExtArgs>>): Prisma__WeatherClient<$Result.GetResult<Prisma.$WeatherPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Weathers.
     * @param {WeatherCreateManyArgs} args - Arguments to create many Weathers.
     * @example
     * // Create many Weathers
     * const weather = await prisma.weather.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WeatherCreateManyArgs>(args?: SelectSubset<T, WeatherCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Weathers and returns the data saved in the database.
     * @param {WeatherCreateManyAndReturnArgs} args - Arguments to create many Weathers.
     * @example
     * // Create many Weathers
     * const weather = await prisma.weather.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Weathers and only return the `id`
     * const weatherWithIdOnly = await prisma.weather.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WeatherCreateManyAndReturnArgs>(args?: SelectSubset<T, WeatherCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeatherPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Weather.
     * @param {WeatherDeleteArgs} args - Arguments to delete one Weather.
     * @example
     * // Delete one Weather
     * const Weather = await prisma.weather.delete({
     *   where: {
     *     // ... filter to delete one Weather
     *   }
     * })
     * 
     */
    delete<T extends WeatherDeleteArgs>(args: SelectSubset<T, WeatherDeleteArgs<ExtArgs>>): Prisma__WeatherClient<$Result.GetResult<Prisma.$WeatherPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Weather.
     * @param {WeatherUpdateArgs} args - Arguments to update one Weather.
     * @example
     * // Update one Weather
     * const weather = await prisma.weather.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WeatherUpdateArgs>(args: SelectSubset<T, WeatherUpdateArgs<ExtArgs>>): Prisma__WeatherClient<$Result.GetResult<Prisma.$WeatherPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Weathers.
     * @param {WeatherDeleteManyArgs} args - Arguments to filter Weathers to delete.
     * @example
     * // Delete a few Weathers
     * const { count } = await prisma.weather.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WeatherDeleteManyArgs>(args?: SelectSubset<T, WeatherDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Weathers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Weathers
     * const weather = await prisma.weather.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WeatherUpdateManyArgs>(args: SelectSubset<T, WeatherUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Weathers and returns the data updated in the database.
     * @param {WeatherUpdateManyAndReturnArgs} args - Arguments to update many Weathers.
     * @example
     * // Update many Weathers
     * const weather = await prisma.weather.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Weathers and only return the `id`
     * const weatherWithIdOnly = await prisma.weather.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WeatherUpdateManyAndReturnArgs>(args: SelectSubset<T, WeatherUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeatherPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Weather.
     * @param {WeatherUpsertArgs} args - Arguments to update or create a Weather.
     * @example
     * // Update or create a Weather
     * const weather = await prisma.weather.upsert({
     *   create: {
     *     // ... data to create a Weather
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Weather we want to update
     *   }
     * })
     */
    upsert<T extends WeatherUpsertArgs>(args: SelectSubset<T, WeatherUpsertArgs<ExtArgs>>): Prisma__WeatherClient<$Result.GetResult<Prisma.$WeatherPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Weathers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherCountArgs} args - Arguments to filter Weathers to count.
     * @example
     * // Count the number of Weathers
     * const count = await prisma.weather.count({
     *   where: {
     *     // ... the filter for the Weathers we want to count
     *   }
     * })
    **/
    count<T extends WeatherCountArgs>(
      args?: Subset<T, WeatherCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WeatherCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Weather.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WeatherAggregateArgs>(args: Subset<T, WeatherAggregateArgs>): Prisma.PrismaPromise<GetWeatherAggregateType<T>>

    /**
     * Group by Weather.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeatherGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WeatherGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WeatherGroupByArgs['orderBy'] }
        : { orderBy?: WeatherGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WeatherGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWeatherGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Weather model
   */
  readonly fields: WeatherFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Weather.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WeatherClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Weather model
   */
  interface WeatherFieldRefs {
    readonly id: FieldRef<"Weather", 'String'>
    readonly cityId: FieldRef<"Weather", 'String'>
    readonly city: FieldRef<"Weather", 'String'>
    readonly date: FieldRef<"Weather", 'String'>
    readonly current: FieldRef<"Weather", 'String'>
    readonly forecast: FieldRef<"Weather", 'String'>
    readonly hourlyForecast: FieldRef<"Weather", 'String'>
    readonly recommendation: FieldRef<"Weather", 'String'>
    readonly createdAt: FieldRef<"Weather", 'DateTime'>
    readonly updatedAt: FieldRef<"Weather", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Weather findUnique
   */
  export type WeatherFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weather
     */
    select?: WeatherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weather
     */
    omit?: WeatherOmit<ExtArgs> | null
    /**
     * Filter, which Weather to fetch.
     */
    where: WeatherWhereUniqueInput
  }

  /**
   * Weather findUniqueOrThrow
   */
  export type WeatherFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weather
     */
    select?: WeatherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weather
     */
    omit?: WeatherOmit<ExtArgs> | null
    /**
     * Filter, which Weather to fetch.
     */
    where: WeatherWhereUniqueInput
  }

  /**
   * Weather findFirst
   */
  export type WeatherFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weather
     */
    select?: WeatherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weather
     */
    omit?: WeatherOmit<ExtArgs> | null
    /**
     * Filter, which Weather to fetch.
     */
    where?: WeatherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Weathers to fetch.
     */
    orderBy?: WeatherOrderByWithRelationInput | WeatherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Weathers.
     */
    cursor?: WeatherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Weathers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Weathers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Weathers.
     */
    distinct?: WeatherScalarFieldEnum | WeatherScalarFieldEnum[]
  }

  /**
   * Weather findFirstOrThrow
   */
  export type WeatherFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weather
     */
    select?: WeatherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weather
     */
    omit?: WeatherOmit<ExtArgs> | null
    /**
     * Filter, which Weather to fetch.
     */
    where?: WeatherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Weathers to fetch.
     */
    orderBy?: WeatherOrderByWithRelationInput | WeatherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Weathers.
     */
    cursor?: WeatherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Weathers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Weathers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Weathers.
     */
    distinct?: WeatherScalarFieldEnum | WeatherScalarFieldEnum[]
  }

  /**
   * Weather findMany
   */
  export type WeatherFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weather
     */
    select?: WeatherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weather
     */
    omit?: WeatherOmit<ExtArgs> | null
    /**
     * Filter, which Weathers to fetch.
     */
    where?: WeatherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Weathers to fetch.
     */
    orderBy?: WeatherOrderByWithRelationInput | WeatherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Weathers.
     */
    cursor?: WeatherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Weathers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Weathers.
     */
    skip?: number
    distinct?: WeatherScalarFieldEnum | WeatherScalarFieldEnum[]
  }

  /**
   * Weather create
   */
  export type WeatherCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weather
     */
    select?: WeatherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weather
     */
    omit?: WeatherOmit<ExtArgs> | null
    /**
     * The data needed to create a Weather.
     */
    data: XOR<WeatherCreateInput, WeatherUncheckedCreateInput>
  }

  /**
   * Weather createMany
   */
  export type WeatherCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Weathers.
     */
    data: WeatherCreateManyInput | WeatherCreateManyInput[]
  }

  /**
   * Weather createManyAndReturn
   */
  export type WeatherCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weather
     */
    select?: WeatherSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Weather
     */
    omit?: WeatherOmit<ExtArgs> | null
    /**
     * The data used to create many Weathers.
     */
    data: WeatherCreateManyInput | WeatherCreateManyInput[]
  }

  /**
   * Weather update
   */
  export type WeatherUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weather
     */
    select?: WeatherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weather
     */
    omit?: WeatherOmit<ExtArgs> | null
    /**
     * The data needed to update a Weather.
     */
    data: XOR<WeatherUpdateInput, WeatherUncheckedUpdateInput>
    /**
     * Choose, which Weather to update.
     */
    where: WeatherWhereUniqueInput
  }

  /**
   * Weather updateMany
   */
  export type WeatherUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Weathers.
     */
    data: XOR<WeatherUpdateManyMutationInput, WeatherUncheckedUpdateManyInput>
    /**
     * Filter which Weathers to update
     */
    where?: WeatherWhereInput
    /**
     * Limit how many Weathers to update.
     */
    limit?: number
  }

  /**
   * Weather updateManyAndReturn
   */
  export type WeatherUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weather
     */
    select?: WeatherSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Weather
     */
    omit?: WeatherOmit<ExtArgs> | null
    /**
     * The data used to update Weathers.
     */
    data: XOR<WeatherUpdateManyMutationInput, WeatherUncheckedUpdateManyInput>
    /**
     * Filter which Weathers to update
     */
    where?: WeatherWhereInput
    /**
     * Limit how many Weathers to update.
     */
    limit?: number
  }

  /**
   * Weather upsert
   */
  export type WeatherUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weather
     */
    select?: WeatherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weather
     */
    omit?: WeatherOmit<ExtArgs> | null
    /**
     * The filter to search for the Weather to update in case it exists.
     */
    where: WeatherWhereUniqueInput
    /**
     * In case the Weather found by the `where` argument doesn't exist, create a new Weather with this data.
     */
    create: XOR<WeatherCreateInput, WeatherUncheckedCreateInput>
    /**
     * In case the Weather was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WeatherUpdateInput, WeatherUncheckedUpdateInput>
  }

  /**
   * Weather delete
   */
  export type WeatherDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weather
     */
    select?: WeatherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weather
     */
    omit?: WeatherOmit<ExtArgs> | null
    /**
     * Filter which Weather to delete.
     */
    where: WeatherWhereUniqueInput
  }

  /**
   * Weather deleteMany
   */
  export type WeatherDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Weathers to delete
     */
    where?: WeatherWhereInput
    /**
     * Limit how many Weathers to delete.
     */
    limit?: number
  }

  /**
   * Weather without action
   */
  export type WeatherDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weather
     */
    select?: WeatherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weather
     */
    omit?: WeatherOmit<ExtArgs> | null
  }


  /**
   * Model Guide
   */

  export type AggregateGuide = {
    _count: GuideCountAggregateOutputType | null
    _avg: GuideAvgAggregateOutputType | null
    _sum: GuideSumAggregateOutputType | null
    _min: GuideMinAggregateOutputType | null
    _max: GuideMaxAggregateOutputType | null
  }

  export type GuideAvgAggregateOutputType = {
    yearsOfExperience: number | null
    rating: number | null
    reviews: number | null
  }

  export type GuideSumAggregateOutputType = {
    yearsOfExperience: number | null
    rating: number | null
    reviews: number | null
  }

  export type GuideMinAggregateOutputType = {
    id: string | null
    cityId: string | null
    name: string | null
    specialization: string | null
    city: string | null
    languages: string | null
    certification: string | null
    yearsOfExperience: number | null
    rating: number | null
    reviews: number | null
    pricePerDay: string | null
    availability: string | null
    groupSize: string | null
    skills: string | null
    tours: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GuideMaxAggregateOutputType = {
    id: string | null
    cityId: string | null
    name: string | null
    specialization: string | null
    city: string | null
    languages: string | null
    certification: string | null
    yearsOfExperience: number | null
    rating: number | null
    reviews: number | null
    pricePerDay: string | null
    availability: string | null
    groupSize: string | null
    skills: string | null
    tours: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GuideCountAggregateOutputType = {
    id: number
    cityId: number
    name: number
    specialization: number
    city: number
    languages: number
    certification: number
    yearsOfExperience: number
    rating: number
    reviews: number
    pricePerDay: number
    availability: number
    groupSize: number
    skills: number
    tours: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GuideAvgAggregateInputType = {
    yearsOfExperience?: true
    rating?: true
    reviews?: true
  }

  export type GuideSumAggregateInputType = {
    yearsOfExperience?: true
    rating?: true
    reviews?: true
  }

  export type GuideMinAggregateInputType = {
    id?: true
    cityId?: true
    name?: true
    specialization?: true
    city?: true
    languages?: true
    certification?: true
    yearsOfExperience?: true
    rating?: true
    reviews?: true
    pricePerDay?: true
    availability?: true
    groupSize?: true
    skills?: true
    tours?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GuideMaxAggregateInputType = {
    id?: true
    cityId?: true
    name?: true
    specialization?: true
    city?: true
    languages?: true
    certification?: true
    yearsOfExperience?: true
    rating?: true
    reviews?: true
    pricePerDay?: true
    availability?: true
    groupSize?: true
    skills?: true
    tours?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GuideCountAggregateInputType = {
    id?: true
    cityId?: true
    name?: true
    specialization?: true
    city?: true
    languages?: true
    certification?: true
    yearsOfExperience?: true
    rating?: true
    reviews?: true
    pricePerDay?: true
    availability?: true
    groupSize?: true
    skills?: true
    tours?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GuideAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Guide to aggregate.
     */
    where?: GuideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Guides to fetch.
     */
    orderBy?: GuideOrderByWithRelationInput | GuideOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GuideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Guides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Guides.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Guides
    **/
    _count?: true | GuideCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GuideAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GuideSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GuideMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GuideMaxAggregateInputType
  }

  export type GetGuideAggregateType<T extends GuideAggregateArgs> = {
        [P in keyof T & keyof AggregateGuide]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGuide[P]>
      : GetScalarType<T[P], AggregateGuide[P]>
  }




  export type GuideGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GuideWhereInput
    orderBy?: GuideOrderByWithAggregationInput | GuideOrderByWithAggregationInput[]
    by: GuideScalarFieldEnum[] | GuideScalarFieldEnum
    having?: GuideScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GuideCountAggregateInputType | true
    _avg?: GuideAvgAggregateInputType
    _sum?: GuideSumAggregateInputType
    _min?: GuideMinAggregateInputType
    _max?: GuideMaxAggregateInputType
  }

  export type GuideGroupByOutputType = {
    id: string
    cityId: string | null
    name: string
    specialization: string
    city: string
    languages: string
    certification: string | null
    yearsOfExperience: number
    rating: number | null
    reviews: number
    pricePerDay: string
    availability: string
    groupSize: string
    skills: string
    tours: string
    createdAt: Date
    updatedAt: Date
    _count: GuideCountAggregateOutputType | null
    _avg: GuideAvgAggregateOutputType | null
    _sum: GuideSumAggregateOutputType | null
    _min: GuideMinAggregateOutputType | null
    _max: GuideMaxAggregateOutputType | null
  }

  type GetGuideGroupByPayload<T extends GuideGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GuideGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GuideGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GuideGroupByOutputType[P]>
            : GetScalarType<T[P], GuideGroupByOutputType[P]>
        }
      >
    >


  export type GuideSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cityId?: boolean
    name?: boolean
    specialization?: boolean
    city?: boolean
    languages?: boolean
    certification?: boolean
    yearsOfExperience?: boolean
    rating?: boolean
    reviews?: boolean
    pricePerDay?: boolean
    availability?: boolean
    groupSize?: boolean
    skills?: boolean
    tours?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["guide"]>

  export type GuideSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cityId?: boolean
    name?: boolean
    specialization?: boolean
    city?: boolean
    languages?: boolean
    certification?: boolean
    yearsOfExperience?: boolean
    rating?: boolean
    reviews?: boolean
    pricePerDay?: boolean
    availability?: boolean
    groupSize?: boolean
    skills?: boolean
    tours?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["guide"]>

  export type GuideSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cityId?: boolean
    name?: boolean
    specialization?: boolean
    city?: boolean
    languages?: boolean
    certification?: boolean
    yearsOfExperience?: boolean
    rating?: boolean
    reviews?: boolean
    pricePerDay?: boolean
    availability?: boolean
    groupSize?: boolean
    skills?: boolean
    tours?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["guide"]>

  export type GuideSelectScalar = {
    id?: boolean
    cityId?: boolean
    name?: boolean
    specialization?: boolean
    city?: boolean
    languages?: boolean
    certification?: boolean
    yearsOfExperience?: boolean
    rating?: boolean
    reviews?: boolean
    pricePerDay?: boolean
    availability?: boolean
    groupSize?: boolean
    skills?: boolean
    tours?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GuideOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cityId" | "name" | "specialization" | "city" | "languages" | "certification" | "yearsOfExperience" | "rating" | "reviews" | "pricePerDay" | "availability" | "groupSize" | "skills" | "tours" | "createdAt" | "updatedAt", ExtArgs["result"]["guide"]>

  export type $GuidePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Guide"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      cityId: string | null
      name: string
      specialization: string
      city: string
      languages: string
      certification: string | null
      yearsOfExperience: number
      rating: number | null
      reviews: number
      pricePerDay: string
      availability: string
      groupSize: string
      skills: string
      tours: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["guide"]>
    composites: {}
  }

  type GuideGetPayload<S extends boolean | null | undefined | GuideDefaultArgs> = $Result.GetResult<Prisma.$GuidePayload, S>

  type GuideCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GuideFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GuideCountAggregateInputType | true
    }

  export interface GuideDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Guide'], meta: { name: 'Guide' } }
    /**
     * Find zero or one Guide that matches the filter.
     * @param {GuideFindUniqueArgs} args - Arguments to find a Guide
     * @example
     * // Get one Guide
     * const guide = await prisma.guide.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GuideFindUniqueArgs>(args: SelectSubset<T, GuideFindUniqueArgs<ExtArgs>>): Prisma__GuideClient<$Result.GetResult<Prisma.$GuidePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Guide that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GuideFindUniqueOrThrowArgs} args - Arguments to find a Guide
     * @example
     * // Get one Guide
     * const guide = await prisma.guide.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GuideFindUniqueOrThrowArgs>(args: SelectSubset<T, GuideFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GuideClient<$Result.GetResult<Prisma.$GuidePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Guide that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuideFindFirstArgs} args - Arguments to find a Guide
     * @example
     * // Get one Guide
     * const guide = await prisma.guide.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GuideFindFirstArgs>(args?: SelectSubset<T, GuideFindFirstArgs<ExtArgs>>): Prisma__GuideClient<$Result.GetResult<Prisma.$GuidePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Guide that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuideFindFirstOrThrowArgs} args - Arguments to find a Guide
     * @example
     * // Get one Guide
     * const guide = await prisma.guide.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GuideFindFirstOrThrowArgs>(args?: SelectSubset<T, GuideFindFirstOrThrowArgs<ExtArgs>>): Prisma__GuideClient<$Result.GetResult<Prisma.$GuidePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Guides that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuideFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Guides
     * const guides = await prisma.guide.findMany()
     * 
     * // Get first 10 Guides
     * const guides = await prisma.guide.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const guideWithIdOnly = await prisma.guide.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GuideFindManyArgs>(args?: SelectSubset<T, GuideFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GuidePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Guide.
     * @param {GuideCreateArgs} args - Arguments to create a Guide.
     * @example
     * // Create one Guide
     * const Guide = await prisma.guide.create({
     *   data: {
     *     // ... data to create a Guide
     *   }
     * })
     * 
     */
    create<T extends GuideCreateArgs>(args: SelectSubset<T, GuideCreateArgs<ExtArgs>>): Prisma__GuideClient<$Result.GetResult<Prisma.$GuidePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Guides.
     * @param {GuideCreateManyArgs} args - Arguments to create many Guides.
     * @example
     * // Create many Guides
     * const guide = await prisma.guide.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GuideCreateManyArgs>(args?: SelectSubset<T, GuideCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Guides and returns the data saved in the database.
     * @param {GuideCreateManyAndReturnArgs} args - Arguments to create many Guides.
     * @example
     * // Create many Guides
     * const guide = await prisma.guide.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Guides and only return the `id`
     * const guideWithIdOnly = await prisma.guide.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GuideCreateManyAndReturnArgs>(args?: SelectSubset<T, GuideCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GuidePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Guide.
     * @param {GuideDeleteArgs} args - Arguments to delete one Guide.
     * @example
     * // Delete one Guide
     * const Guide = await prisma.guide.delete({
     *   where: {
     *     // ... filter to delete one Guide
     *   }
     * })
     * 
     */
    delete<T extends GuideDeleteArgs>(args: SelectSubset<T, GuideDeleteArgs<ExtArgs>>): Prisma__GuideClient<$Result.GetResult<Prisma.$GuidePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Guide.
     * @param {GuideUpdateArgs} args - Arguments to update one Guide.
     * @example
     * // Update one Guide
     * const guide = await prisma.guide.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GuideUpdateArgs>(args: SelectSubset<T, GuideUpdateArgs<ExtArgs>>): Prisma__GuideClient<$Result.GetResult<Prisma.$GuidePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Guides.
     * @param {GuideDeleteManyArgs} args - Arguments to filter Guides to delete.
     * @example
     * // Delete a few Guides
     * const { count } = await prisma.guide.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GuideDeleteManyArgs>(args?: SelectSubset<T, GuideDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Guides.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuideUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Guides
     * const guide = await prisma.guide.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GuideUpdateManyArgs>(args: SelectSubset<T, GuideUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Guides and returns the data updated in the database.
     * @param {GuideUpdateManyAndReturnArgs} args - Arguments to update many Guides.
     * @example
     * // Update many Guides
     * const guide = await prisma.guide.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Guides and only return the `id`
     * const guideWithIdOnly = await prisma.guide.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GuideUpdateManyAndReturnArgs>(args: SelectSubset<T, GuideUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GuidePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Guide.
     * @param {GuideUpsertArgs} args - Arguments to update or create a Guide.
     * @example
     * // Update or create a Guide
     * const guide = await prisma.guide.upsert({
     *   create: {
     *     // ... data to create a Guide
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Guide we want to update
     *   }
     * })
     */
    upsert<T extends GuideUpsertArgs>(args: SelectSubset<T, GuideUpsertArgs<ExtArgs>>): Prisma__GuideClient<$Result.GetResult<Prisma.$GuidePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Guides.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuideCountArgs} args - Arguments to filter Guides to count.
     * @example
     * // Count the number of Guides
     * const count = await prisma.guide.count({
     *   where: {
     *     // ... the filter for the Guides we want to count
     *   }
     * })
    **/
    count<T extends GuideCountArgs>(
      args?: Subset<T, GuideCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GuideCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Guide.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuideAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GuideAggregateArgs>(args: Subset<T, GuideAggregateArgs>): Prisma.PrismaPromise<GetGuideAggregateType<T>>

    /**
     * Group by Guide.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuideGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GuideGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GuideGroupByArgs['orderBy'] }
        : { orderBy?: GuideGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GuideGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGuideGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Guide model
   */
  readonly fields: GuideFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Guide.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GuideClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Guide model
   */
  interface GuideFieldRefs {
    readonly id: FieldRef<"Guide", 'String'>
    readonly cityId: FieldRef<"Guide", 'String'>
    readonly name: FieldRef<"Guide", 'String'>
    readonly specialization: FieldRef<"Guide", 'String'>
    readonly city: FieldRef<"Guide", 'String'>
    readonly languages: FieldRef<"Guide", 'String'>
    readonly certification: FieldRef<"Guide", 'String'>
    readonly yearsOfExperience: FieldRef<"Guide", 'Int'>
    readonly rating: FieldRef<"Guide", 'Float'>
    readonly reviews: FieldRef<"Guide", 'Int'>
    readonly pricePerDay: FieldRef<"Guide", 'String'>
    readonly availability: FieldRef<"Guide", 'String'>
    readonly groupSize: FieldRef<"Guide", 'String'>
    readonly skills: FieldRef<"Guide", 'String'>
    readonly tours: FieldRef<"Guide", 'String'>
    readonly createdAt: FieldRef<"Guide", 'DateTime'>
    readonly updatedAt: FieldRef<"Guide", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Guide findUnique
   */
  export type GuideFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guide
     */
    select?: GuideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guide
     */
    omit?: GuideOmit<ExtArgs> | null
    /**
     * Filter, which Guide to fetch.
     */
    where: GuideWhereUniqueInput
  }

  /**
   * Guide findUniqueOrThrow
   */
  export type GuideFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guide
     */
    select?: GuideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guide
     */
    omit?: GuideOmit<ExtArgs> | null
    /**
     * Filter, which Guide to fetch.
     */
    where: GuideWhereUniqueInput
  }

  /**
   * Guide findFirst
   */
  export type GuideFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guide
     */
    select?: GuideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guide
     */
    omit?: GuideOmit<ExtArgs> | null
    /**
     * Filter, which Guide to fetch.
     */
    where?: GuideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Guides to fetch.
     */
    orderBy?: GuideOrderByWithRelationInput | GuideOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Guides.
     */
    cursor?: GuideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Guides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Guides.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Guides.
     */
    distinct?: GuideScalarFieldEnum | GuideScalarFieldEnum[]
  }

  /**
   * Guide findFirstOrThrow
   */
  export type GuideFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guide
     */
    select?: GuideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guide
     */
    omit?: GuideOmit<ExtArgs> | null
    /**
     * Filter, which Guide to fetch.
     */
    where?: GuideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Guides to fetch.
     */
    orderBy?: GuideOrderByWithRelationInput | GuideOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Guides.
     */
    cursor?: GuideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Guides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Guides.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Guides.
     */
    distinct?: GuideScalarFieldEnum | GuideScalarFieldEnum[]
  }

  /**
   * Guide findMany
   */
  export type GuideFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guide
     */
    select?: GuideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guide
     */
    omit?: GuideOmit<ExtArgs> | null
    /**
     * Filter, which Guides to fetch.
     */
    where?: GuideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Guides to fetch.
     */
    orderBy?: GuideOrderByWithRelationInput | GuideOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Guides.
     */
    cursor?: GuideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Guides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Guides.
     */
    skip?: number
    distinct?: GuideScalarFieldEnum | GuideScalarFieldEnum[]
  }

  /**
   * Guide create
   */
  export type GuideCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guide
     */
    select?: GuideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guide
     */
    omit?: GuideOmit<ExtArgs> | null
    /**
     * The data needed to create a Guide.
     */
    data: XOR<GuideCreateInput, GuideUncheckedCreateInput>
  }

  /**
   * Guide createMany
   */
  export type GuideCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Guides.
     */
    data: GuideCreateManyInput | GuideCreateManyInput[]
  }

  /**
   * Guide createManyAndReturn
   */
  export type GuideCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guide
     */
    select?: GuideSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Guide
     */
    omit?: GuideOmit<ExtArgs> | null
    /**
     * The data used to create many Guides.
     */
    data: GuideCreateManyInput | GuideCreateManyInput[]
  }

  /**
   * Guide update
   */
  export type GuideUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guide
     */
    select?: GuideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guide
     */
    omit?: GuideOmit<ExtArgs> | null
    /**
     * The data needed to update a Guide.
     */
    data: XOR<GuideUpdateInput, GuideUncheckedUpdateInput>
    /**
     * Choose, which Guide to update.
     */
    where: GuideWhereUniqueInput
  }

  /**
   * Guide updateMany
   */
  export type GuideUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Guides.
     */
    data: XOR<GuideUpdateManyMutationInput, GuideUncheckedUpdateManyInput>
    /**
     * Filter which Guides to update
     */
    where?: GuideWhereInput
    /**
     * Limit how many Guides to update.
     */
    limit?: number
  }

  /**
   * Guide updateManyAndReturn
   */
  export type GuideUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guide
     */
    select?: GuideSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Guide
     */
    omit?: GuideOmit<ExtArgs> | null
    /**
     * The data used to update Guides.
     */
    data: XOR<GuideUpdateManyMutationInput, GuideUncheckedUpdateManyInput>
    /**
     * Filter which Guides to update
     */
    where?: GuideWhereInput
    /**
     * Limit how many Guides to update.
     */
    limit?: number
  }

  /**
   * Guide upsert
   */
  export type GuideUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guide
     */
    select?: GuideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guide
     */
    omit?: GuideOmit<ExtArgs> | null
    /**
     * The filter to search for the Guide to update in case it exists.
     */
    where: GuideWhereUniqueInput
    /**
     * In case the Guide found by the `where` argument doesn't exist, create a new Guide with this data.
     */
    create: XOR<GuideCreateInput, GuideUncheckedCreateInput>
    /**
     * In case the Guide was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GuideUpdateInput, GuideUncheckedUpdateInput>
  }

  /**
   * Guide delete
   */
  export type GuideDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guide
     */
    select?: GuideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guide
     */
    omit?: GuideOmit<ExtArgs> | null
    /**
     * Filter which Guide to delete.
     */
    where: GuideWhereUniqueInput
  }

  /**
   * Guide deleteMany
   */
  export type GuideDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Guides to delete
     */
    where?: GuideWhereInput
    /**
     * Limit how many Guides to delete.
     */
    limit?: number
  }

  /**
   * Guide without action
   */
  export type GuideDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guide
     */
    select?: GuideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guide
     */
    omit?: GuideOmit<ExtArgs> | null
  }


  /**
   * Model Event
   */

  export type AggregateEvent = {
    _count: EventCountAggregateOutputType | null
    _avg: EventAvgAggregateOutputType | null
    _sum: EventSumAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  export type EventAvgAggregateOutputType = {
    entryFee: number | null
  }

  export type EventSumAggregateOutputType = {
    entryFee: number | null
  }

  export type EventMinAggregateOutputType = {
    id: string | null
    name: string | null
    city: string | null
    country: string | null
    startDate: string | null
    endDate: string | null
    description: string | null
    category: string | null
    expectedCrowd: string | null
    entryFee: number | null
    highlights: string | null
    bestLocations: string | null
    tips: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EventMaxAggregateOutputType = {
    id: string | null
    name: string | null
    city: string | null
    country: string | null
    startDate: string | null
    endDate: string | null
    description: string | null
    category: string | null
    expectedCrowd: string | null
    entryFee: number | null
    highlights: string | null
    bestLocations: string | null
    tips: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EventCountAggregateOutputType = {
    id: number
    name: number
    city: number
    country: number
    startDate: number
    endDate: number
    description: number
    category: number
    expectedCrowd: number
    entryFee: number
    highlights: number
    bestLocations: number
    tips: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EventAvgAggregateInputType = {
    entryFee?: true
  }

  export type EventSumAggregateInputType = {
    entryFee?: true
  }

  export type EventMinAggregateInputType = {
    id?: true
    name?: true
    city?: true
    country?: true
    startDate?: true
    endDate?: true
    description?: true
    category?: true
    expectedCrowd?: true
    entryFee?: true
    highlights?: true
    bestLocations?: true
    tips?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EventMaxAggregateInputType = {
    id?: true
    name?: true
    city?: true
    country?: true
    startDate?: true
    endDate?: true
    description?: true
    category?: true
    expectedCrowd?: true
    entryFee?: true
    highlights?: true
    bestLocations?: true
    tips?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EventCountAggregateInputType = {
    id?: true
    name?: true
    city?: true
    country?: true
    startDate?: true
    endDate?: true
    description?: true
    category?: true
    expectedCrowd?: true
    entryFee?: true
    highlights?: true
    bestLocations?: true
    tips?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Event to aggregate.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Events
    **/
    _count?: true | EventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventMaxAggregateInputType
  }

  export type GetEventAggregateType<T extends EventAggregateArgs> = {
        [P in keyof T & keyof AggregateEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvent[P]>
      : GetScalarType<T[P], AggregateEvent[P]>
  }




  export type EventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
    orderBy?: EventOrderByWithAggregationInput | EventOrderByWithAggregationInput[]
    by: EventScalarFieldEnum[] | EventScalarFieldEnum
    having?: EventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventCountAggregateInputType | true
    _avg?: EventAvgAggregateInputType
    _sum?: EventSumAggregateInputType
    _min?: EventMinAggregateInputType
    _max?: EventMaxAggregateInputType
  }

  export type EventGroupByOutputType = {
    id: string
    name: string
    city: string
    country: string
    startDate: string
    endDate: string
    description: string | null
    category: string
    expectedCrowd: string | null
    entryFee: number
    highlights: string
    bestLocations: string
    tips: string
    createdAt: Date
    updatedAt: Date
    _count: EventCountAggregateOutputType | null
    _avg: EventAvgAggregateOutputType | null
    _sum: EventSumAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  type GetEventGroupByPayload<T extends EventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventGroupByOutputType[P]>
            : GetScalarType<T[P], EventGroupByOutputType[P]>
        }
      >
    >


  export type EventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    city?: boolean
    country?: boolean
    startDate?: boolean
    endDate?: boolean
    description?: boolean
    category?: boolean
    expectedCrowd?: boolean
    entryFee?: boolean
    highlights?: boolean
    bestLocations?: boolean
    tips?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["event"]>

  export type EventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    city?: boolean
    country?: boolean
    startDate?: boolean
    endDate?: boolean
    description?: boolean
    category?: boolean
    expectedCrowd?: boolean
    entryFee?: boolean
    highlights?: boolean
    bestLocations?: boolean
    tips?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["event"]>

  export type EventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    city?: boolean
    country?: boolean
    startDate?: boolean
    endDate?: boolean
    description?: boolean
    category?: boolean
    expectedCrowd?: boolean
    entryFee?: boolean
    highlights?: boolean
    bestLocations?: boolean
    tips?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["event"]>

  export type EventSelectScalar = {
    id?: boolean
    name?: boolean
    city?: boolean
    country?: boolean
    startDate?: boolean
    endDate?: boolean
    description?: boolean
    category?: boolean
    expectedCrowd?: boolean
    entryFee?: boolean
    highlights?: boolean
    bestLocations?: boolean
    tips?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "city" | "country" | "startDate" | "endDate" | "description" | "category" | "expectedCrowd" | "entryFee" | "highlights" | "bestLocations" | "tips" | "createdAt" | "updatedAt", ExtArgs["result"]["event"]>

  export type $EventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Event"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      city: string
      country: string
      startDate: string
      endDate: string
      description: string | null
      category: string
      expectedCrowd: string | null
      entryFee: number
      highlights: string
      bestLocations: string
      tips: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["event"]>
    composites: {}
  }

  type EventGetPayload<S extends boolean | null | undefined | EventDefaultArgs> = $Result.GetResult<Prisma.$EventPayload, S>

  type EventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EventCountAggregateInputType | true
    }

  export interface EventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Event'], meta: { name: 'Event' } }
    /**
     * Find zero or one Event that matches the filter.
     * @param {EventFindUniqueArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventFindUniqueArgs>(args: SelectSubset<T, EventFindUniqueArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Event that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EventFindUniqueOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventFindUniqueOrThrowArgs>(args: SelectSubset<T, EventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Event that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventFindFirstArgs>(args?: SelectSubset<T, EventFindFirstArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Event that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventFindFirstOrThrowArgs>(args?: SelectSubset<T, EventFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Events
     * const events = await prisma.event.findMany()
     * 
     * // Get first 10 Events
     * const events = await prisma.event.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventWithIdOnly = await prisma.event.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EventFindManyArgs>(args?: SelectSubset<T, EventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Event.
     * @param {EventCreateArgs} args - Arguments to create a Event.
     * @example
     * // Create one Event
     * const Event = await prisma.event.create({
     *   data: {
     *     // ... data to create a Event
     *   }
     * })
     * 
     */
    create<T extends EventCreateArgs>(args: SelectSubset<T, EventCreateArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Events.
     * @param {EventCreateManyArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const event = await prisma.event.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventCreateManyArgs>(args?: SelectSubset<T, EventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Events and returns the data saved in the database.
     * @param {EventCreateManyAndReturnArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const event = await prisma.event.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Events and only return the `id`
     * const eventWithIdOnly = await prisma.event.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EventCreateManyAndReturnArgs>(args?: SelectSubset<T, EventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Event.
     * @param {EventDeleteArgs} args - Arguments to delete one Event.
     * @example
     * // Delete one Event
     * const Event = await prisma.event.delete({
     *   where: {
     *     // ... filter to delete one Event
     *   }
     * })
     * 
     */
    delete<T extends EventDeleteArgs>(args: SelectSubset<T, EventDeleteArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Event.
     * @param {EventUpdateArgs} args - Arguments to update one Event.
     * @example
     * // Update one Event
     * const event = await prisma.event.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventUpdateArgs>(args: SelectSubset<T, EventUpdateArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Events.
     * @param {EventDeleteManyArgs} args - Arguments to filter Events to delete.
     * @example
     * // Delete a few Events
     * const { count } = await prisma.event.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventDeleteManyArgs>(args?: SelectSubset<T, EventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Events
     * const event = await prisma.event.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventUpdateManyArgs>(args: SelectSubset<T, EventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Events and returns the data updated in the database.
     * @param {EventUpdateManyAndReturnArgs} args - Arguments to update many Events.
     * @example
     * // Update many Events
     * const event = await prisma.event.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Events and only return the `id`
     * const eventWithIdOnly = await prisma.event.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EventUpdateManyAndReturnArgs>(args: SelectSubset<T, EventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Event.
     * @param {EventUpsertArgs} args - Arguments to update or create a Event.
     * @example
     * // Update or create a Event
     * const event = await prisma.event.upsert({
     *   create: {
     *     // ... data to create a Event
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Event we want to update
     *   }
     * })
     */
    upsert<T extends EventUpsertArgs>(args: SelectSubset<T, EventUpsertArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventCountArgs} args - Arguments to filter Events to count.
     * @example
     * // Count the number of Events
     * const count = await prisma.event.count({
     *   where: {
     *     // ... the filter for the Events we want to count
     *   }
     * })
    **/
    count<T extends EventCountArgs>(
      args?: Subset<T, EventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventAggregateArgs>(args: Subset<T, EventAggregateArgs>): Prisma.PrismaPromise<GetEventAggregateType<T>>

    /**
     * Group by Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventGroupByArgs['orderBy'] }
        : { orderBy?: EventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Event model
   */
  readonly fields: EventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Event.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Event model
   */
  interface EventFieldRefs {
    readonly id: FieldRef<"Event", 'String'>
    readonly name: FieldRef<"Event", 'String'>
    readonly city: FieldRef<"Event", 'String'>
    readonly country: FieldRef<"Event", 'String'>
    readonly startDate: FieldRef<"Event", 'String'>
    readonly endDate: FieldRef<"Event", 'String'>
    readonly description: FieldRef<"Event", 'String'>
    readonly category: FieldRef<"Event", 'String'>
    readonly expectedCrowd: FieldRef<"Event", 'String'>
    readonly entryFee: FieldRef<"Event", 'Float'>
    readonly highlights: FieldRef<"Event", 'String'>
    readonly bestLocations: FieldRef<"Event", 'String'>
    readonly tips: FieldRef<"Event", 'String'>
    readonly createdAt: FieldRef<"Event", 'DateTime'>
    readonly updatedAt: FieldRef<"Event", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Event findUnique
   */
  export type EventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event findUniqueOrThrow
   */
  export type EventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event findFirst
   */
  export type EventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event findFirstOrThrow
   */
  export type EventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event findMany
   */
  export type EventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Filter, which Events to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event create
   */
  export type EventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * The data needed to create a Event.
     */
    data: XOR<EventCreateInput, EventUncheckedCreateInput>
  }

  /**
   * Event createMany
   */
  export type EventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Events.
     */
    data: EventCreateManyInput | EventCreateManyInput[]
  }

  /**
   * Event createManyAndReturn
   */
  export type EventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * The data used to create many Events.
     */
    data: EventCreateManyInput | EventCreateManyInput[]
  }

  /**
   * Event update
   */
  export type EventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * The data needed to update a Event.
     */
    data: XOR<EventUpdateInput, EventUncheckedUpdateInput>
    /**
     * Choose, which Event to update.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event updateMany
   */
  export type EventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Events.
     */
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyInput>
    /**
     * Filter which Events to update
     */
    where?: EventWhereInput
    /**
     * Limit how many Events to update.
     */
    limit?: number
  }

  /**
   * Event updateManyAndReturn
   */
  export type EventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * The data used to update Events.
     */
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyInput>
    /**
     * Filter which Events to update
     */
    where?: EventWhereInput
    /**
     * Limit how many Events to update.
     */
    limit?: number
  }

  /**
   * Event upsert
   */
  export type EventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * The filter to search for the Event to update in case it exists.
     */
    where: EventWhereUniqueInput
    /**
     * In case the Event found by the `where` argument doesn't exist, create a new Event with this data.
     */
    create: XOR<EventCreateInput, EventUncheckedCreateInput>
    /**
     * In case the Event was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventUpdateInput, EventUncheckedUpdateInput>
  }

  /**
   * Event delete
   */
  export type EventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Filter which Event to delete.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event deleteMany
   */
  export type EventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Events to delete
     */
    where?: EventWhereInput
    /**
     * Limit how many Events to delete.
     */
    limit?: number
  }

  /**
   * Event without action
   */
  export type EventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
  }


  /**
   * Model CostOfLiving
   */

  export type AggregateCostOfLiving = {
    _count: CostOfLivingCountAggregateOutputType | null
    _avg: CostOfLivingAvgAggregateOutputType | null
    _sum: CostOfLivingSumAggregateOutputType | null
    _min: CostOfLivingMinAggregateOutputType | null
    _max: CostOfLivingMaxAggregateOutputType | null
  }

  export type CostOfLivingAvgAggregateOutputType = {
    weeklyTotalEstimate: number | null
    monthlyTotalEstimate: number | null
  }

  export type CostOfLivingSumAggregateOutputType = {
    weeklyTotalEstimate: number | null
    monthlyTotalEstimate: number | null
  }

  export type CostOfLivingMinAggregateOutputType = {
    id: string | null
    city: string | null
    country: string | null
    category: string | null
    dailyCost: string | null
    weeklyTotalEstimate: number | null
    monthlyTotalEstimate: number | null
    costBreakdown: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CostOfLivingMaxAggregateOutputType = {
    id: string | null
    city: string | null
    country: string | null
    category: string | null
    dailyCost: string | null
    weeklyTotalEstimate: number | null
    monthlyTotalEstimate: number | null
    costBreakdown: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CostOfLivingCountAggregateOutputType = {
    id: number
    city: number
    country: number
    category: number
    dailyCost: number
    weeklyTotalEstimate: number
    monthlyTotalEstimate: number
    costBreakdown: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CostOfLivingAvgAggregateInputType = {
    weeklyTotalEstimate?: true
    monthlyTotalEstimate?: true
  }

  export type CostOfLivingSumAggregateInputType = {
    weeklyTotalEstimate?: true
    monthlyTotalEstimate?: true
  }

  export type CostOfLivingMinAggregateInputType = {
    id?: true
    city?: true
    country?: true
    category?: true
    dailyCost?: true
    weeklyTotalEstimate?: true
    monthlyTotalEstimate?: true
    costBreakdown?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CostOfLivingMaxAggregateInputType = {
    id?: true
    city?: true
    country?: true
    category?: true
    dailyCost?: true
    weeklyTotalEstimate?: true
    monthlyTotalEstimate?: true
    costBreakdown?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CostOfLivingCountAggregateInputType = {
    id?: true
    city?: true
    country?: true
    category?: true
    dailyCost?: true
    weeklyTotalEstimate?: true
    monthlyTotalEstimate?: true
    costBreakdown?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CostOfLivingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CostOfLiving to aggregate.
     */
    where?: CostOfLivingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CostOfLivings to fetch.
     */
    orderBy?: CostOfLivingOrderByWithRelationInput | CostOfLivingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CostOfLivingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CostOfLivings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CostOfLivings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CostOfLivings
    **/
    _count?: true | CostOfLivingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CostOfLivingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CostOfLivingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CostOfLivingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CostOfLivingMaxAggregateInputType
  }

  export type GetCostOfLivingAggregateType<T extends CostOfLivingAggregateArgs> = {
        [P in keyof T & keyof AggregateCostOfLiving]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCostOfLiving[P]>
      : GetScalarType<T[P], AggregateCostOfLiving[P]>
  }




  export type CostOfLivingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CostOfLivingWhereInput
    orderBy?: CostOfLivingOrderByWithAggregationInput | CostOfLivingOrderByWithAggregationInput[]
    by: CostOfLivingScalarFieldEnum[] | CostOfLivingScalarFieldEnum
    having?: CostOfLivingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CostOfLivingCountAggregateInputType | true
    _avg?: CostOfLivingAvgAggregateInputType
    _sum?: CostOfLivingSumAggregateInputType
    _min?: CostOfLivingMinAggregateInputType
    _max?: CostOfLivingMaxAggregateInputType
  }

  export type CostOfLivingGroupByOutputType = {
    id: string
    city: string
    country: string
    category: string
    dailyCost: string
    weeklyTotalEstimate: number
    monthlyTotalEstimate: number
    costBreakdown: string
    createdAt: Date
    updatedAt: Date
    _count: CostOfLivingCountAggregateOutputType | null
    _avg: CostOfLivingAvgAggregateOutputType | null
    _sum: CostOfLivingSumAggregateOutputType | null
    _min: CostOfLivingMinAggregateOutputType | null
    _max: CostOfLivingMaxAggregateOutputType | null
  }

  type GetCostOfLivingGroupByPayload<T extends CostOfLivingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CostOfLivingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CostOfLivingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CostOfLivingGroupByOutputType[P]>
            : GetScalarType<T[P], CostOfLivingGroupByOutputType[P]>
        }
      >
    >


  export type CostOfLivingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    city?: boolean
    country?: boolean
    category?: boolean
    dailyCost?: boolean
    weeklyTotalEstimate?: boolean
    monthlyTotalEstimate?: boolean
    costBreakdown?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["costOfLiving"]>

  export type CostOfLivingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    city?: boolean
    country?: boolean
    category?: boolean
    dailyCost?: boolean
    weeklyTotalEstimate?: boolean
    monthlyTotalEstimate?: boolean
    costBreakdown?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["costOfLiving"]>

  export type CostOfLivingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    city?: boolean
    country?: boolean
    category?: boolean
    dailyCost?: boolean
    weeklyTotalEstimate?: boolean
    monthlyTotalEstimate?: boolean
    costBreakdown?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["costOfLiving"]>

  export type CostOfLivingSelectScalar = {
    id?: boolean
    city?: boolean
    country?: boolean
    category?: boolean
    dailyCost?: boolean
    weeklyTotalEstimate?: boolean
    monthlyTotalEstimate?: boolean
    costBreakdown?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CostOfLivingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "city" | "country" | "category" | "dailyCost" | "weeklyTotalEstimate" | "monthlyTotalEstimate" | "costBreakdown" | "createdAt" | "updatedAt", ExtArgs["result"]["costOfLiving"]>

  export type $CostOfLivingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CostOfLiving"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      city: string
      country: string
      category: string
      dailyCost: string
      weeklyTotalEstimate: number
      monthlyTotalEstimate: number
      costBreakdown: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["costOfLiving"]>
    composites: {}
  }

  type CostOfLivingGetPayload<S extends boolean | null | undefined | CostOfLivingDefaultArgs> = $Result.GetResult<Prisma.$CostOfLivingPayload, S>

  type CostOfLivingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CostOfLivingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CostOfLivingCountAggregateInputType | true
    }

  export interface CostOfLivingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CostOfLiving'], meta: { name: 'CostOfLiving' } }
    /**
     * Find zero or one CostOfLiving that matches the filter.
     * @param {CostOfLivingFindUniqueArgs} args - Arguments to find a CostOfLiving
     * @example
     * // Get one CostOfLiving
     * const costOfLiving = await prisma.costOfLiving.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CostOfLivingFindUniqueArgs>(args: SelectSubset<T, CostOfLivingFindUniqueArgs<ExtArgs>>): Prisma__CostOfLivingClient<$Result.GetResult<Prisma.$CostOfLivingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CostOfLiving that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CostOfLivingFindUniqueOrThrowArgs} args - Arguments to find a CostOfLiving
     * @example
     * // Get one CostOfLiving
     * const costOfLiving = await prisma.costOfLiving.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CostOfLivingFindUniqueOrThrowArgs>(args: SelectSubset<T, CostOfLivingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CostOfLivingClient<$Result.GetResult<Prisma.$CostOfLivingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CostOfLiving that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostOfLivingFindFirstArgs} args - Arguments to find a CostOfLiving
     * @example
     * // Get one CostOfLiving
     * const costOfLiving = await prisma.costOfLiving.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CostOfLivingFindFirstArgs>(args?: SelectSubset<T, CostOfLivingFindFirstArgs<ExtArgs>>): Prisma__CostOfLivingClient<$Result.GetResult<Prisma.$CostOfLivingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CostOfLiving that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostOfLivingFindFirstOrThrowArgs} args - Arguments to find a CostOfLiving
     * @example
     * // Get one CostOfLiving
     * const costOfLiving = await prisma.costOfLiving.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CostOfLivingFindFirstOrThrowArgs>(args?: SelectSubset<T, CostOfLivingFindFirstOrThrowArgs<ExtArgs>>): Prisma__CostOfLivingClient<$Result.GetResult<Prisma.$CostOfLivingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CostOfLivings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostOfLivingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CostOfLivings
     * const costOfLivings = await prisma.costOfLiving.findMany()
     * 
     * // Get first 10 CostOfLivings
     * const costOfLivings = await prisma.costOfLiving.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const costOfLivingWithIdOnly = await prisma.costOfLiving.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CostOfLivingFindManyArgs>(args?: SelectSubset<T, CostOfLivingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CostOfLivingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CostOfLiving.
     * @param {CostOfLivingCreateArgs} args - Arguments to create a CostOfLiving.
     * @example
     * // Create one CostOfLiving
     * const CostOfLiving = await prisma.costOfLiving.create({
     *   data: {
     *     // ... data to create a CostOfLiving
     *   }
     * })
     * 
     */
    create<T extends CostOfLivingCreateArgs>(args: SelectSubset<T, CostOfLivingCreateArgs<ExtArgs>>): Prisma__CostOfLivingClient<$Result.GetResult<Prisma.$CostOfLivingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CostOfLivings.
     * @param {CostOfLivingCreateManyArgs} args - Arguments to create many CostOfLivings.
     * @example
     * // Create many CostOfLivings
     * const costOfLiving = await prisma.costOfLiving.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CostOfLivingCreateManyArgs>(args?: SelectSubset<T, CostOfLivingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CostOfLivings and returns the data saved in the database.
     * @param {CostOfLivingCreateManyAndReturnArgs} args - Arguments to create many CostOfLivings.
     * @example
     * // Create many CostOfLivings
     * const costOfLiving = await prisma.costOfLiving.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CostOfLivings and only return the `id`
     * const costOfLivingWithIdOnly = await prisma.costOfLiving.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CostOfLivingCreateManyAndReturnArgs>(args?: SelectSubset<T, CostOfLivingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CostOfLivingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CostOfLiving.
     * @param {CostOfLivingDeleteArgs} args - Arguments to delete one CostOfLiving.
     * @example
     * // Delete one CostOfLiving
     * const CostOfLiving = await prisma.costOfLiving.delete({
     *   where: {
     *     // ... filter to delete one CostOfLiving
     *   }
     * })
     * 
     */
    delete<T extends CostOfLivingDeleteArgs>(args: SelectSubset<T, CostOfLivingDeleteArgs<ExtArgs>>): Prisma__CostOfLivingClient<$Result.GetResult<Prisma.$CostOfLivingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CostOfLiving.
     * @param {CostOfLivingUpdateArgs} args - Arguments to update one CostOfLiving.
     * @example
     * // Update one CostOfLiving
     * const costOfLiving = await prisma.costOfLiving.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CostOfLivingUpdateArgs>(args: SelectSubset<T, CostOfLivingUpdateArgs<ExtArgs>>): Prisma__CostOfLivingClient<$Result.GetResult<Prisma.$CostOfLivingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CostOfLivings.
     * @param {CostOfLivingDeleteManyArgs} args - Arguments to filter CostOfLivings to delete.
     * @example
     * // Delete a few CostOfLivings
     * const { count } = await prisma.costOfLiving.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CostOfLivingDeleteManyArgs>(args?: SelectSubset<T, CostOfLivingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CostOfLivings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostOfLivingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CostOfLivings
     * const costOfLiving = await prisma.costOfLiving.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CostOfLivingUpdateManyArgs>(args: SelectSubset<T, CostOfLivingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CostOfLivings and returns the data updated in the database.
     * @param {CostOfLivingUpdateManyAndReturnArgs} args - Arguments to update many CostOfLivings.
     * @example
     * // Update many CostOfLivings
     * const costOfLiving = await prisma.costOfLiving.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CostOfLivings and only return the `id`
     * const costOfLivingWithIdOnly = await prisma.costOfLiving.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CostOfLivingUpdateManyAndReturnArgs>(args: SelectSubset<T, CostOfLivingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CostOfLivingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CostOfLiving.
     * @param {CostOfLivingUpsertArgs} args - Arguments to update or create a CostOfLiving.
     * @example
     * // Update or create a CostOfLiving
     * const costOfLiving = await prisma.costOfLiving.upsert({
     *   create: {
     *     // ... data to create a CostOfLiving
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CostOfLiving we want to update
     *   }
     * })
     */
    upsert<T extends CostOfLivingUpsertArgs>(args: SelectSubset<T, CostOfLivingUpsertArgs<ExtArgs>>): Prisma__CostOfLivingClient<$Result.GetResult<Prisma.$CostOfLivingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CostOfLivings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostOfLivingCountArgs} args - Arguments to filter CostOfLivings to count.
     * @example
     * // Count the number of CostOfLivings
     * const count = await prisma.costOfLiving.count({
     *   where: {
     *     // ... the filter for the CostOfLivings we want to count
     *   }
     * })
    **/
    count<T extends CostOfLivingCountArgs>(
      args?: Subset<T, CostOfLivingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CostOfLivingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CostOfLiving.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostOfLivingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CostOfLivingAggregateArgs>(args: Subset<T, CostOfLivingAggregateArgs>): Prisma.PrismaPromise<GetCostOfLivingAggregateType<T>>

    /**
     * Group by CostOfLiving.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostOfLivingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CostOfLivingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CostOfLivingGroupByArgs['orderBy'] }
        : { orderBy?: CostOfLivingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CostOfLivingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCostOfLivingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CostOfLiving model
   */
  readonly fields: CostOfLivingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CostOfLiving.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CostOfLivingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CostOfLiving model
   */
  interface CostOfLivingFieldRefs {
    readonly id: FieldRef<"CostOfLiving", 'String'>
    readonly city: FieldRef<"CostOfLiving", 'String'>
    readonly country: FieldRef<"CostOfLiving", 'String'>
    readonly category: FieldRef<"CostOfLiving", 'String'>
    readonly dailyCost: FieldRef<"CostOfLiving", 'String'>
    readonly weeklyTotalEstimate: FieldRef<"CostOfLiving", 'Float'>
    readonly monthlyTotalEstimate: FieldRef<"CostOfLiving", 'Float'>
    readonly costBreakdown: FieldRef<"CostOfLiving", 'String'>
    readonly createdAt: FieldRef<"CostOfLiving", 'DateTime'>
    readonly updatedAt: FieldRef<"CostOfLiving", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CostOfLiving findUnique
   */
  export type CostOfLivingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostOfLiving
     */
    select?: CostOfLivingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostOfLiving
     */
    omit?: CostOfLivingOmit<ExtArgs> | null
    /**
     * Filter, which CostOfLiving to fetch.
     */
    where: CostOfLivingWhereUniqueInput
  }

  /**
   * CostOfLiving findUniqueOrThrow
   */
  export type CostOfLivingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostOfLiving
     */
    select?: CostOfLivingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostOfLiving
     */
    omit?: CostOfLivingOmit<ExtArgs> | null
    /**
     * Filter, which CostOfLiving to fetch.
     */
    where: CostOfLivingWhereUniqueInput
  }

  /**
   * CostOfLiving findFirst
   */
  export type CostOfLivingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostOfLiving
     */
    select?: CostOfLivingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostOfLiving
     */
    omit?: CostOfLivingOmit<ExtArgs> | null
    /**
     * Filter, which CostOfLiving to fetch.
     */
    where?: CostOfLivingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CostOfLivings to fetch.
     */
    orderBy?: CostOfLivingOrderByWithRelationInput | CostOfLivingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CostOfLivings.
     */
    cursor?: CostOfLivingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CostOfLivings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CostOfLivings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CostOfLivings.
     */
    distinct?: CostOfLivingScalarFieldEnum | CostOfLivingScalarFieldEnum[]
  }

  /**
   * CostOfLiving findFirstOrThrow
   */
  export type CostOfLivingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostOfLiving
     */
    select?: CostOfLivingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostOfLiving
     */
    omit?: CostOfLivingOmit<ExtArgs> | null
    /**
     * Filter, which CostOfLiving to fetch.
     */
    where?: CostOfLivingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CostOfLivings to fetch.
     */
    orderBy?: CostOfLivingOrderByWithRelationInput | CostOfLivingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CostOfLivings.
     */
    cursor?: CostOfLivingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CostOfLivings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CostOfLivings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CostOfLivings.
     */
    distinct?: CostOfLivingScalarFieldEnum | CostOfLivingScalarFieldEnum[]
  }

  /**
   * CostOfLiving findMany
   */
  export type CostOfLivingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostOfLiving
     */
    select?: CostOfLivingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostOfLiving
     */
    omit?: CostOfLivingOmit<ExtArgs> | null
    /**
     * Filter, which CostOfLivings to fetch.
     */
    where?: CostOfLivingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CostOfLivings to fetch.
     */
    orderBy?: CostOfLivingOrderByWithRelationInput | CostOfLivingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CostOfLivings.
     */
    cursor?: CostOfLivingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CostOfLivings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CostOfLivings.
     */
    skip?: number
    distinct?: CostOfLivingScalarFieldEnum | CostOfLivingScalarFieldEnum[]
  }

  /**
   * CostOfLiving create
   */
  export type CostOfLivingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostOfLiving
     */
    select?: CostOfLivingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostOfLiving
     */
    omit?: CostOfLivingOmit<ExtArgs> | null
    /**
     * The data needed to create a CostOfLiving.
     */
    data: XOR<CostOfLivingCreateInput, CostOfLivingUncheckedCreateInput>
  }

  /**
   * CostOfLiving createMany
   */
  export type CostOfLivingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CostOfLivings.
     */
    data: CostOfLivingCreateManyInput | CostOfLivingCreateManyInput[]
  }

  /**
   * CostOfLiving createManyAndReturn
   */
  export type CostOfLivingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostOfLiving
     */
    select?: CostOfLivingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CostOfLiving
     */
    omit?: CostOfLivingOmit<ExtArgs> | null
    /**
     * The data used to create many CostOfLivings.
     */
    data: CostOfLivingCreateManyInput | CostOfLivingCreateManyInput[]
  }

  /**
   * CostOfLiving update
   */
  export type CostOfLivingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostOfLiving
     */
    select?: CostOfLivingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostOfLiving
     */
    omit?: CostOfLivingOmit<ExtArgs> | null
    /**
     * The data needed to update a CostOfLiving.
     */
    data: XOR<CostOfLivingUpdateInput, CostOfLivingUncheckedUpdateInput>
    /**
     * Choose, which CostOfLiving to update.
     */
    where: CostOfLivingWhereUniqueInput
  }

  /**
   * CostOfLiving updateMany
   */
  export type CostOfLivingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CostOfLivings.
     */
    data: XOR<CostOfLivingUpdateManyMutationInput, CostOfLivingUncheckedUpdateManyInput>
    /**
     * Filter which CostOfLivings to update
     */
    where?: CostOfLivingWhereInput
    /**
     * Limit how many CostOfLivings to update.
     */
    limit?: number
  }

  /**
   * CostOfLiving updateManyAndReturn
   */
  export type CostOfLivingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostOfLiving
     */
    select?: CostOfLivingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CostOfLiving
     */
    omit?: CostOfLivingOmit<ExtArgs> | null
    /**
     * The data used to update CostOfLivings.
     */
    data: XOR<CostOfLivingUpdateManyMutationInput, CostOfLivingUncheckedUpdateManyInput>
    /**
     * Filter which CostOfLivings to update
     */
    where?: CostOfLivingWhereInput
    /**
     * Limit how many CostOfLivings to update.
     */
    limit?: number
  }

  /**
   * CostOfLiving upsert
   */
  export type CostOfLivingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostOfLiving
     */
    select?: CostOfLivingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostOfLiving
     */
    omit?: CostOfLivingOmit<ExtArgs> | null
    /**
     * The filter to search for the CostOfLiving to update in case it exists.
     */
    where: CostOfLivingWhereUniqueInput
    /**
     * In case the CostOfLiving found by the `where` argument doesn't exist, create a new CostOfLiving with this data.
     */
    create: XOR<CostOfLivingCreateInput, CostOfLivingUncheckedCreateInput>
    /**
     * In case the CostOfLiving was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CostOfLivingUpdateInput, CostOfLivingUncheckedUpdateInput>
  }

  /**
   * CostOfLiving delete
   */
  export type CostOfLivingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostOfLiving
     */
    select?: CostOfLivingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostOfLiving
     */
    omit?: CostOfLivingOmit<ExtArgs> | null
    /**
     * Filter which CostOfLiving to delete.
     */
    where: CostOfLivingWhereUniqueInput
  }

  /**
   * CostOfLiving deleteMany
   */
  export type CostOfLivingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CostOfLivings to delete
     */
    where?: CostOfLivingWhereInput
    /**
     * Limit how many CostOfLivings to delete.
     */
    limit?: number
  }

  /**
   * CostOfLiving without action
   */
  export type CostOfLivingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostOfLiving
     */
    select?: CostOfLivingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostOfLiving
     */
    omit?: CostOfLivingOmit<ExtArgs> | null
  }


  /**
   * Model Crowd
   */

  export type AggregateCrowd = {
    _count: CrowdCountAggregateOutputType | null
    _avg: CrowdAvgAggregateOutputType | null
    _sum: CrowdSumAggregateOutputType | null
    _min: CrowdMinAggregateOutputType | null
    _max: CrowdMaxAggregateOutputType | null
  }

  export type CrowdAvgAggregateOutputType = {
    avgWaitTime: number | null
  }

  export type CrowdSumAggregateOutputType = {
    avgWaitTime: number | null
  }

  export type CrowdMinAggregateOutputType = {
    id: string | null
    location: string | null
    date: string | null
    hourlyData: string | null
    seasonalFactor: string | null
    bestTimeToVisit: string | null
    avgWaitTime: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CrowdMaxAggregateOutputType = {
    id: string | null
    location: string | null
    date: string | null
    hourlyData: string | null
    seasonalFactor: string | null
    bestTimeToVisit: string | null
    avgWaitTime: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CrowdCountAggregateOutputType = {
    id: number
    location: number
    date: number
    hourlyData: number
    seasonalFactor: number
    bestTimeToVisit: number
    avgWaitTime: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CrowdAvgAggregateInputType = {
    avgWaitTime?: true
  }

  export type CrowdSumAggregateInputType = {
    avgWaitTime?: true
  }

  export type CrowdMinAggregateInputType = {
    id?: true
    location?: true
    date?: true
    hourlyData?: true
    seasonalFactor?: true
    bestTimeToVisit?: true
    avgWaitTime?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CrowdMaxAggregateInputType = {
    id?: true
    location?: true
    date?: true
    hourlyData?: true
    seasonalFactor?: true
    bestTimeToVisit?: true
    avgWaitTime?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CrowdCountAggregateInputType = {
    id?: true
    location?: true
    date?: true
    hourlyData?: true
    seasonalFactor?: true
    bestTimeToVisit?: true
    avgWaitTime?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CrowdAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Crowd to aggregate.
     */
    where?: CrowdWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Crowds to fetch.
     */
    orderBy?: CrowdOrderByWithRelationInput | CrowdOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CrowdWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Crowds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Crowds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Crowds
    **/
    _count?: true | CrowdCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CrowdAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CrowdSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CrowdMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CrowdMaxAggregateInputType
  }

  export type GetCrowdAggregateType<T extends CrowdAggregateArgs> = {
        [P in keyof T & keyof AggregateCrowd]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCrowd[P]>
      : GetScalarType<T[P], AggregateCrowd[P]>
  }




  export type CrowdGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CrowdWhereInput
    orderBy?: CrowdOrderByWithAggregationInput | CrowdOrderByWithAggregationInput[]
    by: CrowdScalarFieldEnum[] | CrowdScalarFieldEnum
    having?: CrowdScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CrowdCountAggregateInputType | true
    _avg?: CrowdAvgAggregateInputType
    _sum?: CrowdSumAggregateInputType
    _min?: CrowdMinAggregateInputType
    _max?: CrowdMaxAggregateInputType
  }

  export type CrowdGroupByOutputType = {
    id: string
    location: string
    date: string
    hourlyData: string
    seasonalFactor: string
    bestTimeToVisit: string | null
    avgWaitTime: number | null
    createdAt: Date
    updatedAt: Date
    _count: CrowdCountAggregateOutputType | null
    _avg: CrowdAvgAggregateOutputType | null
    _sum: CrowdSumAggregateOutputType | null
    _min: CrowdMinAggregateOutputType | null
    _max: CrowdMaxAggregateOutputType | null
  }

  type GetCrowdGroupByPayload<T extends CrowdGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CrowdGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CrowdGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CrowdGroupByOutputType[P]>
            : GetScalarType<T[P], CrowdGroupByOutputType[P]>
        }
      >
    >


  export type CrowdSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    location?: boolean
    date?: boolean
    hourlyData?: boolean
    seasonalFactor?: boolean
    bestTimeToVisit?: boolean
    avgWaitTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["crowd"]>

  export type CrowdSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    location?: boolean
    date?: boolean
    hourlyData?: boolean
    seasonalFactor?: boolean
    bestTimeToVisit?: boolean
    avgWaitTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["crowd"]>

  export type CrowdSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    location?: boolean
    date?: boolean
    hourlyData?: boolean
    seasonalFactor?: boolean
    bestTimeToVisit?: boolean
    avgWaitTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["crowd"]>

  export type CrowdSelectScalar = {
    id?: boolean
    location?: boolean
    date?: boolean
    hourlyData?: boolean
    seasonalFactor?: boolean
    bestTimeToVisit?: boolean
    avgWaitTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CrowdOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "location" | "date" | "hourlyData" | "seasonalFactor" | "bestTimeToVisit" | "avgWaitTime" | "createdAt" | "updatedAt", ExtArgs["result"]["crowd"]>

  export type $CrowdPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Crowd"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      location: string
      date: string
      hourlyData: string
      seasonalFactor: string
      bestTimeToVisit: string | null
      avgWaitTime: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["crowd"]>
    composites: {}
  }

  type CrowdGetPayload<S extends boolean | null | undefined | CrowdDefaultArgs> = $Result.GetResult<Prisma.$CrowdPayload, S>

  type CrowdCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CrowdFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CrowdCountAggregateInputType | true
    }

  export interface CrowdDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Crowd'], meta: { name: 'Crowd' } }
    /**
     * Find zero or one Crowd that matches the filter.
     * @param {CrowdFindUniqueArgs} args - Arguments to find a Crowd
     * @example
     * // Get one Crowd
     * const crowd = await prisma.crowd.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CrowdFindUniqueArgs>(args: SelectSubset<T, CrowdFindUniqueArgs<ExtArgs>>): Prisma__CrowdClient<$Result.GetResult<Prisma.$CrowdPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Crowd that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CrowdFindUniqueOrThrowArgs} args - Arguments to find a Crowd
     * @example
     * // Get one Crowd
     * const crowd = await prisma.crowd.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CrowdFindUniqueOrThrowArgs>(args: SelectSubset<T, CrowdFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CrowdClient<$Result.GetResult<Prisma.$CrowdPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Crowd that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrowdFindFirstArgs} args - Arguments to find a Crowd
     * @example
     * // Get one Crowd
     * const crowd = await prisma.crowd.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CrowdFindFirstArgs>(args?: SelectSubset<T, CrowdFindFirstArgs<ExtArgs>>): Prisma__CrowdClient<$Result.GetResult<Prisma.$CrowdPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Crowd that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrowdFindFirstOrThrowArgs} args - Arguments to find a Crowd
     * @example
     * // Get one Crowd
     * const crowd = await prisma.crowd.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CrowdFindFirstOrThrowArgs>(args?: SelectSubset<T, CrowdFindFirstOrThrowArgs<ExtArgs>>): Prisma__CrowdClient<$Result.GetResult<Prisma.$CrowdPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Crowds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrowdFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Crowds
     * const crowds = await prisma.crowd.findMany()
     * 
     * // Get first 10 Crowds
     * const crowds = await prisma.crowd.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const crowdWithIdOnly = await prisma.crowd.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CrowdFindManyArgs>(args?: SelectSubset<T, CrowdFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrowdPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Crowd.
     * @param {CrowdCreateArgs} args - Arguments to create a Crowd.
     * @example
     * // Create one Crowd
     * const Crowd = await prisma.crowd.create({
     *   data: {
     *     // ... data to create a Crowd
     *   }
     * })
     * 
     */
    create<T extends CrowdCreateArgs>(args: SelectSubset<T, CrowdCreateArgs<ExtArgs>>): Prisma__CrowdClient<$Result.GetResult<Prisma.$CrowdPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Crowds.
     * @param {CrowdCreateManyArgs} args - Arguments to create many Crowds.
     * @example
     * // Create many Crowds
     * const crowd = await prisma.crowd.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CrowdCreateManyArgs>(args?: SelectSubset<T, CrowdCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Crowds and returns the data saved in the database.
     * @param {CrowdCreateManyAndReturnArgs} args - Arguments to create many Crowds.
     * @example
     * // Create many Crowds
     * const crowd = await prisma.crowd.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Crowds and only return the `id`
     * const crowdWithIdOnly = await prisma.crowd.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CrowdCreateManyAndReturnArgs>(args?: SelectSubset<T, CrowdCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrowdPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Crowd.
     * @param {CrowdDeleteArgs} args - Arguments to delete one Crowd.
     * @example
     * // Delete one Crowd
     * const Crowd = await prisma.crowd.delete({
     *   where: {
     *     // ... filter to delete one Crowd
     *   }
     * })
     * 
     */
    delete<T extends CrowdDeleteArgs>(args: SelectSubset<T, CrowdDeleteArgs<ExtArgs>>): Prisma__CrowdClient<$Result.GetResult<Prisma.$CrowdPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Crowd.
     * @param {CrowdUpdateArgs} args - Arguments to update one Crowd.
     * @example
     * // Update one Crowd
     * const crowd = await prisma.crowd.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CrowdUpdateArgs>(args: SelectSubset<T, CrowdUpdateArgs<ExtArgs>>): Prisma__CrowdClient<$Result.GetResult<Prisma.$CrowdPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Crowds.
     * @param {CrowdDeleteManyArgs} args - Arguments to filter Crowds to delete.
     * @example
     * // Delete a few Crowds
     * const { count } = await prisma.crowd.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CrowdDeleteManyArgs>(args?: SelectSubset<T, CrowdDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Crowds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrowdUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Crowds
     * const crowd = await prisma.crowd.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CrowdUpdateManyArgs>(args: SelectSubset<T, CrowdUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Crowds and returns the data updated in the database.
     * @param {CrowdUpdateManyAndReturnArgs} args - Arguments to update many Crowds.
     * @example
     * // Update many Crowds
     * const crowd = await prisma.crowd.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Crowds and only return the `id`
     * const crowdWithIdOnly = await prisma.crowd.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CrowdUpdateManyAndReturnArgs>(args: SelectSubset<T, CrowdUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrowdPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Crowd.
     * @param {CrowdUpsertArgs} args - Arguments to update or create a Crowd.
     * @example
     * // Update or create a Crowd
     * const crowd = await prisma.crowd.upsert({
     *   create: {
     *     // ... data to create a Crowd
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Crowd we want to update
     *   }
     * })
     */
    upsert<T extends CrowdUpsertArgs>(args: SelectSubset<T, CrowdUpsertArgs<ExtArgs>>): Prisma__CrowdClient<$Result.GetResult<Prisma.$CrowdPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Crowds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrowdCountArgs} args - Arguments to filter Crowds to count.
     * @example
     * // Count the number of Crowds
     * const count = await prisma.crowd.count({
     *   where: {
     *     // ... the filter for the Crowds we want to count
     *   }
     * })
    **/
    count<T extends CrowdCountArgs>(
      args?: Subset<T, CrowdCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CrowdCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Crowd.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrowdAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CrowdAggregateArgs>(args: Subset<T, CrowdAggregateArgs>): Prisma.PrismaPromise<GetCrowdAggregateType<T>>

    /**
     * Group by Crowd.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrowdGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CrowdGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CrowdGroupByArgs['orderBy'] }
        : { orderBy?: CrowdGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CrowdGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCrowdGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Crowd model
   */
  readonly fields: CrowdFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Crowd.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CrowdClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Crowd model
   */
  interface CrowdFieldRefs {
    readonly id: FieldRef<"Crowd", 'String'>
    readonly location: FieldRef<"Crowd", 'String'>
    readonly date: FieldRef<"Crowd", 'String'>
    readonly hourlyData: FieldRef<"Crowd", 'String'>
    readonly seasonalFactor: FieldRef<"Crowd", 'String'>
    readonly bestTimeToVisit: FieldRef<"Crowd", 'String'>
    readonly avgWaitTime: FieldRef<"Crowd", 'Int'>
    readonly createdAt: FieldRef<"Crowd", 'DateTime'>
    readonly updatedAt: FieldRef<"Crowd", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Crowd findUnique
   */
  export type CrowdFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crowd
     */
    select?: CrowdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Crowd
     */
    omit?: CrowdOmit<ExtArgs> | null
    /**
     * Filter, which Crowd to fetch.
     */
    where: CrowdWhereUniqueInput
  }

  /**
   * Crowd findUniqueOrThrow
   */
  export type CrowdFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crowd
     */
    select?: CrowdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Crowd
     */
    omit?: CrowdOmit<ExtArgs> | null
    /**
     * Filter, which Crowd to fetch.
     */
    where: CrowdWhereUniqueInput
  }

  /**
   * Crowd findFirst
   */
  export type CrowdFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crowd
     */
    select?: CrowdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Crowd
     */
    omit?: CrowdOmit<ExtArgs> | null
    /**
     * Filter, which Crowd to fetch.
     */
    where?: CrowdWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Crowds to fetch.
     */
    orderBy?: CrowdOrderByWithRelationInput | CrowdOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Crowds.
     */
    cursor?: CrowdWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Crowds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Crowds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Crowds.
     */
    distinct?: CrowdScalarFieldEnum | CrowdScalarFieldEnum[]
  }

  /**
   * Crowd findFirstOrThrow
   */
  export type CrowdFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crowd
     */
    select?: CrowdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Crowd
     */
    omit?: CrowdOmit<ExtArgs> | null
    /**
     * Filter, which Crowd to fetch.
     */
    where?: CrowdWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Crowds to fetch.
     */
    orderBy?: CrowdOrderByWithRelationInput | CrowdOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Crowds.
     */
    cursor?: CrowdWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Crowds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Crowds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Crowds.
     */
    distinct?: CrowdScalarFieldEnum | CrowdScalarFieldEnum[]
  }

  /**
   * Crowd findMany
   */
  export type CrowdFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crowd
     */
    select?: CrowdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Crowd
     */
    omit?: CrowdOmit<ExtArgs> | null
    /**
     * Filter, which Crowds to fetch.
     */
    where?: CrowdWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Crowds to fetch.
     */
    orderBy?: CrowdOrderByWithRelationInput | CrowdOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Crowds.
     */
    cursor?: CrowdWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Crowds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Crowds.
     */
    skip?: number
    distinct?: CrowdScalarFieldEnum | CrowdScalarFieldEnum[]
  }

  /**
   * Crowd create
   */
  export type CrowdCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crowd
     */
    select?: CrowdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Crowd
     */
    omit?: CrowdOmit<ExtArgs> | null
    /**
     * The data needed to create a Crowd.
     */
    data: XOR<CrowdCreateInput, CrowdUncheckedCreateInput>
  }

  /**
   * Crowd createMany
   */
  export type CrowdCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Crowds.
     */
    data: CrowdCreateManyInput | CrowdCreateManyInput[]
  }

  /**
   * Crowd createManyAndReturn
   */
  export type CrowdCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crowd
     */
    select?: CrowdSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Crowd
     */
    omit?: CrowdOmit<ExtArgs> | null
    /**
     * The data used to create many Crowds.
     */
    data: CrowdCreateManyInput | CrowdCreateManyInput[]
  }

  /**
   * Crowd update
   */
  export type CrowdUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crowd
     */
    select?: CrowdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Crowd
     */
    omit?: CrowdOmit<ExtArgs> | null
    /**
     * The data needed to update a Crowd.
     */
    data: XOR<CrowdUpdateInput, CrowdUncheckedUpdateInput>
    /**
     * Choose, which Crowd to update.
     */
    where: CrowdWhereUniqueInput
  }

  /**
   * Crowd updateMany
   */
  export type CrowdUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Crowds.
     */
    data: XOR<CrowdUpdateManyMutationInput, CrowdUncheckedUpdateManyInput>
    /**
     * Filter which Crowds to update
     */
    where?: CrowdWhereInput
    /**
     * Limit how many Crowds to update.
     */
    limit?: number
  }

  /**
   * Crowd updateManyAndReturn
   */
  export type CrowdUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crowd
     */
    select?: CrowdSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Crowd
     */
    omit?: CrowdOmit<ExtArgs> | null
    /**
     * The data used to update Crowds.
     */
    data: XOR<CrowdUpdateManyMutationInput, CrowdUncheckedUpdateManyInput>
    /**
     * Filter which Crowds to update
     */
    where?: CrowdWhereInput
    /**
     * Limit how many Crowds to update.
     */
    limit?: number
  }

  /**
   * Crowd upsert
   */
  export type CrowdUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crowd
     */
    select?: CrowdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Crowd
     */
    omit?: CrowdOmit<ExtArgs> | null
    /**
     * The filter to search for the Crowd to update in case it exists.
     */
    where: CrowdWhereUniqueInput
    /**
     * In case the Crowd found by the `where` argument doesn't exist, create a new Crowd with this data.
     */
    create: XOR<CrowdCreateInput, CrowdUncheckedCreateInput>
    /**
     * In case the Crowd was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CrowdUpdateInput, CrowdUncheckedUpdateInput>
  }

  /**
   * Crowd delete
   */
  export type CrowdDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crowd
     */
    select?: CrowdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Crowd
     */
    omit?: CrowdOmit<ExtArgs> | null
    /**
     * Filter which Crowd to delete.
     */
    where: CrowdWhereUniqueInput
  }

  /**
   * Crowd deleteMany
   */
  export type CrowdDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Crowds to delete
     */
    where?: CrowdWhereInput
    /**
     * Limit how many Crowds to delete.
     */
    limit?: number
  }

  /**
   * Crowd without action
   */
  export type CrowdDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crowd
     */
    select?: CrowdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Crowd
     */
    omit?: CrowdOmit<ExtArgs> | null
  }


  /**
   * Model Currency
   */

  export type AggregateCurrency = {
    _count: CurrencyCountAggregateOutputType | null
    _min: CurrencyMinAggregateOutputType | null
    _max: CurrencyMaxAggregateOutputType | null
  }

  export type CurrencyMinAggregateOutputType = {
    id: string | null
    date: string | null
    baseCurrency: string | null
    rates: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CurrencyMaxAggregateOutputType = {
    id: string | null
    date: string | null
    baseCurrency: string | null
    rates: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CurrencyCountAggregateOutputType = {
    id: number
    date: number
    baseCurrency: number
    rates: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CurrencyMinAggregateInputType = {
    id?: true
    date?: true
    baseCurrency?: true
    rates?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CurrencyMaxAggregateInputType = {
    id?: true
    date?: true
    baseCurrency?: true
    rates?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CurrencyCountAggregateInputType = {
    id?: true
    date?: true
    baseCurrency?: true
    rates?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CurrencyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Currency to aggregate.
     */
    where?: CurrencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Currencies to fetch.
     */
    orderBy?: CurrencyOrderByWithRelationInput | CurrencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CurrencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Currencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Currencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Currencies
    **/
    _count?: true | CurrencyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CurrencyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CurrencyMaxAggregateInputType
  }

  export type GetCurrencyAggregateType<T extends CurrencyAggregateArgs> = {
        [P in keyof T & keyof AggregateCurrency]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCurrency[P]>
      : GetScalarType<T[P], AggregateCurrency[P]>
  }




  export type CurrencyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CurrencyWhereInput
    orderBy?: CurrencyOrderByWithAggregationInput | CurrencyOrderByWithAggregationInput[]
    by: CurrencyScalarFieldEnum[] | CurrencyScalarFieldEnum
    having?: CurrencyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CurrencyCountAggregateInputType | true
    _min?: CurrencyMinAggregateInputType
    _max?: CurrencyMaxAggregateInputType
  }

  export type CurrencyGroupByOutputType = {
    id: string
    date: string
    baseCurrency: string
    rates: string
    createdAt: Date
    updatedAt: Date
    _count: CurrencyCountAggregateOutputType | null
    _min: CurrencyMinAggregateOutputType | null
    _max: CurrencyMaxAggregateOutputType | null
  }

  type GetCurrencyGroupByPayload<T extends CurrencyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CurrencyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CurrencyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CurrencyGroupByOutputType[P]>
            : GetScalarType<T[P], CurrencyGroupByOutputType[P]>
        }
      >
    >


  export type CurrencySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    baseCurrency?: boolean
    rates?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["currency"]>

  export type CurrencySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    baseCurrency?: boolean
    rates?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["currency"]>

  export type CurrencySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    baseCurrency?: boolean
    rates?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["currency"]>

  export type CurrencySelectScalar = {
    id?: boolean
    date?: boolean
    baseCurrency?: boolean
    rates?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CurrencyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date" | "baseCurrency" | "rates" | "createdAt" | "updatedAt", ExtArgs["result"]["currency"]>

  export type $CurrencyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Currency"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      date: string
      baseCurrency: string
      rates: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["currency"]>
    composites: {}
  }

  type CurrencyGetPayload<S extends boolean | null | undefined | CurrencyDefaultArgs> = $Result.GetResult<Prisma.$CurrencyPayload, S>

  type CurrencyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CurrencyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CurrencyCountAggregateInputType | true
    }

  export interface CurrencyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Currency'], meta: { name: 'Currency' } }
    /**
     * Find zero or one Currency that matches the filter.
     * @param {CurrencyFindUniqueArgs} args - Arguments to find a Currency
     * @example
     * // Get one Currency
     * const currency = await prisma.currency.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CurrencyFindUniqueArgs>(args: SelectSubset<T, CurrencyFindUniqueArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Currency that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CurrencyFindUniqueOrThrowArgs} args - Arguments to find a Currency
     * @example
     * // Get one Currency
     * const currency = await prisma.currency.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CurrencyFindUniqueOrThrowArgs>(args: SelectSubset<T, CurrencyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Currency that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyFindFirstArgs} args - Arguments to find a Currency
     * @example
     * // Get one Currency
     * const currency = await prisma.currency.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CurrencyFindFirstArgs>(args?: SelectSubset<T, CurrencyFindFirstArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Currency that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyFindFirstOrThrowArgs} args - Arguments to find a Currency
     * @example
     * // Get one Currency
     * const currency = await prisma.currency.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CurrencyFindFirstOrThrowArgs>(args?: SelectSubset<T, CurrencyFindFirstOrThrowArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Currencies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Currencies
     * const currencies = await prisma.currency.findMany()
     * 
     * // Get first 10 Currencies
     * const currencies = await prisma.currency.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const currencyWithIdOnly = await prisma.currency.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CurrencyFindManyArgs>(args?: SelectSubset<T, CurrencyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Currency.
     * @param {CurrencyCreateArgs} args - Arguments to create a Currency.
     * @example
     * // Create one Currency
     * const Currency = await prisma.currency.create({
     *   data: {
     *     // ... data to create a Currency
     *   }
     * })
     * 
     */
    create<T extends CurrencyCreateArgs>(args: SelectSubset<T, CurrencyCreateArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Currencies.
     * @param {CurrencyCreateManyArgs} args - Arguments to create many Currencies.
     * @example
     * // Create many Currencies
     * const currency = await prisma.currency.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CurrencyCreateManyArgs>(args?: SelectSubset<T, CurrencyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Currencies and returns the data saved in the database.
     * @param {CurrencyCreateManyAndReturnArgs} args - Arguments to create many Currencies.
     * @example
     * // Create many Currencies
     * const currency = await prisma.currency.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Currencies and only return the `id`
     * const currencyWithIdOnly = await prisma.currency.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CurrencyCreateManyAndReturnArgs>(args?: SelectSubset<T, CurrencyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Currency.
     * @param {CurrencyDeleteArgs} args - Arguments to delete one Currency.
     * @example
     * // Delete one Currency
     * const Currency = await prisma.currency.delete({
     *   where: {
     *     // ... filter to delete one Currency
     *   }
     * })
     * 
     */
    delete<T extends CurrencyDeleteArgs>(args: SelectSubset<T, CurrencyDeleteArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Currency.
     * @param {CurrencyUpdateArgs} args - Arguments to update one Currency.
     * @example
     * // Update one Currency
     * const currency = await prisma.currency.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CurrencyUpdateArgs>(args: SelectSubset<T, CurrencyUpdateArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Currencies.
     * @param {CurrencyDeleteManyArgs} args - Arguments to filter Currencies to delete.
     * @example
     * // Delete a few Currencies
     * const { count } = await prisma.currency.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CurrencyDeleteManyArgs>(args?: SelectSubset<T, CurrencyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Currencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Currencies
     * const currency = await prisma.currency.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CurrencyUpdateManyArgs>(args: SelectSubset<T, CurrencyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Currencies and returns the data updated in the database.
     * @param {CurrencyUpdateManyAndReturnArgs} args - Arguments to update many Currencies.
     * @example
     * // Update many Currencies
     * const currency = await prisma.currency.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Currencies and only return the `id`
     * const currencyWithIdOnly = await prisma.currency.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CurrencyUpdateManyAndReturnArgs>(args: SelectSubset<T, CurrencyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Currency.
     * @param {CurrencyUpsertArgs} args - Arguments to update or create a Currency.
     * @example
     * // Update or create a Currency
     * const currency = await prisma.currency.upsert({
     *   create: {
     *     // ... data to create a Currency
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Currency we want to update
     *   }
     * })
     */
    upsert<T extends CurrencyUpsertArgs>(args: SelectSubset<T, CurrencyUpsertArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Currencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyCountArgs} args - Arguments to filter Currencies to count.
     * @example
     * // Count the number of Currencies
     * const count = await prisma.currency.count({
     *   where: {
     *     // ... the filter for the Currencies we want to count
     *   }
     * })
    **/
    count<T extends CurrencyCountArgs>(
      args?: Subset<T, CurrencyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CurrencyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Currency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CurrencyAggregateArgs>(args: Subset<T, CurrencyAggregateArgs>): Prisma.PrismaPromise<GetCurrencyAggregateType<T>>

    /**
     * Group by Currency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CurrencyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CurrencyGroupByArgs['orderBy'] }
        : { orderBy?: CurrencyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CurrencyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCurrencyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Currency model
   */
  readonly fields: CurrencyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Currency.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CurrencyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Currency model
   */
  interface CurrencyFieldRefs {
    readonly id: FieldRef<"Currency", 'String'>
    readonly date: FieldRef<"Currency", 'String'>
    readonly baseCurrency: FieldRef<"Currency", 'String'>
    readonly rates: FieldRef<"Currency", 'String'>
    readonly createdAt: FieldRef<"Currency", 'DateTime'>
    readonly updatedAt: FieldRef<"Currency", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Currency findUnique
   */
  export type CurrencyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Filter, which Currency to fetch.
     */
    where: CurrencyWhereUniqueInput
  }

  /**
   * Currency findUniqueOrThrow
   */
  export type CurrencyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Filter, which Currency to fetch.
     */
    where: CurrencyWhereUniqueInput
  }

  /**
   * Currency findFirst
   */
  export type CurrencyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Filter, which Currency to fetch.
     */
    where?: CurrencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Currencies to fetch.
     */
    orderBy?: CurrencyOrderByWithRelationInput | CurrencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Currencies.
     */
    cursor?: CurrencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Currencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Currencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Currencies.
     */
    distinct?: CurrencyScalarFieldEnum | CurrencyScalarFieldEnum[]
  }

  /**
   * Currency findFirstOrThrow
   */
  export type CurrencyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Filter, which Currency to fetch.
     */
    where?: CurrencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Currencies to fetch.
     */
    orderBy?: CurrencyOrderByWithRelationInput | CurrencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Currencies.
     */
    cursor?: CurrencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Currencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Currencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Currencies.
     */
    distinct?: CurrencyScalarFieldEnum | CurrencyScalarFieldEnum[]
  }

  /**
   * Currency findMany
   */
  export type CurrencyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Filter, which Currencies to fetch.
     */
    where?: CurrencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Currencies to fetch.
     */
    orderBy?: CurrencyOrderByWithRelationInput | CurrencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Currencies.
     */
    cursor?: CurrencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Currencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Currencies.
     */
    skip?: number
    distinct?: CurrencyScalarFieldEnum | CurrencyScalarFieldEnum[]
  }

  /**
   * Currency create
   */
  export type CurrencyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * The data needed to create a Currency.
     */
    data: XOR<CurrencyCreateInput, CurrencyUncheckedCreateInput>
  }

  /**
   * Currency createMany
   */
  export type CurrencyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Currencies.
     */
    data: CurrencyCreateManyInput | CurrencyCreateManyInput[]
  }

  /**
   * Currency createManyAndReturn
   */
  export type CurrencyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * The data used to create many Currencies.
     */
    data: CurrencyCreateManyInput | CurrencyCreateManyInput[]
  }

  /**
   * Currency update
   */
  export type CurrencyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * The data needed to update a Currency.
     */
    data: XOR<CurrencyUpdateInput, CurrencyUncheckedUpdateInput>
    /**
     * Choose, which Currency to update.
     */
    where: CurrencyWhereUniqueInput
  }

  /**
   * Currency updateMany
   */
  export type CurrencyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Currencies.
     */
    data: XOR<CurrencyUpdateManyMutationInput, CurrencyUncheckedUpdateManyInput>
    /**
     * Filter which Currencies to update
     */
    where?: CurrencyWhereInput
    /**
     * Limit how many Currencies to update.
     */
    limit?: number
  }

  /**
   * Currency updateManyAndReturn
   */
  export type CurrencyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * The data used to update Currencies.
     */
    data: XOR<CurrencyUpdateManyMutationInput, CurrencyUncheckedUpdateManyInput>
    /**
     * Filter which Currencies to update
     */
    where?: CurrencyWhereInput
    /**
     * Limit how many Currencies to update.
     */
    limit?: number
  }

  /**
   * Currency upsert
   */
  export type CurrencyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * The filter to search for the Currency to update in case it exists.
     */
    where: CurrencyWhereUniqueInput
    /**
     * In case the Currency found by the `where` argument doesn't exist, create a new Currency with this data.
     */
    create: XOR<CurrencyCreateInput, CurrencyUncheckedCreateInput>
    /**
     * In case the Currency was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CurrencyUpdateInput, CurrencyUncheckedUpdateInput>
  }

  /**
   * Currency delete
   */
  export type CurrencyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Filter which Currency to delete.
     */
    where: CurrencyWhereUniqueInput
  }

  /**
   * Currency deleteMany
   */
  export type CurrencyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Currencies to delete
     */
    where?: CurrencyWhereInput
    /**
     * Limit how many Currencies to delete.
     */
    limit?: number
  }

  /**
   * Currency without action
   */
  export type CurrencyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    passwordHash: 'passwordHash',
    fullName: 'fullName',
    profilePhotoUrl: 'profilePhotoUrl',
    preferredLanguage: 'preferredLanguage',
    preferredCurrency: 'preferredCurrency',
    emailVerified: 'emailVerified',
    isActive: 'isActive',
    lastLoginAt: 'lastLoginAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const RoleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    permissions: 'permissions',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const UserRoleScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    roleId: 'roleId',
    assignedAt: 'assignedAt'
  };

  export type UserRoleScalarFieldEnum = (typeof UserRoleScalarFieldEnum)[keyof typeof UserRoleScalarFieldEnum]


  export const CityScalarFieldEnum: {
    id: 'id',
    name: 'name',
    country: 'country',
    countryCode: 'countryCode',
    region: 'region',
    latitude: 'latitude',
    longitude: 'longitude',
    timezone: 'timezone',
    costIndex: 'costIndex',
    popularityScore: 'popularityScore',
    description: 'description',
    imageUrl: 'imageUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type CityScalarFieldEnum = (typeof CityScalarFieldEnum)[keyof typeof CityScalarFieldEnum]


  export const ActivityScalarFieldEnum: {
    id: 'id',
    cityId: 'cityId',
    name: 'name',
    category: 'category',
    description: 'description',
    estimatedCost: 'estimatedCost',
    currency: 'currency',
    durationMinutes: 'durationMinutes',
    imageUrl: 'imageUrl',
    rating: 'rating',
    popularityScore: 'popularityScore',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type ActivityScalarFieldEnum = (typeof ActivityScalarFieldEnum)[keyof typeof ActivityScalarFieldEnum]


  export const HotelScalarFieldEnum: {
    id: 'id',
    cityId: 'cityId',
    name: 'name',
    category: 'category',
    description: 'description',
    pricePerNight: 'pricePerNight',
    currency: 'currency',
    rating: 'rating',
    amenities: 'amenities',
    address: 'address',
    imageUrl: 'imageUrl',
    contactPhone: 'contactPhone',
    website: 'website',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type HotelScalarFieldEnum = (typeof HotelScalarFieldEnum)[keyof typeof HotelScalarFieldEnum]


  export const RestaurantScalarFieldEnum: {
    id: 'id',
    cityId: 'cityId',
    name: 'name',
    cuisineType: 'cuisineType',
    priceRange: 'priceRange',
    avgMealCost: 'avgMealCost',
    currency: 'currency',
    rating: 'rating',
    description: 'description',
    address: 'address',
    imageUrl: 'imageUrl',
    isVegetarian: 'isVegetarian',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type RestaurantScalarFieldEnum = (typeof RestaurantScalarFieldEnum)[keyof typeof RestaurantScalarFieldEnum]


  export const TransportScalarFieldEnum: {
    id: 'id',
    fromCityId: 'fromCityId',
    toCityId: 'toCityId',
    transportType: 'transportType',
    operatorName: 'operatorName',
    departureTime: 'departureTime',
    arrivalTime: 'arrivalTime',
    durationMinutes: 'durationMinutes',
    price: 'price',
    currency: 'currency',
    classType: 'classType',
    frequency: 'frequency',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type TransportScalarFieldEnum = (typeof TransportScalarFieldEnum)[keyof typeof TransportScalarFieldEnum]


  export const TripScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    description: 'description',
    startDate: 'startDate',
    endDate: 'endDate',
    coverPhotoUrl: 'coverPhotoUrl',
    status: 'status',
    isPublic: 'isPublic',
    totalEstimatedCost: 'totalEstimatedCost',
    currency: 'currency',
    travelStyle: 'travelStyle',
    versionNumber: 'versionNumber',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type TripScalarFieldEnum = (typeof TripScalarFieldEnum)[keyof typeof TripScalarFieldEnum]


  export const TripStopScalarFieldEnum: {
    id: 'id',
    tripId: 'tripId',
    cityId: 'cityId',
    stopOrder: 'stopOrder',
    arrivalDate: 'arrivalDate',
    departureDate: 'departureDate',
    accommodationName: 'accommodationName',
    accommodationCost: 'accommodationCost',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type TripStopScalarFieldEnum = (typeof TripStopScalarFieldEnum)[keyof typeof TripStopScalarFieldEnum]


  export const StopActivityScalarFieldEnum: {
    id: 'id',
    tripStopId: 'tripStopId',
    activityId: 'activityId',
    scheduledDate: 'scheduledDate',
    scheduledTime: 'scheduledTime',
    actualCost: 'actualCost',
    notes: 'notes',
    isCompleted: 'isCompleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type StopActivityScalarFieldEnum = (typeof StopActivityScalarFieldEnum)[keyof typeof StopActivityScalarFieldEnum]


  export const TripBudgetScalarFieldEnum: {
    id: 'id',
    tripId: 'tripId',
    category: 'category',
    estimatedAmount: 'estimatedAmount',
    actualAmount: 'actualAmount',
    currency: 'currency',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type TripBudgetScalarFieldEnum = (typeof TripBudgetScalarFieldEnum)[keyof typeof TripBudgetScalarFieldEnum]


  export const TripMediaScalarFieldEnum: {
    id: 'id',
    tripId: 'tripId',
    mediaType: 'mediaType',
    mediaUrl: 'mediaUrl',
    thumbnailUrl: 'thumbnailUrl',
    caption: 'caption',
    displayOrder: 'displayOrder',
    uploadedAt: 'uploadedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type TripMediaScalarFieldEnum = (typeof TripMediaScalarFieldEnum)[keyof typeof TripMediaScalarFieldEnum]


  export const TripShareScalarFieldEnum: {
    id: 'id',
    tripId: 'tripId',
    shareToken: 'shareToken',
    shareType: 'shareType',
    sharedWithEmail: 'sharedWithEmail',
    viewCount: 'viewCount',
    lastViewedAt: 'lastViewedAt',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type TripShareScalarFieldEnum = (typeof TripShareScalarFieldEnum)[keyof typeof TripShareScalarFieldEnum]


  export const TripVersionScalarFieldEnum: {
    id: 'id',
    tripId: 'tripId',
    versionNumber: 'versionNumber',
    snapshotData: 'snapshotData',
    changeSummary: 'changeSummary',
    createdBy: 'createdBy',
    createdAt: 'createdAt'
  };

  export type TripVersionScalarFieldEnum = (typeof TripVersionScalarFieldEnum)[keyof typeof TripVersionScalarFieldEnum]


  export const UserSavedDestinationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    cityId: 'cityId',
    notes: 'notes',
    savedAt: 'savedAt'
  };

  export type UserSavedDestinationScalarFieldEnum = (typeof UserSavedDestinationScalarFieldEnum)[keyof typeof UserSavedDestinationScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    action: 'action',
    entityType: 'entityType',
    entityId: 'entityId',
    changes: 'changes',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const WeatherScalarFieldEnum: {
    id: 'id',
    cityId: 'cityId',
    city: 'city',
    date: 'date',
    current: 'current',
    forecast: 'forecast',
    hourlyForecast: 'hourlyForecast',
    recommendation: 'recommendation',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WeatherScalarFieldEnum = (typeof WeatherScalarFieldEnum)[keyof typeof WeatherScalarFieldEnum]


  export const GuideScalarFieldEnum: {
    id: 'id',
    cityId: 'cityId',
    name: 'name',
    specialization: 'specialization',
    city: 'city',
    languages: 'languages',
    certification: 'certification',
    yearsOfExperience: 'yearsOfExperience',
    rating: 'rating',
    reviews: 'reviews',
    pricePerDay: 'pricePerDay',
    availability: 'availability',
    groupSize: 'groupSize',
    skills: 'skills',
    tours: 'tours',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GuideScalarFieldEnum = (typeof GuideScalarFieldEnum)[keyof typeof GuideScalarFieldEnum]


  export const EventScalarFieldEnum: {
    id: 'id',
    name: 'name',
    city: 'city',
    country: 'country',
    startDate: 'startDate',
    endDate: 'endDate',
    description: 'description',
    category: 'category',
    expectedCrowd: 'expectedCrowd',
    entryFee: 'entryFee',
    highlights: 'highlights',
    bestLocations: 'bestLocations',
    tips: 'tips',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EventScalarFieldEnum = (typeof EventScalarFieldEnum)[keyof typeof EventScalarFieldEnum]


  export const CostOfLivingScalarFieldEnum: {
    id: 'id',
    city: 'city',
    country: 'country',
    category: 'category',
    dailyCost: 'dailyCost',
    weeklyTotalEstimate: 'weeklyTotalEstimate',
    monthlyTotalEstimate: 'monthlyTotalEstimate',
    costBreakdown: 'costBreakdown',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CostOfLivingScalarFieldEnum = (typeof CostOfLivingScalarFieldEnum)[keyof typeof CostOfLivingScalarFieldEnum]


  export const CrowdScalarFieldEnum: {
    id: 'id',
    location: 'location',
    date: 'date',
    hourlyData: 'hourlyData',
    seasonalFactor: 'seasonalFactor',
    bestTimeToVisit: 'bestTimeToVisit',
    avgWaitTime: 'avgWaitTime',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CrowdScalarFieldEnum = (typeof CrowdScalarFieldEnum)[keyof typeof CrowdScalarFieldEnum]


  export const CurrencyScalarFieldEnum: {
    id: 'id',
    date: 'date',
    baseCurrency: 'baseCurrency',
    rates: 'rates',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CurrencyScalarFieldEnum = (typeof CurrencyScalarFieldEnum)[keyof typeof CurrencyScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    fullName?: StringFilter<"User"> | string
    profilePhotoUrl?: StringNullableFilter<"User"> | string | null
    preferredLanguage?: StringFilter<"User"> | string
    preferredCurrency?: StringFilter<"User"> | string
    emailVerified?: BoolFilter<"User"> | boolean
    isActive?: BoolFilter<"User"> | boolean
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    deletedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    trips?: TripListRelationFilter
    savedDestinations?: UserSavedDestinationListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    userRoles?: UserRoleListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    fullName?: SortOrder
    profilePhotoUrl?: SortOrderInput | SortOrder
    preferredLanguage?: SortOrder
    preferredCurrency?: SortOrder
    emailVerified?: SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    trips?: TripOrderByRelationAggregateInput
    savedDestinations?: UserSavedDestinationOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    userRoles?: UserRoleOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    passwordHash?: StringFilter<"User"> | string
    fullName?: StringFilter<"User"> | string
    profilePhotoUrl?: StringNullableFilter<"User"> | string | null
    preferredLanguage?: StringFilter<"User"> | string
    preferredCurrency?: StringFilter<"User"> | string
    emailVerified?: BoolFilter<"User"> | boolean
    isActive?: BoolFilter<"User"> | boolean
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    deletedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    trips?: TripListRelationFilter
    savedDestinations?: UserSavedDestinationListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    userRoles?: UserRoleListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    fullName?: SortOrder
    profilePhotoUrl?: SortOrderInput | SortOrder
    preferredLanguage?: SortOrder
    preferredCurrency?: SortOrder
    emailVerified?: SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    fullName?: StringWithAggregatesFilter<"User"> | string
    profilePhotoUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    preferredLanguage?: StringWithAggregatesFilter<"User"> | string
    preferredCurrency?: StringWithAggregatesFilter<"User"> | string
    emailVerified?: BoolWithAggregatesFilter<"User"> | boolean
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
  }

  export type RoleWhereInput = {
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    id?: StringFilter<"Role"> | string
    name?: StringFilter<"Role"> | string
    description?: StringNullableFilter<"Role"> | string | null
    permissions?: StringFilter<"Role"> | string
    createdAt?: DateTimeFilter<"Role"> | Date | string
    updatedAt?: DateTimeFilter<"Role"> | Date | string
    userRoles?: UserRoleListRelationFilter
  }

  export type RoleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    permissions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userRoles?: UserRoleOrderByRelationAggregateInput
  }

  export type RoleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    description?: StringNullableFilter<"Role"> | string | null
    permissions?: StringFilter<"Role"> | string
    createdAt?: DateTimeFilter<"Role"> | Date | string
    updatedAt?: DateTimeFilter<"Role"> | Date | string
    userRoles?: UserRoleListRelationFilter
  }, "id" | "name">

  export type RoleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    permissions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RoleCountOrderByAggregateInput
    _max?: RoleMaxOrderByAggregateInput
    _min?: RoleMinOrderByAggregateInput
  }

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    OR?: RoleScalarWhereWithAggregatesInput[]
    NOT?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Role"> | string
    name?: StringWithAggregatesFilter<"Role"> | string
    description?: StringNullableWithAggregatesFilter<"Role"> | string | null
    permissions?: StringWithAggregatesFilter<"Role"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Role"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Role"> | Date | string
  }

  export type UserRoleWhereInput = {
    AND?: UserRoleWhereInput | UserRoleWhereInput[]
    OR?: UserRoleWhereInput[]
    NOT?: UserRoleWhereInput | UserRoleWhereInput[]
    id?: StringFilter<"UserRole"> | string
    userId?: StringFilter<"UserRole"> | string
    roleId?: StringFilter<"UserRole"> | string
    assignedAt?: DateTimeFilter<"UserRole"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
  }

  export type UserRoleOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    assignedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    role?: RoleOrderByWithRelationInput
  }

  export type UserRoleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_roleId?: UserRoleUserIdRoleIdCompoundUniqueInput
    AND?: UserRoleWhereInput | UserRoleWhereInput[]
    OR?: UserRoleWhereInput[]
    NOT?: UserRoleWhereInput | UserRoleWhereInput[]
    userId?: StringFilter<"UserRole"> | string
    roleId?: StringFilter<"UserRole"> | string
    assignedAt?: DateTimeFilter<"UserRole"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
  }, "id" | "userId_roleId">

  export type UserRoleOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    assignedAt?: SortOrder
    _count?: UserRoleCountOrderByAggregateInput
    _max?: UserRoleMaxOrderByAggregateInput
    _min?: UserRoleMinOrderByAggregateInput
  }

  export type UserRoleScalarWhereWithAggregatesInput = {
    AND?: UserRoleScalarWhereWithAggregatesInput | UserRoleScalarWhereWithAggregatesInput[]
    OR?: UserRoleScalarWhereWithAggregatesInput[]
    NOT?: UserRoleScalarWhereWithAggregatesInput | UserRoleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserRole"> | string
    userId?: StringWithAggregatesFilter<"UserRole"> | string
    roleId?: StringWithAggregatesFilter<"UserRole"> | string
    assignedAt?: DateTimeWithAggregatesFilter<"UserRole"> | Date | string
  }

  export type CityWhereInput = {
    AND?: CityWhereInput | CityWhereInput[]
    OR?: CityWhereInput[]
    NOT?: CityWhereInput | CityWhereInput[]
    id?: StringFilter<"City"> | string
    name?: StringFilter<"City"> | string
    country?: StringFilter<"City"> | string
    countryCode?: StringFilter<"City"> | string
    region?: StringNullableFilter<"City"> | string | null
    latitude?: FloatFilter<"City"> | number
    longitude?: FloatFilter<"City"> | number
    timezone?: StringFilter<"City"> | string
    costIndex?: FloatFilter<"City"> | number
    popularityScore?: IntFilter<"City"> | number
    description?: StringNullableFilter<"City"> | string | null
    imageUrl?: StringNullableFilter<"City"> | string | null
    createdAt?: DateTimeFilter<"City"> | Date | string
    updatedAt?: DateTimeFilter<"City"> | Date | string
    deletedAt?: DateTimeNullableFilter<"City"> | Date | string | null
    activities?: ActivityListRelationFilter
    hotels?: HotelListRelationFilter
    restaurants?: RestaurantListRelationFilter
    transportFrom?: TransportListRelationFilter
    transportTo?: TransportListRelationFilter
    tripStops?: TripStopListRelationFilter
    savedDestinations?: UserSavedDestinationListRelationFilter
  }

  export type CityOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    country?: SortOrder
    countryCode?: SortOrder
    region?: SortOrderInput | SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    timezone?: SortOrder
    costIndex?: SortOrder
    popularityScore?: SortOrder
    description?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    activities?: ActivityOrderByRelationAggregateInput
    hotels?: HotelOrderByRelationAggregateInput
    restaurants?: RestaurantOrderByRelationAggregateInput
    transportFrom?: TransportOrderByRelationAggregateInput
    transportTo?: TransportOrderByRelationAggregateInput
    tripStops?: TripStopOrderByRelationAggregateInput
    savedDestinations?: UserSavedDestinationOrderByRelationAggregateInput
  }

  export type CityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name_country?: CityNameCountryCompoundUniqueInput
    AND?: CityWhereInput | CityWhereInput[]
    OR?: CityWhereInput[]
    NOT?: CityWhereInput | CityWhereInput[]
    name?: StringFilter<"City"> | string
    country?: StringFilter<"City"> | string
    countryCode?: StringFilter<"City"> | string
    region?: StringNullableFilter<"City"> | string | null
    latitude?: FloatFilter<"City"> | number
    longitude?: FloatFilter<"City"> | number
    timezone?: StringFilter<"City"> | string
    costIndex?: FloatFilter<"City"> | number
    popularityScore?: IntFilter<"City"> | number
    description?: StringNullableFilter<"City"> | string | null
    imageUrl?: StringNullableFilter<"City"> | string | null
    createdAt?: DateTimeFilter<"City"> | Date | string
    updatedAt?: DateTimeFilter<"City"> | Date | string
    deletedAt?: DateTimeNullableFilter<"City"> | Date | string | null
    activities?: ActivityListRelationFilter
    hotels?: HotelListRelationFilter
    restaurants?: RestaurantListRelationFilter
    transportFrom?: TransportListRelationFilter
    transportTo?: TransportListRelationFilter
    tripStops?: TripStopListRelationFilter
    savedDestinations?: UserSavedDestinationListRelationFilter
  }, "id" | "name_country">

  export type CityOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    country?: SortOrder
    countryCode?: SortOrder
    region?: SortOrderInput | SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    timezone?: SortOrder
    costIndex?: SortOrder
    popularityScore?: SortOrder
    description?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: CityCountOrderByAggregateInput
    _avg?: CityAvgOrderByAggregateInput
    _max?: CityMaxOrderByAggregateInput
    _min?: CityMinOrderByAggregateInput
    _sum?: CitySumOrderByAggregateInput
  }

  export type CityScalarWhereWithAggregatesInput = {
    AND?: CityScalarWhereWithAggregatesInput | CityScalarWhereWithAggregatesInput[]
    OR?: CityScalarWhereWithAggregatesInput[]
    NOT?: CityScalarWhereWithAggregatesInput | CityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"City"> | string
    name?: StringWithAggregatesFilter<"City"> | string
    country?: StringWithAggregatesFilter<"City"> | string
    countryCode?: StringWithAggregatesFilter<"City"> | string
    region?: StringNullableWithAggregatesFilter<"City"> | string | null
    latitude?: FloatWithAggregatesFilter<"City"> | number
    longitude?: FloatWithAggregatesFilter<"City"> | number
    timezone?: StringWithAggregatesFilter<"City"> | string
    costIndex?: FloatWithAggregatesFilter<"City"> | number
    popularityScore?: IntWithAggregatesFilter<"City"> | number
    description?: StringNullableWithAggregatesFilter<"City"> | string | null
    imageUrl?: StringNullableWithAggregatesFilter<"City"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"City"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"City"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"City"> | Date | string | null
  }

  export type ActivityWhereInput = {
    AND?: ActivityWhereInput | ActivityWhereInput[]
    OR?: ActivityWhereInput[]
    NOT?: ActivityWhereInput | ActivityWhereInput[]
    id?: StringFilter<"Activity"> | string
    cityId?: StringFilter<"Activity"> | string
    name?: StringFilter<"Activity"> | string
    category?: StringFilter<"Activity"> | string
    description?: StringNullableFilter<"Activity"> | string | null
    estimatedCost?: FloatFilter<"Activity"> | number
    currency?: StringFilter<"Activity"> | string
    durationMinutes?: IntNullableFilter<"Activity"> | number | null
    imageUrl?: StringNullableFilter<"Activity"> | string | null
    rating?: FloatNullableFilter<"Activity"> | number | null
    popularityScore?: IntFilter<"Activity"> | number
    createdAt?: DateTimeFilter<"Activity"> | Date | string
    updatedAt?: DateTimeFilter<"Activity"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Activity"> | Date | string | null
    city?: XOR<CityScalarRelationFilter, CityWhereInput>
    stopActivities?: StopActivityListRelationFilter
  }

  export type ActivityOrderByWithRelationInput = {
    id?: SortOrder
    cityId?: SortOrder
    name?: SortOrder
    category?: SortOrder
    description?: SortOrderInput | SortOrder
    estimatedCost?: SortOrder
    currency?: SortOrder
    durationMinutes?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    rating?: SortOrderInput | SortOrder
    popularityScore?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    city?: CityOrderByWithRelationInput
    stopActivities?: StopActivityOrderByRelationAggregateInput
  }

  export type ActivityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ActivityWhereInput | ActivityWhereInput[]
    OR?: ActivityWhereInput[]
    NOT?: ActivityWhereInput | ActivityWhereInput[]
    cityId?: StringFilter<"Activity"> | string
    name?: StringFilter<"Activity"> | string
    category?: StringFilter<"Activity"> | string
    description?: StringNullableFilter<"Activity"> | string | null
    estimatedCost?: FloatFilter<"Activity"> | number
    currency?: StringFilter<"Activity"> | string
    durationMinutes?: IntNullableFilter<"Activity"> | number | null
    imageUrl?: StringNullableFilter<"Activity"> | string | null
    rating?: FloatNullableFilter<"Activity"> | number | null
    popularityScore?: IntFilter<"Activity"> | number
    createdAt?: DateTimeFilter<"Activity"> | Date | string
    updatedAt?: DateTimeFilter<"Activity"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Activity"> | Date | string | null
    city?: XOR<CityScalarRelationFilter, CityWhereInput>
    stopActivities?: StopActivityListRelationFilter
  }, "id">

  export type ActivityOrderByWithAggregationInput = {
    id?: SortOrder
    cityId?: SortOrder
    name?: SortOrder
    category?: SortOrder
    description?: SortOrderInput | SortOrder
    estimatedCost?: SortOrder
    currency?: SortOrder
    durationMinutes?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    rating?: SortOrderInput | SortOrder
    popularityScore?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: ActivityCountOrderByAggregateInput
    _avg?: ActivityAvgOrderByAggregateInput
    _max?: ActivityMaxOrderByAggregateInput
    _min?: ActivityMinOrderByAggregateInput
    _sum?: ActivitySumOrderByAggregateInput
  }

  export type ActivityScalarWhereWithAggregatesInput = {
    AND?: ActivityScalarWhereWithAggregatesInput | ActivityScalarWhereWithAggregatesInput[]
    OR?: ActivityScalarWhereWithAggregatesInput[]
    NOT?: ActivityScalarWhereWithAggregatesInput | ActivityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Activity"> | string
    cityId?: StringWithAggregatesFilter<"Activity"> | string
    name?: StringWithAggregatesFilter<"Activity"> | string
    category?: StringWithAggregatesFilter<"Activity"> | string
    description?: StringNullableWithAggregatesFilter<"Activity"> | string | null
    estimatedCost?: FloatWithAggregatesFilter<"Activity"> | number
    currency?: StringWithAggregatesFilter<"Activity"> | string
    durationMinutes?: IntNullableWithAggregatesFilter<"Activity"> | number | null
    imageUrl?: StringNullableWithAggregatesFilter<"Activity"> | string | null
    rating?: FloatNullableWithAggregatesFilter<"Activity"> | number | null
    popularityScore?: IntWithAggregatesFilter<"Activity"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Activity"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Activity"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Activity"> | Date | string | null
  }

  export type HotelWhereInput = {
    AND?: HotelWhereInput | HotelWhereInput[]
    OR?: HotelWhereInput[]
    NOT?: HotelWhereInput | HotelWhereInput[]
    id?: StringFilter<"Hotel"> | string
    cityId?: StringFilter<"Hotel"> | string
    name?: StringFilter<"Hotel"> | string
    category?: StringFilter<"Hotel"> | string
    description?: StringNullableFilter<"Hotel"> | string | null
    pricePerNight?: FloatFilter<"Hotel"> | number
    currency?: StringFilter<"Hotel"> | string
    rating?: FloatNullableFilter<"Hotel"> | number | null
    amenities?: StringNullableFilter<"Hotel"> | string | null
    address?: StringNullableFilter<"Hotel"> | string | null
    imageUrl?: StringNullableFilter<"Hotel"> | string | null
    contactPhone?: StringNullableFilter<"Hotel"> | string | null
    website?: StringNullableFilter<"Hotel"> | string | null
    createdAt?: DateTimeFilter<"Hotel"> | Date | string
    updatedAt?: DateTimeFilter<"Hotel"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Hotel"> | Date | string | null
    city?: XOR<CityScalarRelationFilter, CityWhereInput>
  }

  export type HotelOrderByWithRelationInput = {
    id?: SortOrder
    cityId?: SortOrder
    name?: SortOrder
    category?: SortOrder
    description?: SortOrderInput | SortOrder
    pricePerNight?: SortOrder
    currency?: SortOrder
    rating?: SortOrderInput | SortOrder
    amenities?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    contactPhone?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    city?: CityOrderByWithRelationInput
  }

  export type HotelWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: HotelWhereInput | HotelWhereInput[]
    OR?: HotelWhereInput[]
    NOT?: HotelWhereInput | HotelWhereInput[]
    cityId?: StringFilter<"Hotel"> | string
    name?: StringFilter<"Hotel"> | string
    category?: StringFilter<"Hotel"> | string
    description?: StringNullableFilter<"Hotel"> | string | null
    pricePerNight?: FloatFilter<"Hotel"> | number
    currency?: StringFilter<"Hotel"> | string
    rating?: FloatNullableFilter<"Hotel"> | number | null
    amenities?: StringNullableFilter<"Hotel"> | string | null
    address?: StringNullableFilter<"Hotel"> | string | null
    imageUrl?: StringNullableFilter<"Hotel"> | string | null
    contactPhone?: StringNullableFilter<"Hotel"> | string | null
    website?: StringNullableFilter<"Hotel"> | string | null
    createdAt?: DateTimeFilter<"Hotel"> | Date | string
    updatedAt?: DateTimeFilter<"Hotel"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Hotel"> | Date | string | null
    city?: XOR<CityScalarRelationFilter, CityWhereInput>
  }, "id">

  export type HotelOrderByWithAggregationInput = {
    id?: SortOrder
    cityId?: SortOrder
    name?: SortOrder
    category?: SortOrder
    description?: SortOrderInput | SortOrder
    pricePerNight?: SortOrder
    currency?: SortOrder
    rating?: SortOrderInput | SortOrder
    amenities?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    contactPhone?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: HotelCountOrderByAggregateInput
    _avg?: HotelAvgOrderByAggregateInput
    _max?: HotelMaxOrderByAggregateInput
    _min?: HotelMinOrderByAggregateInput
    _sum?: HotelSumOrderByAggregateInput
  }

  export type HotelScalarWhereWithAggregatesInput = {
    AND?: HotelScalarWhereWithAggregatesInput | HotelScalarWhereWithAggregatesInput[]
    OR?: HotelScalarWhereWithAggregatesInput[]
    NOT?: HotelScalarWhereWithAggregatesInput | HotelScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Hotel"> | string
    cityId?: StringWithAggregatesFilter<"Hotel"> | string
    name?: StringWithAggregatesFilter<"Hotel"> | string
    category?: StringWithAggregatesFilter<"Hotel"> | string
    description?: StringNullableWithAggregatesFilter<"Hotel"> | string | null
    pricePerNight?: FloatWithAggregatesFilter<"Hotel"> | number
    currency?: StringWithAggregatesFilter<"Hotel"> | string
    rating?: FloatNullableWithAggregatesFilter<"Hotel"> | number | null
    amenities?: StringNullableWithAggregatesFilter<"Hotel"> | string | null
    address?: StringNullableWithAggregatesFilter<"Hotel"> | string | null
    imageUrl?: StringNullableWithAggregatesFilter<"Hotel"> | string | null
    contactPhone?: StringNullableWithAggregatesFilter<"Hotel"> | string | null
    website?: StringNullableWithAggregatesFilter<"Hotel"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Hotel"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Hotel"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Hotel"> | Date | string | null
  }

  export type RestaurantWhereInput = {
    AND?: RestaurantWhereInput | RestaurantWhereInput[]
    OR?: RestaurantWhereInput[]
    NOT?: RestaurantWhereInput | RestaurantWhereInput[]
    id?: StringFilter<"Restaurant"> | string
    cityId?: StringFilter<"Restaurant"> | string
    name?: StringFilter<"Restaurant"> | string
    cuisineType?: StringFilter<"Restaurant"> | string
    priceRange?: StringFilter<"Restaurant"> | string
    avgMealCost?: FloatFilter<"Restaurant"> | number
    currency?: StringFilter<"Restaurant"> | string
    rating?: FloatNullableFilter<"Restaurant"> | number | null
    description?: StringNullableFilter<"Restaurant"> | string | null
    address?: StringNullableFilter<"Restaurant"> | string | null
    imageUrl?: StringNullableFilter<"Restaurant"> | string | null
    isVegetarian?: BoolFilter<"Restaurant"> | boolean
    createdAt?: DateTimeFilter<"Restaurant"> | Date | string
    updatedAt?: DateTimeFilter<"Restaurant"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Restaurant"> | Date | string | null
    city?: XOR<CityScalarRelationFilter, CityWhereInput>
  }

  export type RestaurantOrderByWithRelationInput = {
    id?: SortOrder
    cityId?: SortOrder
    name?: SortOrder
    cuisineType?: SortOrder
    priceRange?: SortOrder
    avgMealCost?: SortOrder
    currency?: SortOrder
    rating?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    isVegetarian?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    city?: CityOrderByWithRelationInput
  }

  export type RestaurantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RestaurantWhereInput | RestaurantWhereInput[]
    OR?: RestaurantWhereInput[]
    NOT?: RestaurantWhereInput | RestaurantWhereInput[]
    cityId?: StringFilter<"Restaurant"> | string
    name?: StringFilter<"Restaurant"> | string
    cuisineType?: StringFilter<"Restaurant"> | string
    priceRange?: StringFilter<"Restaurant"> | string
    avgMealCost?: FloatFilter<"Restaurant"> | number
    currency?: StringFilter<"Restaurant"> | string
    rating?: FloatNullableFilter<"Restaurant"> | number | null
    description?: StringNullableFilter<"Restaurant"> | string | null
    address?: StringNullableFilter<"Restaurant"> | string | null
    imageUrl?: StringNullableFilter<"Restaurant"> | string | null
    isVegetarian?: BoolFilter<"Restaurant"> | boolean
    createdAt?: DateTimeFilter<"Restaurant"> | Date | string
    updatedAt?: DateTimeFilter<"Restaurant"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Restaurant"> | Date | string | null
    city?: XOR<CityScalarRelationFilter, CityWhereInput>
  }, "id">

  export type RestaurantOrderByWithAggregationInput = {
    id?: SortOrder
    cityId?: SortOrder
    name?: SortOrder
    cuisineType?: SortOrder
    priceRange?: SortOrder
    avgMealCost?: SortOrder
    currency?: SortOrder
    rating?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    isVegetarian?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: RestaurantCountOrderByAggregateInput
    _avg?: RestaurantAvgOrderByAggregateInput
    _max?: RestaurantMaxOrderByAggregateInput
    _min?: RestaurantMinOrderByAggregateInput
    _sum?: RestaurantSumOrderByAggregateInput
  }

  export type RestaurantScalarWhereWithAggregatesInput = {
    AND?: RestaurantScalarWhereWithAggregatesInput | RestaurantScalarWhereWithAggregatesInput[]
    OR?: RestaurantScalarWhereWithAggregatesInput[]
    NOT?: RestaurantScalarWhereWithAggregatesInput | RestaurantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Restaurant"> | string
    cityId?: StringWithAggregatesFilter<"Restaurant"> | string
    name?: StringWithAggregatesFilter<"Restaurant"> | string
    cuisineType?: StringWithAggregatesFilter<"Restaurant"> | string
    priceRange?: StringWithAggregatesFilter<"Restaurant"> | string
    avgMealCost?: FloatWithAggregatesFilter<"Restaurant"> | number
    currency?: StringWithAggregatesFilter<"Restaurant"> | string
    rating?: FloatNullableWithAggregatesFilter<"Restaurant"> | number | null
    description?: StringNullableWithAggregatesFilter<"Restaurant"> | string | null
    address?: StringNullableWithAggregatesFilter<"Restaurant"> | string | null
    imageUrl?: StringNullableWithAggregatesFilter<"Restaurant"> | string | null
    isVegetarian?: BoolWithAggregatesFilter<"Restaurant"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Restaurant"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Restaurant"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Restaurant"> | Date | string | null
  }

  export type TransportWhereInput = {
    AND?: TransportWhereInput | TransportWhereInput[]
    OR?: TransportWhereInput[]
    NOT?: TransportWhereInput | TransportWhereInput[]
    id?: StringFilter<"Transport"> | string
    fromCityId?: StringFilter<"Transport"> | string
    toCityId?: StringFilter<"Transport"> | string
    transportType?: StringFilter<"Transport"> | string
    operatorName?: StringFilter<"Transport"> | string
    departureTime?: StringFilter<"Transport"> | string
    arrivalTime?: StringFilter<"Transport"> | string
    durationMinutes?: IntFilter<"Transport"> | number
    price?: FloatFilter<"Transport"> | number
    currency?: StringFilter<"Transport"> | string
    classType?: StringNullableFilter<"Transport"> | string | null
    frequency?: StringNullableFilter<"Transport"> | string | null
    createdAt?: DateTimeFilter<"Transport"> | Date | string
    updatedAt?: DateTimeFilter<"Transport"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Transport"> | Date | string | null
    fromCity?: XOR<CityScalarRelationFilter, CityWhereInput>
    toCity?: XOR<CityScalarRelationFilter, CityWhereInput>
  }

  export type TransportOrderByWithRelationInput = {
    id?: SortOrder
    fromCityId?: SortOrder
    toCityId?: SortOrder
    transportType?: SortOrder
    operatorName?: SortOrder
    departureTime?: SortOrder
    arrivalTime?: SortOrder
    durationMinutes?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    classType?: SortOrderInput | SortOrder
    frequency?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    fromCity?: CityOrderByWithRelationInput
    toCity?: CityOrderByWithRelationInput
  }

  export type TransportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TransportWhereInput | TransportWhereInput[]
    OR?: TransportWhereInput[]
    NOT?: TransportWhereInput | TransportWhereInput[]
    fromCityId?: StringFilter<"Transport"> | string
    toCityId?: StringFilter<"Transport"> | string
    transportType?: StringFilter<"Transport"> | string
    operatorName?: StringFilter<"Transport"> | string
    departureTime?: StringFilter<"Transport"> | string
    arrivalTime?: StringFilter<"Transport"> | string
    durationMinutes?: IntFilter<"Transport"> | number
    price?: FloatFilter<"Transport"> | number
    currency?: StringFilter<"Transport"> | string
    classType?: StringNullableFilter<"Transport"> | string | null
    frequency?: StringNullableFilter<"Transport"> | string | null
    createdAt?: DateTimeFilter<"Transport"> | Date | string
    updatedAt?: DateTimeFilter<"Transport"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Transport"> | Date | string | null
    fromCity?: XOR<CityScalarRelationFilter, CityWhereInput>
    toCity?: XOR<CityScalarRelationFilter, CityWhereInput>
  }, "id">

  export type TransportOrderByWithAggregationInput = {
    id?: SortOrder
    fromCityId?: SortOrder
    toCityId?: SortOrder
    transportType?: SortOrder
    operatorName?: SortOrder
    departureTime?: SortOrder
    arrivalTime?: SortOrder
    durationMinutes?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    classType?: SortOrderInput | SortOrder
    frequency?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: TransportCountOrderByAggregateInput
    _avg?: TransportAvgOrderByAggregateInput
    _max?: TransportMaxOrderByAggregateInput
    _min?: TransportMinOrderByAggregateInput
    _sum?: TransportSumOrderByAggregateInput
  }

  export type TransportScalarWhereWithAggregatesInput = {
    AND?: TransportScalarWhereWithAggregatesInput | TransportScalarWhereWithAggregatesInput[]
    OR?: TransportScalarWhereWithAggregatesInput[]
    NOT?: TransportScalarWhereWithAggregatesInput | TransportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Transport"> | string
    fromCityId?: StringWithAggregatesFilter<"Transport"> | string
    toCityId?: StringWithAggregatesFilter<"Transport"> | string
    transportType?: StringWithAggregatesFilter<"Transport"> | string
    operatorName?: StringWithAggregatesFilter<"Transport"> | string
    departureTime?: StringWithAggregatesFilter<"Transport"> | string
    arrivalTime?: StringWithAggregatesFilter<"Transport"> | string
    durationMinutes?: IntWithAggregatesFilter<"Transport"> | number
    price?: FloatWithAggregatesFilter<"Transport"> | number
    currency?: StringWithAggregatesFilter<"Transport"> | string
    classType?: StringNullableWithAggregatesFilter<"Transport"> | string | null
    frequency?: StringNullableWithAggregatesFilter<"Transport"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Transport"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Transport"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Transport"> | Date | string | null
  }

  export type TripWhereInput = {
    AND?: TripWhereInput | TripWhereInput[]
    OR?: TripWhereInput[]
    NOT?: TripWhereInput | TripWhereInput[]
    id?: StringFilter<"Trip"> | string
    userId?: StringFilter<"Trip"> | string
    name?: StringFilter<"Trip"> | string
    description?: StringNullableFilter<"Trip"> | string | null
    startDate?: DateTimeFilter<"Trip"> | Date | string
    endDate?: DateTimeFilter<"Trip"> | Date | string
    coverPhotoUrl?: StringNullableFilter<"Trip"> | string | null
    status?: StringFilter<"Trip"> | string
    isPublic?: BoolFilter<"Trip"> | boolean
    totalEstimatedCost?: FloatFilter<"Trip"> | number
    currency?: StringFilter<"Trip"> | string
    travelStyle?: StringNullableFilter<"Trip"> | string | null
    versionNumber?: IntFilter<"Trip"> | number
    createdAt?: DateTimeFilter<"Trip"> | Date | string
    updatedAt?: DateTimeFilter<"Trip"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Trip"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    stops?: TripStopListRelationFilter
    budgets?: TripBudgetListRelationFilter
    media?: TripMediaListRelationFilter
    shares?: TripShareListRelationFilter
    versions?: TripVersionListRelationFilter
  }

  export type TripOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    coverPhotoUrl?: SortOrderInput | SortOrder
    status?: SortOrder
    isPublic?: SortOrder
    totalEstimatedCost?: SortOrder
    currency?: SortOrder
    travelStyle?: SortOrderInput | SortOrder
    versionNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    stops?: TripStopOrderByRelationAggregateInput
    budgets?: TripBudgetOrderByRelationAggregateInput
    media?: TripMediaOrderByRelationAggregateInput
    shares?: TripShareOrderByRelationAggregateInput
    versions?: TripVersionOrderByRelationAggregateInput
  }

  export type TripWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TripWhereInput | TripWhereInput[]
    OR?: TripWhereInput[]
    NOT?: TripWhereInput | TripWhereInput[]
    userId?: StringFilter<"Trip"> | string
    name?: StringFilter<"Trip"> | string
    description?: StringNullableFilter<"Trip"> | string | null
    startDate?: DateTimeFilter<"Trip"> | Date | string
    endDate?: DateTimeFilter<"Trip"> | Date | string
    coverPhotoUrl?: StringNullableFilter<"Trip"> | string | null
    status?: StringFilter<"Trip"> | string
    isPublic?: BoolFilter<"Trip"> | boolean
    totalEstimatedCost?: FloatFilter<"Trip"> | number
    currency?: StringFilter<"Trip"> | string
    travelStyle?: StringNullableFilter<"Trip"> | string | null
    versionNumber?: IntFilter<"Trip"> | number
    createdAt?: DateTimeFilter<"Trip"> | Date | string
    updatedAt?: DateTimeFilter<"Trip"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Trip"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    stops?: TripStopListRelationFilter
    budgets?: TripBudgetListRelationFilter
    media?: TripMediaListRelationFilter
    shares?: TripShareListRelationFilter
    versions?: TripVersionListRelationFilter
  }, "id">

  export type TripOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    coverPhotoUrl?: SortOrderInput | SortOrder
    status?: SortOrder
    isPublic?: SortOrder
    totalEstimatedCost?: SortOrder
    currency?: SortOrder
    travelStyle?: SortOrderInput | SortOrder
    versionNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: TripCountOrderByAggregateInput
    _avg?: TripAvgOrderByAggregateInput
    _max?: TripMaxOrderByAggregateInput
    _min?: TripMinOrderByAggregateInput
    _sum?: TripSumOrderByAggregateInput
  }

  export type TripScalarWhereWithAggregatesInput = {
    AND?: TripScalarWhereWithAggregatesInput | TripScalarWhereWithAggregatesInput[]
    OR?: TripScalarWhereWithAggregatesInput[]
    NOT?: TripScalarWhereWithAggregatesInput | TripScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Trip"> | string
    userId?: StringWithAggregatesFilter<"Trip"> | string
    name?: StringWithAggregatesFilter<"Trip"> | string
    description?: StringNullableWithAggregatesFilter<"Trip"> | string | null
    startDate?: DateTimeWithAggregatesFilter<"Trip"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Trip"> | Date | string
    coverPhotoUrl?: StringNullableWithAggregatesFilter<"Trip"> | string | null
    status?: StringWithAggregatesFilter<"Trip"> | string
    isPublic?: BoolWithAggregatesFilter<"Trip"> | boolean
    totalEstimatedCost?: FloatWithAggregatesFilter<"Trip"> | number
    currency?: StringWithAggregatesFilter<"Trip"> | string
    travelStyle?: StringNullableWithAggregatesFilter<"Trip"> | string | null
    versionNumber?: IntWithAggregatesFilter<"Trip"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Trip"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Trip"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Trip"> | Date | string | null
  }

  export type TripStopWhereInput = {
    AND?: TripStopWhereInput | TripStopWhereInput[]
    OR?: TripStopWhereInput[]
    NOT?: TripStopWhereInput | TripStopWhereInput[]
    id?: StringFilter<"TripStop"> | string
    tripId?: StringFilter<"TripStop"> | string
    cityId?: StringFilter<"TripStop"> | string
    stopOrder?: IntFilter<"TripStop"> | number
    arrivalDate?: DateTimeFilter<"TripStop"> | Date | string
    departureDate?: DateTimeFilter<"TripStop"> | Date | string
    accommodationName?: StringNullableFilter<"TripStop"> | string | null
    accommodationCost?: FloatNullableFilter<"TripStop"> | number | null
    notes?: StringNullableFilter<"TripStop"> | string | null
    createdAt?: DateTimeFilter<"TripStop"> | Date | string
    updatedAt?: DateTimeFilter<"TripStop"> | Date | string
    deletedAt?: DateTimeNullableFilter<"TripStop"> | Date | string | null
    trip?: XOR<TripScalarRelationFilter, TripWhereInput>
    city?: XOR<CityScalarRelationFilter, CityWhereInput>
    activities?: StopActivityListRelationFilter
  }

  export type TripStopOrderByWithRelationInput = {
    id?: SortOrder
    tripId?: SortOrder
    cityId?: SortOrder
    stopOrder?: SortOrder
    arrivalDate?: SortOrder
    departureDate?: SortOrder
    accommodationName?: SortOrderInput | SortOrder
    accommodationCost?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    trip?: TripOrderByWithRelationInput
    city?: CityOrderByWithRelationInput
    activities?: StopActivityOrderByRelationAggregateInput
  }

  export type TripStopWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tripId_stopOrder?: TripStopTripIdStopOrderCompoundUniqueInput
    AND?: TripStopWhereInput | TripStopWhereInput[]
    OR?: TripStopWhereInput[]
    NOT?: TripStopWhereInput | TripStopWhereInput[]
    tripId?: StringFilter<"TripStop"> | string
    cityId?: StringFilter<"TripStop"> | string
    stopOrder?: IntFilter<"TripStop"> | number
    arrivalDate?: DateTimeFilter<"TripStop"> | Date | string
    departureDate?: DateTimeFilter<"TripStop"> | Date | string
    accommodationName?: StringNullableFilter<"TripStop"> | string | null
    accommodationCost?: FloatNullableFilter<"TripStop"> | number | null
    notes?: StringNullableFilter<"TripStop"> | string | null
    createdAt?: DateTimeFilter<"TripStop"> | Date | string
    updatedAt?: DateTimeFilter<"TripStop"> | Date | string
    deletedAt?: DateTimeNullableFilter<"TripStop"> | Date | string | null
    trip?: XOR<TripScalarRelationFilter, TripWhereInput>
    city?: XOR<CityScalarRelationFilter, CityWhereInput>
    activities?: StopActivityListRelationFilter
  }, "id" | "tripId_stopOrder">

  export type TripStopOrderByWithAggregationInput = {
    id?: SortOrder
    tripId?: SortOrder
    cityId?: SortOrder
    stopOrder?: SortOrder
    arrivalDate?: SortOrder
    departureDate?: SortOrder
    accommodationName?: SortOrderInput | SortOrder
    accommodationCost?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: TripStopCountOrderByAggregateInput
    _avg?: TripStopAvgOrderByAggregateInput
    _max?: TripStopMaxOrderByAggregateInput
    _min?: TripStopMinOrderByAggregateInput
    _sum?: TripStopSumOrderByAggregateInput
  }

  export type TripStopScalarWhereWithAggregatesInput = {
    AND?: TripStopScalarWhereWithAggregatesInput | TripStopScalarWhereWithAggregatesInput[]
    OR?: TripStopScalarWhereWithAggregatesInput[]
    NOT?: TripStopScalarWhereWithAggregatesInput | TripStopScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TripStop"> | string
    tripId?: StringWithAggregatesFilter<"TripStop"> | string
    cityId?: StringWithAggregatesFilter<"TripStop"> | string
    stopOrder?: IntWithAggregatesFilter<"TripStop"> | number
    arrivalDate?: DateTimeWithAggregatesFilter<"TripStop"> | Date | string
    departureDate?: DateTimeWithAggregatesFilter<"TripStop"> | Date | string
    accommodationName?: StringNullableWithAggregatesFilter<"TripStop"> | string | null
    accommodationCost?: FloatNullableWithAggregatesFilter<"TripStop"> | number | null
    notes?: StringNullableWithAggregatesFilter<"TripStop"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TripStop"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TripStop"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"TripStop"> | Date | string | null
  }

  export type StopActivityWhereInput = {
    AND?: StopActivityWhereInput | StopActivityWhereInput[]
    OR?: StopActivityWhereInput[]
    NOT?: StopActivityWhereInput | StopActivityWhereInput[]
    id?: StringFilter<"StopActivity"> | string
    tripStopId?: StringFilter<"StopActivity"> | string
    activityId?: StringFilter<"StopActivity"> | string
    scheduledDate?: DateTimeFilter<"StopActivity"> | Date | string
    scheduledTime?: StringNullableFilter<"StopActivity"> | string | null
    actualCost?: FloatNullableFilter<"StopActivity"> | number | null
    notes?: StringNullableFilter<"StopActivity"> | string | null
    isCompleted?: BoolFilter<"StopActivity"> | boolean
    createdAt?: DateTimeFilter<"StopActivity"> | Date | string
    updatedAt?: DateTimeFilter<"StopActivity"> | Date | string
    deletedAt?: DateTimeNullableFilter<"StopActivity"> | Date | string | null
    tripStop?: XOR<TripStopScalarRelationFilter, TripStopWhereInput>
    activity?: XOR<ActivityScalarRelationFilter, ActivityWhereInput>
  }

  export type StopActivityOrderByWithRelationInput = {
    id?: SortOrder
    tripStopId?: SortOrder
    activityId?: SortOrder
    scheduledDate?: SortOrder
    scheduledTime?: SortOrderInput | SortOrder
    actualCost?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    isCompleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    tripStop?: TripStopOrderByWithRelationInput
    activity?: ActivityOrderByWithRelationInput
  }

  export type StopActivityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StopActivityWhereInput | StopActivityWhereInput[]
    OR?: StopActivityWhereInput[]
    NOT?: StopActivityWhereInput | StopActivityWhereInput[]
    tripStopId?: StringFilter<"StopActivity"> | string
    activityId?: StringFilter<"StopActivity"> | string
    scheduledDate?: DateTimeFilter<"StopActivity"> | Date | string
    scheduledTime?: StringNullableFilter<"StopActivity"> | string | null
    actualCost?: FloatNullableFilter<"StopActivity"> | number | null
    notes?: StringNullableFilter<"StopActivity"> | string | null
    isCompleted?: BoolFilter<"StopActivity"> | boolean
    createdAt?: DateTimeFilter<"StopActivity"> | Date | string
    updatedAt?: DateTimeFilter<"StopActivity"> | Date | string
    deletedAt?: DateTimeNullableFilter<"StopActivity"> | Date | string | null
    tripStop?: XOR<TripStopScalarRelationFilter, TripStopWhereInput>
    activity?: XOR<ActivityScalarRelationFilter, ActivityWhereInput>
  }, "id">

  export type StopActivityOrderByWithAggregationInput = {
    id?: SortOrder
    tripStopId?: SortOrder
    activityId?: SortOrder
    scheduledDate?: SortOrder
    scheduledTime?: SortOrderInput | SortOrder
    actualCost?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    isCompleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: StopActivityCountOrderByAggregateInput
    _avg?: StopActivityAvgOrderByAggregateInput
    _max?: StopActivityMaxOrderByAggregateInput
    _min?: StopActivityMinOrderByAggregateInput
    _sum?: StopActivitySumOrderByAggregateInput
  }

  export type StopActivityScalarWhereWithAggregatesInput = {
    AND?: StopActivityScalarWhereWithAggregatesInput | StopActivityScalarWhereWithAggregatesInput[]
    OR?: StopActivityScalarWhereWithAggregatesInput[]
    NOT?: StopActivityScalarWhereWithAggregatesInput | StopActivityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StopActivity"> | string
    tripStopId?: StringWithAggregatesFilter<"StopActivity"> | string
    activityId?: StringWithAggregatesFilter<"StopActivity"> | string
    scheduledDate?: DateTimeWithAggregatesFilter<"StopActivity"> | Date | string
    scheduledTime?: StringNullableWithAggregatesFilter<"StopActivity"> | string | null
    actualCost?: FloatNullableWithAggregatesFilter<"StopActivity"> | number | null
    notes?: StringNullableWithAggregatesFilter<"StopActivity"> | string | null
    isCompleted?: BoolWithAggregatesFilter<"StopActivity"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"StopActivity"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StopActivity"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"StopActivity"> | Date | string | null
  }

  export type TripBudgetWhereInput = {
    AND?: TripBudgetWhereInput | TripBudgetWhereInput[]
    OR?: TripBudgetWhereInput[]
    NOT?: TripBudgetWhereInput | TripBudgetWhereInput[]
    id?: StringFilter<"TripBudget"> | string
    tripId?: StringFilter<"TripBudget"> | string
    category?: StringFilter<"TripBudget"> | string
    estimatedAmount?: FloatFilter<"TripBudget"> | number
    actualAmount?: FloatNullableFilter<"TripBudget"> | number | null
    currency?: StringFilter<"TripBudget"> | string
    notes?: StringNullableFilter<"TripBudget"> | string | null
    createdAt?: DateTimeFilter<"TripBudget"> | Date | string
    updatedAt?: DateTimeFilter<"TripBudget"> | Date | string
    deletedAt?: DateTimeNullableFilter<"TripBudget"> | Date | string | null
    trip?: XOR<TripScalarRelationFilter, TripWhereInput>
  }

  export type TripBudgetOrderByWithRelationInput = {
    id?: SortOrder
    tripId?: SortOrder
    category?: SortOrder
    estimatedAmount?: SortOrder
    actualAmount?: SortOrderInput | SortOrder
    currency?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    trip?: TripOrderByWithRelationInput
  }

  export type TripBudgetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tripId_category?: TripBudgetTripIdCategoryCompoundUniqueInput
    AND?: TripBudgetWhereInput | TripBudgetWhereInput[]
    OR?: TripBudgetWhereInput[]
    NOT?: TripBudgetWhereInput | TripBudgetWhereInput[]
    tripId?: StringFilter<"TripBudget"> | string
    category?: StringFilter<"TripBudget"> | string
    estimatedAmount?: FloatFilter<"TripBudget"> | number
    actualAmount?: FloatNullableFilter<"TripBudget"> | number | null
    currency?: StringFilter<"TripBudget"> | string
    notes?: StringNullableFilter<"TripBudget"> | string | null
    createdAt?: DateTimeFilter<"TripBudget"> | Date | string
    updatedAt?: DateTimeFilter<"TripBudget"> | Date | string
    deletedAt?: DateTimeNullableFilter<"TripBudget"> | Date | string | null
    trip?: XOR<TripScalarRelationFilter, TripWhereInput>
  }, "id" | "tripId_category">

  export type TripBudgetOrderByWithAggregationInput = {
    id?: SortOrder
    tripId?: SortOrder
    category?: SortOrder
    estimatedAmount?: SortOrder
    actualAmount?: SortOrderInput | SortOrder
    currency?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: TripBudgetCountOrderByAggregateInput
    _avg?: TripBudgetAvgOrderByAggregateInput
    _max?: TripBudgetMaxOrderByAggregateInput
    _min?: TripBudgetMinOrderByAggregateInput
    _sum?: TripBudgetSumOrderByAggregateInput
  }

  export type TripBudgetScalarWhereWithAggregatesInput = {
    AND?: TripBudgetScalarWhereWithAggregatesInput | TripBudgetScalarWhereWithAggregatesInput[]
    OR?: TripBudgetScalarWhereWithAggregatesInput[]
    NOT?: TripBudgetScalarWhereWithAggregatesInput | TripBudgetScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TripBudget"> | string
    tripId?: StringWithAggregatesFilter<"TripBudget"> | string
    category?: StringWithAggregatesFilter<"TripBudget"> | string
    estimatedAmount?: FloatWithAggregatesFilter<"TripBudget"> | number
    actualAmount?: FloatNullableWithAggregatesFilter<"TripBudget"> | number | null
    currency?: StringWithAggregatesFilter<"TripBudget"> | string
    notes?: StringNullableWithAggregatesFilter<"TripBudget"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TripBudget"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TripBudget"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"TripBudget"> | Date | string | null
  }

  export type TripMediaWhereInput = {
    AND?: TripMediaWhereInput | TripMediaWhereInput[]
    OR?: TripMediaWhereInput[]
    NOT?: TripMediaWhereInput | TripMediaWhereInput[]
    id?: StringFilter<"TripMedia"> | string
    tripId?: StringFilter<"TripMedia"> | string
    mediaType?: StringFilter<"TripMedia"> | string
    mediaUrl?: StringFilter<"TripMedia"> | string
    thumbnailUrl?: StringNullableFilter<"TripMedia"> | string | null
    caption?: StringNullableFilter<"TripMedia"> | string | null
    displayOrder?: IntNullableFilter<"TripMedia"> | number | null
    uploadedAt?: DateTimeFilter<"TripMedia"> | Date | string
    createdAt?: DateTimeFilter<"TripMedia"> | Date | string
    updatedAt?: DateTimeFilter<"TripMedia"> | Date | string
    deletedAt?: DateTimeNullableFilter<"TripMedia"> | Date | string | null
    trip?: XOR<TripScalarRelationFilter, TripWhereInput>
  }

  export type TripMediaOrderByWithRelationInput = {
    id?: SortOrder
    tripId?: SortOrder
    mediaType?: SortOrder
    mediaUrl?: SortOrder
    thumbnailUrl?: SortOrderInput | SortOrder
    caption?: SortOrderInput | SortOrder
    displayOrder?: SortOrderInput | SortOrder
    uploadedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    trip?: TripOrderByWithRelationInput
  }

  export type TripMediaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TripMediaWhereInput | TripMediaWhereInput[]
    OR?: TripMediaWhereInput[]
    NOT?: TripMediaWhereInput | TripMediaWhereInput[]
    tripId?: StringFilter<"TripMedia"> | string
    mediaType?: StringFilter<"TripMedia"> | string
    mediaUrl?: StringFilter<"TripMedia"> | string
    thumbnailUrl?: StringNullableFilter<"TripMedia"> | string | null
    caption?: StringNullableFilter<"TripMedia"> | string | null
    displayOrder?: IntNullableFilter<"TripMedia"> | number | null
    uploadedAt?: DateTimeFilter<"TripMedia"> | Date | string
    createdAt?: DateTimeFilter<"TripMedia"> | Date | string
    updatedAt?: DateTimeFilter<"TripMedia"> | Date | string
    deletedAt?: DateTimeNullableFilter<"TripMedia"> | Date | string | null
    trip?: XOR<TripScalarRelationFilter, TripWhereInput>
  }, "id">

  export type TripMediaOrderByWithAggregationInput = {
    id?: SortOrder
    tripId?: SortOrder
    mediaType?: SortOrder
    mediaUrl?: SortOrder
    thumbnailUrl?: SortOrderInput | SortOrder
    caption?: SortOrderInput | SortOrder
    displayOrder?: SortOrderInput | SortOrder
    uploadedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: TripMediaCountOrderByAggregateInput
    _avg?: TripMediaAvgOrderByAggregateInput
    _max?: TripMediaMaxOrderByAggregateInput
    _min?: TripMediaMinOrderByAggregateInput
    _sum?: TripMediaSumOrderByAggregateInput
  }

  export type TripMediaScalarWhereWithAggregatesInput = {
    AND?: TripMediaScalarWhereWithAggregatesInput | TripMediaScalarWhereWithAggregatesInput[]
    OR?: TripMediaScalarWhereWithAggregatesInput[]
    NOT?: TripMediaScalarWhereWithAggregatesInput | TripMediaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TripMedia"> | string
    tripId?: StringWithAggregatesFilter<"TripMedia"> | string
    mediaType?: StringWithAggregatesFilter<"TripMedia"> | string
    mediaUrl?: StringWithAggregatesFilter<"TripMedia"> | string
    thumbnailUrl?: StringNullableWithAggregatesFilter<"TripMedia"> | string | null
    caption?: StringNullableWithAggregatesFilter<"TripMedia"> | string | null
    displayOrder?: IntNullableWithAggregatesFilter<"TripMedia"> | number | null
    uploadedAt?: DateTimeWithAggregatesFilter<"TripMedia"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"TripMedia"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TripMedia"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"TripMedia"> | Date | string | null
  }

  export type TripShareWhereInput = {
    AND?: TripShareWhereInput | TripShareWhereInput[]
    OR?: TripShareWhereInput[]
    NOT?: TripShareWhereInput | TripShareWhereInput[]
    id?: StringFilter<"TripShare"> | string
    tripId?: StringFilter<"TripShare"> | string
    shareToken?: StringFilter<"TripShare"> | string
    shareType?: StringFilter<"TripShare"> | string
    sharedWithEmail?: StringNullableFilter<"TripShare"> | string | null
    viewCount?: IntFilter<"TripShare"> | number
    lastViewedAt?: DateTimeNullableFilter<"TripShare"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"TripShare"> | Date | string | null
    createdAt?: DateTimeFilter<"TripShare"> | Date | string
    updatedAt?: DateTimeFilter<"TripShare"> | Date | string
    deletedAt?: DateTimeNullableFilter<"TripShare"> | Date | string | null
    trip?: XOR<TripScalarRelationFilter, TripWhereInput>
  }

  export type TripShareOrderByWithRelationInput = {
    id?: SortOrder
    tripId?: SortOrder
    shareToken?: SortOrder
    shareType?: SortOrder
    sharedWithEmail?: SortOrderInput | SortOrder
    viewCount?: SortOrder
    lastViewedAt?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    trip?: TripOrderByWithRelationInput
  }

  export type TripShareWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    shareToken?: string
    AND?: TripShareWhereInput | TripShareWhereInput[]
    OR?: TripShareWhereInput[]
    NOT?: TripShareWhereInput | TripShareWhereInput[]
    tripId?: StringFilter<"TripShare"> | string
    shareType?: StringFilter<"TripShare"> | string
    sharedWithEmail?: StringNullableFilter<"TripShare"> | string | null
    viewCount?: IntFilter<"TripShare"> | number
    lastViewedAt?: DateTimeNullableFilter<"TripShare"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"TripShare"> | Date | string | null
    createdAt?: DateTimeFilter<"TripShare"> | Date | string
    updatedAt?: DateTimeFilter<"TripShare"> | Date | string
    deletedAt?: DateTimeNullableFilter<"TripShare"> | Date | string | null
    trip?: XOR<TripScalarRelationFilter, TripWhereInput>
  }, "id" | "shareToken">

  export type TripShareOrderByWithAggregationInput = {
    id?: SortOrder
    tripId?: SortOrder
    shareToken?: SortOrder
    shareType?: SortOrder
    sharedWithEmail?: SortOrderInput | SortOrder
    viewCount?: SortOrder
    lastViewedAt?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: TripShareCountOrderByAggregateInput
    _avg?: TripShareAvgOrderByAggregateInput
    _max?: TripShareMaxOrderByAggregateInput
    _min?: TripShareMinOrderByAggregateInput
    _sum?: TripShareSumOrderByAggregateInput
  }

  export type TripShareScalarWhereWithAggregatesInput = {
    AND?: TripShareScalarWhereWithAggregatesInput | TripShareScalarWhereWithAggregatesInput[]
    OR?: TripShareScalarWhereWithAggregatesInput[]
    NOT?: TripShareScalarWhereWithAggregatesInput | TripShareScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TripShare"> | string
    tripId?: StringWithAggregatesFilter<"TripShare"> | string
    shareToken?: StringWithAggregatesFilter<"TripShare"> | string
    shareType?: StringWithAggregatesFilter<"TripShare"> | string
    sharedWithEmail?: StringNullableWithAggregatesFilter<"TripShare"> | string | null
    viewCount?: IntWithAggregatesFilter<"TripShare"> | number
    lastViewedAt?: DateTimeNullableWithAggregatesFilter<"TripShare"> | Date | string | null
    expiresAt?: DateTimeNullableWithAggregatesFilter<"TripShare"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TripShare"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TripShare"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"TripShare"> | Date | string | null
  }

  export type TripVersionWhereInput = {
    AND?: TripVersionWhereInput | TripVersionWhereInput[]
    OR?: TripVersionWhereInput[]
    NOT?: TripVersionWhereInput | TripVersionWhereInput[]
    id?: StringFilter<"TripVersion"> | string
    tripId?: StringFilter<"TripVersion"> | string
    versionNumber?: IntFilter<"TripVersion"> | number
    snapshotData?: StringFilter<"TripVersion"> | string
    changeSummary?: StringNullableFilter<"TripVersion"> | string | null
    createdBy?: StringFilter<"TripVersion"> | string
    createdAt?: DateTimeFilter<"TripVersion"> | Date | string
    trip?: XOR<TripScalarRelationFilter, TripWhereInput>
  }

  export type TripVersionOrderByWithRelationInput = {
    id?: SortOrder
    tripId?: SortOrder
    versionNumber?: SortOrder
    snapshotData?: SortOrder
    changeSummary?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    trip?: TripOrderByWithRelationInput
  }

  export type TripVersionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tripId_versionNumber?: TripVersionTripIdVersionNumberCompoundUniqueInput
    AND?: TripVersionWhereInput | TripVersionWhereInput[]
    OR?: TripVersionWhereInput[]
    NOT?: TripVersionWhereInput | TripVersionWhereInput[]
    tripId?: StringFilter<"TripVersion"> | string
    versionNumber?: IntFilter<"TripVersion"> | number
    snapshotData?: StringFilter<"TripVersion"> | string
    changeSummary?: StringNullableFilter<"TripVersion"> | string | null
    createdBy?: StringFilter<"TripVersion"> | string
    createdAt?: DateTimeFilter<"TripVersion"> | Date | string
    trip?: XOR<TripScalarRelationFilter, TripWhereInput>
  }, "id" | "tripId_versionNumber">

  export type TripVersionOrderByWithAggregationInput = {
    id?: SortOrder
    tripId?: SortOrder
    versionNumber?: SortOrder
    snapshotData?: SortOrder
    changeSummary?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    _count?: TripVersionCountOrderByAggregateInput
    _avg?: TripVersionAvgOrderByAggregateInput
    _max?: TripVersionMaxOrderByAggregateInput
    _min?: TripVersionMinOrderByAggregateInput
    _sum?: TripVersionSumOrderByAggregateInput
  }

  export type TripVersionScalarWhereWithAggregatesInput = {
    AND?: TripVersionScalarWhereWithAggregatesInput | TripVersionScalarWhereWithAggregatesInput[]
    OR?: TripVersionScalarWhereWithAggregatesInput[]
    NOT?: TripVersionScalarWhereWithAggregatesInput | TripVersionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TripVersion"> | string
    tripId?: StringWithAggregatesFilter<"TripVersion"> | string
    versionNumber?: IntWithAggregatesFilter<"TripVersion"> | number
    snapshotData?: StringWithAggregatesFilter<"TripVersion"> | string
    changeSummary?: StringNullableWithAggregatesFilter<"TripVersion"> | string | null
    createdBy?: StringWithAggregatesFilter<"TripVersion"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TripVersion"> | Date | string
  }

  export type UserSavedDestinationWhereInput = {
    AND?: UserSavedDestinationWhereInput | UserSavedDestinationWhereInput[]
    OR?: UserSavedDestinationWhereInput[]
    NOT?: UserSavedDestinationWhereInput | UserSavedDestinationWhereInput[]
    id?: StringFilter<"UserSavedDestination"> | string
    userId?: StringFilter<"UserSavedDestination"> | string
    cityId?: StringFilter<"UserSavedDestination"> | string
    notes?: StringNullableFilter<"UserSavedDestination"> | string | null
    savedAt?: DateTimeFilter<"UserSavedDestination"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    city?: XOR<CityScalarRelationFilter, CityWhereInput>
  }

  export type UserSavedDestinationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    cityId?: SortOrder
    notes?: SortOrderInput | SortOrder
    savedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    city?: CityOrderByWithRelationInput
  }

  export type UserSavedDestinationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_cityId?: UserSavedDestinationUserIdCityIdCompoundUniqueInput
    AND?: UserSavedDestinationWhereInput | UserSavedDestinationWhereInput[]
    OR?: UserSavedDestinationWhereInput[]
    NOT?: UserSavedDestinationWhereInput | UserSavedDestinationWhereInput[]
    userId?: StringFilter<"UserSavedDestination"> | string
    cityId?: StringFilter<"UserSavedDestination"> | string
    notes?: StringNullableFilter<"UserSavedDestination"> | string | null
    savedAt?: DateTimeFilter<"UserSavedDestination"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    city?: XOR<CityScalarRelationFilter, CityWhereInput>
  }, "id" | "userId_cityId">

  export type UserSavedDestinationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    cityId?: SortOrder
    notes?: SortOrderInput | SortOrder
    savedAt?: SortOrder
    _count?: UserSavedDestinationCountOrderByAggregateInput
    _max?: UserSavedDestinationMaxOrderByAggregateInput
    _min?: UserSavedDestinationMinOrderByAggregateInput
  }

  export type UserSavedDestinationScalarWhereWithAggregatesInput = {
    AND?: UserSavedDestinationScalarWhereWithAggregatesInput | UserSavedDestinationScalarWhereWithAggregatesInput[]
    OR?: UserSavedDestinationScalarWhereWithAggregatesInput[]
    NOT?: UserSavedDestinationScalarWhereWithAggregatesInput | UserSavedDestinationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserSavedDestination"> | string
    userId?: StringWithAggregatesFilter<"UserSavedDestination"> | string
    cityId?: StringWithAggregatesFilter<"UserSavedDestination"> | string
    notes?: StringNullableWithAggregatesFilter<"UserSavedDestination"> | string | null
    savedAt?: DateTimeWithAggregatesFilter<"UserSavedDestination"> | Date | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    changes?: StringNullableFilter<"AuditLog"> | string | null
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    changes?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    userId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    changes?: StringNullableFilter<"AuditLog"> | string | null
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    changes?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    userId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    entityType?: StringWithAggregatesFilter<"AuditLog"> | string
    entityId?: StringWithAggregatesFilter<"AuditLog"> | string
    changes?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type WeatherWhereInput = {
    AND?: WeatherWhereInput | WeatherWhereInput[]
    OR?: WeatherWhereInput[]
    NOT?: WeatherWhereInput | WeatherWhereInput[]
    id?: StringFilter<"Weather"> | string
    cityId?: StringNullableFilter<"Weather"> | string | null
    city?: StringFilter<"Weather"> | string
    date?: StringFilter<"Weather"> | string
    current?: StringFilter<"Weather"> | string
    forecast?: StringFilter<"Weather"> | string
    hourlyForecast?: StringFilter<"Weather"> | string
    recommendation?: StringNullableFilter<"Weather"> | string | null
    createdAt?: DateTimeFilter<"Weather"> | Date | string
    updatedAt?: DateTimeFilter<"Weather"> | Date | string
  }

  export type WeatherOrderByWithRelationInput = {
    id?: SortOrder
    cityId?: SortOrderInput | SortOrder
    city?: SortOrder
    date?: SortOrder
    current?: SortOrder
    forecast?: SortOrder
    hourlyForecast?: SortOrder
    recommendation?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WeatherWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WeatherWhereInput | WeatherWhereInput[]
    OR?: WeatherWhereInput[]
    NOT?: WeatherWhereInput | WeatherWhereInput[]
    cityId?: StringNullableFilter<"Weather"> | string | null
    city?: StringFilter<"Weather"> | string
    date?: StringFilter<"Weather"> | string
    current?: StringFilter<"Weather"> | string
    forecast?: StringFilter<"Weather"> | string
    hourlyForecast?: StringFilter<"Weather"> | string
    recommendation?: StringNullableFilter<"Weather"> | string | null
    createdAt?: DateTimeFilter<"Weather"> | Date | string
    updatedAt?: DateTimeFilter<"Weather"> | Date | string
  }, "id">

  export type WeatherOrderByWithAggregationInput = {
    id?: SortOrder
    cityId?: SortOrderInput | SortOrder
    city?: SortOrder
    date?: SortOrder
    current?: SortOrder
    forecast?: SortOrder
    hourlyForecast?: SortOrder
    recommendation?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WeatherCountOrderByAggregateInput
    _max?: WeatherMaxOrderByAggregateInput
    _min?: WeatherMinOrderByAggregateInput
  }

  export type WeatherScalarWhereWithAggregatesInput = {
    AND?: WeatherScalarWhereWithAggregatesInput | WeatherScalarWhereWithAggregatesInput[]
    OR?: WeatherScalarWhereWithAggregatesInput[]
    NOT?: WeatherScalarWhereWithAggregatesInput | WeatherScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Weather"> | string
    cityId?: StringNullableWithAggregatesFilter<"Weather"> | string | null
    city?: StringWithAggregatesFilter<"Weather"> | string
    date?: StringWithAggregatesFilter<"Weather"> | string
    current?: StringWithAggregatesFilter<"Weather"> | string
    forecast?: StringWithAggregatesFilter<"Weather"> | string
    hourlyForecast?: StringWithAggregatesFilter<"Weather"> | string
    recommendation?: StringNullableWithAggregatesFilter<"Weather"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Weather"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Weather"> | Date | string
  }

  export type GuideWhereInput = {
    AND?: GuideWhereInput | GuideWhereInput[]
    OR?: GuideWhereInput[]
    NOT?: GuideWhereInput | GuideWhereInput[]
    id?: StringFilter<"Guide"> | string
    cityId?: StringNullableFilter<"Guide"> | string | null
    name?: StringFilter<"Guide"> | string
    specialization?: StringFilter<"Guide"> | string
    city?: StringFilter<"Guide"> | string
    languages?: StringFilter<"Guide"> | string
    certification?: StringNullableFilter<"Guide"> | string | null
    yearsOfExperience?: IntFilter<"Guide"> | number
    rating?: FloatNullableFilter<"Guide"> | number | null
    reviews?: IntFilter<"Guide"> | number
    pricePerDay?: StringFilter<"Guide"> | string
    availability?: StringFilter<"Guide"> | string
    groupSize?: StringFilter<"Guide"> | string
    skills?: StringFilter<"Guide"> | string
    tours?: StringFilter<"Guide"> | string
    createdAt?: DateTimeFilter<"Guide"> | Date | string
    updatedAt?: DateTimeFilter<"Guide"> | Date | string
  }

  export type GuideOrderByWithRelationInput = {
    id?: SortOrder
    cityId?: SortOrderInput | SortOrder
    name?: SortOrder
    specialization?: SortOrder
    city?: SortOrder
    languages?: SortOrder
    certification?: SortOrderInput | SortOrder
    yearsOfExperience?: SortOrder
    rating?: SortOrderInput | SortOrder
    reviews?: SortOrder
    pricePerDay?: SortOrder
    availability?: SortOrder
    groupSize?: SortOrder
    skills?: SortOrder
    tours?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GuideWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GuideWhereInput | GuideWhereInput[]
    OR?: GuideWhereInput[]
    NOT?: GuideWhereInput | GuideWhereInput[]
    cityId?: StringNullableFilter<"Guide"> | string | null
    name?: StringFilter<"Guide"> | string
    specialization?: StringFilter<"Guide"> | string
    city?: StringFilter<"Guide"> | string
    languages?: StringFilter<"Guide"> | string
    certification?: StringNullableFilter<"Guide"> | string | null
    yearsOfExperience?: IntFilter<"Guide"> | number
    rating?: FloatNullableFilter<"Guide"> | number | null
    reviews?: IntFilter<"Guide"> | number
    pricePerDay?: StringFilter<"Guide"> | string
    availability?: StringFilter<"Guide"> | string
    groupSize?: StringFilter<"Guide"> | string
    skills?: StringFilter<"Guide"> | string
    tours?: StringFilter<"Guide"> | string
    createdAt?: DateTimeFilter<"Guide"> | Date | string
    updatedAt?: DateTimeFilter<"Guide"> | Date | string
  }, "id">

  export type GuideOrderByWithAggregationInput = {
    id?: SortOrder
    cityId?: SortOrderInput | SortOrder
    name?: SortOrder
    specialization?: SortOrder
    city?: SortOrder
    languages?: SortOrder
    certification?: SortOrderInput | SortOrder
    yearsOfExperience?: SortOrder
    rating?: SortOrderInput | SortOrder
    reviews?: SortOrder
    pricePerDay?: SortOrder
    availability?: SortOrder
    groupSize?: SortOrder
    skills?: SortOrder
    tours?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GuideCountOrderByAggregateInput
    _avg?: GuideAvgOrderByAggregateInput
    _max?: GuideMaxOrderByAggregateInput
    _min?: GuideMinOrderByAggregateInput
    _sum?: GuideSumOrderByAggregateInput
  }

  export type GuideScalarWhereWithAggregatesInput = {
    AND?: GuideScalarWhereWithAggregatesInput | GuideScalarWhereWithAggregatesInput[]
    OR?: GuideScalarWhereWithAggregatesInput[]
    NOT?: GuideScalarWhereWithAggregatesInput | GuideScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Guide"> | string
    cityId?: StringNullableWithAggregatesFilter<"Guide"> | string | null
    name?: StringWithAggregatesFilter<"Guide"> | string
    specialization?: StringWithAggregatesFilter<"Guide"> | string
    city?: StringWithAggregatesFilter<"Guide"> | string
    languages?: StringWithAggregatesFilter<"Guide"> | string
    certification?: StringNullableWithAggregatesFilter<"Guide"> | string | null
    yearsOfExperience?: IntWithAggregatesFilter<"Guide"> | number
    rating?: FloatNullableWithAggregatesFilter<"Guide"> | number | null
    reviews?: IntWithAggregatesFilter<"Guide"> | number
    pricePerDay?: StringWithAggregatesFilter<"Guide"> | string
    availability?: StringWithAggregatesFilter<"Guide"> | string
    groupSize?: StringWithAggregatesFilter<"Guide"> | string
    skills?: StringWithAggregatesFilter<"Guide"> | string
    tours?: StringWithAggregatesFilter<"Guide"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Guide"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Guide"> | Date | string
  }

  export type EventWhereInput = {
    AND?: EventWhereInput | EventWhereInput[]
    OR?: EventWhereInput[]
    NOT?: EventWhereInput | EventWhereInput[]
    id?: StringFilter<"Event"> | string
    name?: StringFilter<"Event"> | string
    city?: StringFilter<"Event"> | string
    country?: StringFilter<"Event"> | string
    startDate?: StringFilter<"Event"> | string
    endDate?: StringFilter<"Event"> | string
    description?: StringNullableFilter<"Event"> | string | null
    category?: StringFilter<"Event"> | string
    expectedCrowd?: StringNullableFilter<"Event"> | string | null
    entryFee?: FloatFilter<"Event"> | number
    highlights?: StringFilter<"Event"> | string
    bestLocations?: StringFilter<"Event"> | string
    tips?: StringFilter<"Event"> | string
    createdAt?: DateTimeFilter<"Event"> | Date | string
    updatedAt?: DateTimeFilter<"Event"> | Date | string
  }

  export type EventOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    city?: SortOrder
    country?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    expectedCrowd?: SortOrderInput | SortOrder
    entryFee?: SortOrder
    highlights?: SortOrder
    bestLocations?: SortOrder
    tips?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EventWhereInput | EventWhereInput[]
    OR?: EventWhereInput[]
    NOT?: EventWhereInput | EventWhereInput[]
    name?: StringFilter<"Event"> | string
    city?: StringFilter<"Event"> | string
    country?: StringFilter<"Event"> | string
    startDate?: StringFilter<"Event"> | string
    endDate?: StringFilter<"Event"> | string
    description?: StringNullableFilter<"Event"> | string | null
    category?: StringFilter<"Event"> | string
    expectedCrowd?: StringNullableFilter<"Event"> | string | null
    entryFee?: FloatFilter<"Event"> | number
    highlights?: StringFilter<"Event"> | string
    bestLocations?: StringFilter<"Event"> | string
    tips?: StringFilter<"Event"> | string
    createdAt?: DateTimeFilter<"Event"> | Date | string
    updatedAt?: DateTimeFilter<"Event"> | Date | string
  }, "id">

  export type EventOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    city?: SortOrder
    country?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    expectedCrowd?: SortOrderInput | SortOrder
    entryFee?: SortOrder
    highlights?: SortOrder
    bestLocations?: SortOrder
    tips?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EventCountOrderByAggregateInput
    _avg?: EventAvgOrderByAggregateInput
    _max?: EventMaxOrderByAggregateInput
    _min?: EventMinOrderByAggregateInput
    _sum?: EventSumOrderByAggregateInput
  }

  export type EventScalarWhereWithAggregatesInput = {
    AND?: EventScalarWhereWithAggregatesInput | EventScalarWhereWithAggregatesInput[]
    OR?: EventScalarWhereWithAggregatesInput[]
    NOT?: EventScalarWhereWithAggregatesInput | EventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Event"> | string
    name?: StringWithAggregatesFilter<"Event"> | string
    city?: StringWithAggregatesFilter<"Event"> | string
    country?: StringWithAggregatesFilter<"Event"> | string
    startDate?: StringWithAggregatesFilter<"Event"> | string
    endDate?: StringWithAggregatesFilter<"Event"> | string
    description?: StringNullableWithAggregatesFilter<"Event"> | string | null
    category?: StringWithAggregatesFilter<"Event"> | string
    expectedCrowd?: StringNullableWithAggregatesFilter<"Event"> | string | null
    entryFee?: FloatWithAggregatesFilter<"Event"> | number
    highlights?: StringWithAggregatesFilter<"Event"> | string
    bestLocations?: StringWithAggregatesFilter<"Event"> | string
    tips?: StringWithAggregatesFilter<"Event"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Event"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Event"> | Date | string
  }

  export type CostOfLivingWhereInput = {
    AND?: CostOfLivingWhereInput | CostOfLivingWhereInput[]
    OR?: CostOfLivingWhereInput[]
    NOT?: CostOfLivingWhereInput | CostOfLivingWhereInput[]
    id?: StringFilter<"CostOfLiving"> | string
    city?: StringFilter<"CostOfLiving"> | string
    country?: StringFilter<"CostOfLiving"> | string
    category?: StringFilter<"CostOfLiving"> | string
    dailyCost?: StringFilter<"CostOfLiving"> | string
    weeklyTotalEstimate?: FloatFilter<"CostOfLiving"> | number
    monthlyTotalEstimate?: FloatFilter<"CostOfLiving"> | number
    costBreakdown?: StringFilter<"CostOfLiving"> | string
    createdAt?: DateTimeFilter<"CostOfLiving"> | Date | string
    updatedAt?: DateTimeFilter<"CostOfLiving"> | Date | string
  }

  export type CostOfLivingOrderByWithRelationInput = {
    id?: SortOrder
    city?: SortOrder
    country?: SortOrder
    category?: SortOrder
    dailyCost?: SortOrder
    weeklyTotalEstimate?: SortOrder
    monthlyTotalEstimate?: SortOrder
    costBreakdown?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CostOfLivingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CostOfLivingWhereInput | CostOfLivingWhereInput[]
    OR?: CostOfLivingWhereInput[]
    NOT?: CostOfLivingWhereInput | CostOfLivingWhereInput[]
    city?: StringFilter<"CostOfLiving"> | string
    country?: StringFilter<"CostOfLiving"> | string
    category?: StringFilter<"CostOfLiving"> | string
    dailyCost?: StringFilter<"CostOfLiving"> | string
    weeklyTotalEstimate?: FloatFilter<"CostOfLiving"> | number
    monthlyTotalEstimate?: FloatFilter<"CostOfLiving"> | number
    costBreakdown?: StringFilter<"CostOfLiving"> | string
    createdAt?: DateTimeFilter<"CostOfLiving"> | Date | string
    updatedAt?: DateTimeFilter<"CostOfLiving"> | Date | string
  }, "id">

  export type CostOfLivingOrderByWithAggregationInput = {
    id?: SortOrder
    city?: SortOrder
    country?: SortOrder
    category?: SortOrder
    dailyCost?: SortOrder
    weeklyTotalEstimate?: SortOrder
    monthlyTotalEstimate?: SortOrder
    costBreakdown?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CostOfLivingCountOrderByAggregateInput
    _avg?: CostOfLivingAvgOrderByAggregateInput
    _max?: CostOfLivingMaxOrderByAggregateInput
    _min?: CostOfLivingMinOrderByAggregateInput
    _sum?: CostOfLivingSumOrderByAggregateInput
  }

  export type CostOfLivingScalarWhereWithAggregatesInput = {
    AND?: CostOfLivingScalarWhereWithAggregatesInput | CostOfLivingScalarWhereWithAggregatesInput[]
    OR?: CostOfLivingScalarWhereWithAggregatesInput[]
    NOT?: CostOfLivingScalarWhereWithAggregatesInput | CostOfLivingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CostOfLiving"> | string
    city?: StringWithAggregatesFilter<"CostOfLiving"> | string
    country?: StringWithAggregatesFilter<"CostOfLiving"> | string
    category?: StringWithAggregatesFilter<"CostOfLiving"> | string
    dailyCost?: StringWithAggregatesFilter<"CostOfLiving"> | string
    weeklyTotalEstimate?: FloatWithAggregatesFilter<"CostOfLiving"> | number
    monthlyTotalEstimate?: FloatWithAggregatesFilter<"CostOfLiving"> | number
    costBreakdown?: StringWithAggregatesFilter<"CostOfLiving"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CostOfLiving"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CostOfLiving"> | Date | string
  }

  export type CrowdWhereInput = {
    AND?: CrowdWhereInput | CrowdWhereInput[]
    OR?: CrowdWhereInput[]
    NOT?: CrowdWhereInput | CrowdWhereInput[]
    id?: StringFilter<"Crowd"> | string
    location?: StringFilter<"Crowd"> | string
    date?: StringFilter<"Crowd"> | string
    hourlyData?: StringFilter<"Crowd"> | string
    seasonalFactor?: StringFilter<"Crowd"> | string
    bestTimeToVisit?: StringNullableFilter<"Crowd"> | string | null
    avgWaitTime?: IntNullableFilter<"Crowd"> | number | null
    createdAt?: DateTimeFilter<"Crowd"> | Date | string
    updatedAt?: DateTimeFilter<"Crowd"> | Date | string
  }

  export type CrowdOrderByWithRelationInput = {
    id?: SortOrder
    location?: SortOrder
    date?: SortOrder
    hourlyData?: SortOrder
    seasonalFactor?: SortOrder
    bestTimeToVisit?: SortOrderInput | SortOrder
    avgWaitTime?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CrowdWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CrowdWhereInput | CrowdWhereInput[]
    OR?: CrowdWhereInput[]
    NOT?: CrowdWhereInput | CrowdWhereInput[]
    location?: StringFilter<"Crowd"> | string
    date?: StringFilter<"Crowd"> | string
    hourlyData?: StringFilter<"Crowd"> | string
    seasonalFactor?: StringFilter<"Crowd"> | string
    bestTimeToVisit?: StringNullableFilter<"Crowd"> | string | null
    avgWaitTime?: IntNullableFilter<"Crowd"> | number | null
    createdAt?: DateTimeFilter<"Crowd"> | Date | string
    updatedAt?: DateTimeFilter<"Crowd"> | Date | string
  }, "id">

  export type CrowdOrderByWithAggregationInput = {
    id?: SortOrder
    location?: SortOrder
    date?: SortOrder
    hourlyData?: SortOrder
    seasonalFactor?: SortOrder
    bestTimeToVisit?: SortOrderInput | SortOrder
    avgWaitTime?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CrowdCountOrderByAggregateInput
    _avg?: CrowdAvgOrderByAggregateInput
    _max?: CrowdMaxOrderByAggregateInput
    _min?: CrowdMinOrderByAggregateInput
    _sum?: CrowdSumOrderByAggregateInput
  }

  export type CrowdScalarWhereWithAggregatesInput = {
    AND?: CrowdScalarWhereWithAggregatesInput | CrowdScalarWhereWithAggregatesInput[]
    OR?: CrowdScalarWhereWithAggregatesInput[]
    NOT?: CrowdScalarWhereWithAggregatesInput | CrowdScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Crowd"> | string
    location?: StringWithAggregatesFilter<"Crowd"> | string
    date?: StringWithAggregatesFilter<"Crowd"> | string
    hourlyData?: StringWithAggregatesFilter<"Crowd"> | string
    seasonalFactor?: StringWithAggregatesFilter<"Crowd"> | string
    bestTimeToVisit?: StringNullableWithAggregatesFilter<"Crowd"> | string | null
    avgWaitTime?: IntNullableWithAggregatesFilter<"Crowd"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Crowd"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Crowd"> | Date | string
  }

  export type CurrencyWhereInput = {
    AND?: CurrencyWhereInput | CurrencyWhereInput[]
    OR?: CurrencyWhereInput[]
    NOT?: CurrencyWhereInput | CurrencyWhereInput[]
    id?: StringFilter<"Currency"> | string
    date?: StringFilter<"Currency"> | string
    baseCurrency?: StringFilter<"Currency"> | string
    rates?: StringFilter<"Currency"> | string
    createdAt?: DateTimeFilter<"Currency"> | Date | string
    updatedAt?: DateTimeFilter<"Currency"> | Date | string
  }

  export type CurrencyOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    baseCurrency?: SortOrder
    rates?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CurrencyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CurrencyWhereInput | CurrencyWhereInput[]
    OR?: CurrencyWhereInput[]
    NOT?: CurrencyWhereInput | CurrencyWhereInput[]
    date?: StringFilter<"Currency"> | string
    baseCurrency?: StringFilter<"Currency"> | string
    rates?: StringFilter<"Currency"> | string
    createdAt?: DateTimeFilter<"Currency"> | Date | string
    updatedAt?: DateTimeFilter<"Currency"> | Date | string
  }, "id">

  export type CurrencyOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    baseCurrency?: SortOrder
    rates?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CurrencyCountOrderByAggregateInput
    _max?: CurrencyMaxOrderByAggregateInput
    _min?: CurrencyMinOrderByAggregateInput
  }

  export type CurrencyScalarWhereWithAggregatesInput = {
    AND?: CurrencyScalarWhereWithAggregatesInput | CurrencyScalarWhereWithAggregatesInput[]
    OR?: CurrencyScalarWhereWithAggregatesInput[]
    NOT?: CurrencyScalarWhereWithAggregatesInput | CurrencyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Currency"> | string
    date?: StringWithAggregatesFilter<"Currency"> | string
    baseCurrency?: StringWithAggregatesFilter<"Currency"> | string
    rates?: StringWithAggregatesFilter<"Currency"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Currency"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Currency"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    passwordHash: string
    fullName: string
    profilePhotoUrl?: string | null
    preferredLanguage?: string
    preferredCurrency?: string
    emailVerified?: boolean
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    trips?: TripCreateNestedManyWithoutUserInput
    savedDestinations?: UserSavedDestinationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    passwordHash: string
    fullName: string
    profilePhotoUrl?: string | null
    preferredLanguage?: string
    preferredCurrency?: string
    emailVerified?: boolean
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    trips?: TripUncheckedCreateNestedManyWithoutUserInput
    savedDestinations?: UserSavedDestinationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    preferredCurrency?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trips?: TripUpdateManyWithoutUserNestedInput
    savedDestinations?: UserSavedDestinationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    preferredCurrency?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trips?: TripUncheckedUpdateManyWithoutUserNestedInput
    savedDestinations?: UserSavedDestinationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    passwordHash: string
    fullName: string
    profilePhotoUrl?: string | null
    preferredLanguage?: string
    preferredCurrency?: string
    emailVerified?: boolean
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    preferredCurrency?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    preferredCurrency?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RoleCreateInput = {
    id?: string
    name: string
    description?: string | null
    permissions?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userRoles?: UserRoleCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    permissions?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userRoles?: UserRoleUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userRoles?: UserRoleUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    permissions?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleCreateInput = {
    id?: string
    assignedAt?: Date | string
    user: UserCreateNestedOneWithoutUserRolesInput
    role: RoleCreateNestedOneWithoutUserRolesInput
  }

  export type UserRoleUncheckedCreateInput = {
    id?: string
    userId: string
    roleId: string
    assignedAt?: Date | string
  }

  export type UserRoleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserRolesNestedInput
    role?: RoleUpdateOneRequiredWithoutUserRolesNestedInput
  }

  export type UserRoleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleCreateManyInput = {
    id?: string
    userId: string
    roleId: string
    assignedAt?: Date | string
  }

  export type UserRoleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CityCreateInput = {
    id?: string
    name: string
    country: string
    countryCode: string
    region?: string | null
    latitude: number
    longitude: number
    timezone?: string
    costIndex?: number
    popularityScore?: number
    description?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    activities?: ActivityCreateNestedManyWithoutCityInput
    hotels?: HotelCreateNestedManyWithoutCityInput
    restaurants?: RestaurantCreateNestedManyWithoutCityInput
    transportFrom?: TransportCreateNestedManyWithoutFromCityInput
    transportTo?: TransportCreateNestedManyWithoutToCityInput
    tripStops?: TripStopCreateNestedManyWithoutCityInput
    savedDestinations?: UserSavedDestinationCreateNestedManyWithoutCityInput
  }

  export type CityUncheckedCreateInput = {
    id?: string
    name: string
    country: string
    countryCode: string
    region?: string | null
    latitude: number
    longitude: number
    timezone?: string
    costIndex?: number
    popularityScore?: number
    description?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    activities?: ActivityUncheckedCreateNestedManyWithoutCityInput
    hotels?: HotelUncheckedCreateNestedManyWithoutCityInput
    restaurants?: RestaurantUncheckedCreateNestedManyWithoutCityInput
    transportFrom?: TransportUncheckedCreateNestedManyWithoutFromCityInput
    transportTo?: TransportUncheckedCreateNestedManyWithoutToCityInput
    tripStops?: TripStopUncheckedCreateNestedManyWithoutCityInput
    savedDestinations?: UserSavedDestinationUncheckedCreateNestedManyWithoutCityInput
  }

  export type CityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    costIndex?: FloatFieldUpdateOperationsInput | number
    popularityScore?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activities?: ActivityUpdateManyWithoutCityNestedInput
    hotels?: HotelUpdateManyWithoutCityNestedInput
    restaurants?: RestaurantUpdateManyWithoutCityNestedInput
    transportFrom?: TransportUpdateManyWithoutFromCityNestedInput
    transportTo?: TransportUpdateManyWithoutToCityNestedInput
    tripStops?: TripStopUpdateManyWithoutCityNestedInput
    savedDestinations?: UserSavedDestinationUpdateManyWithoutCityNestedInput
  }

  export type CityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    costIndex?: FloatFieldUpdateOperationsInput | number
    popularityScore?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activities?: ActivityUncheckedUpdateManyWithoutCityNestedInput
    hotels?: HotelUncheckedUpdateManyWithoutCityNestedInput
    restaurants?: RestaurantUncheckedUpdateManyWithoutCityNestedInput
    transportFrom?: TransportUncheckedUpdateManyWithoutFromCityNestedInput
    transportTo?: TransportUncheckedUpdateManyWithoutToCityNestedInput
    tripStops?: TripStopUncheckedUpdateManyWithoutCityNestedInput
    savedDestinations?: UserSavedDestinationUncheckedUpdateManyWithoutCityNestedInput
  }

  export type CityCreateManyInput = {
    id?: string
    name: string
    country: string
    countryCode: string
    region?: string | null
    latitude: number
    longitude: number
    timezone?: string
    costIndex?: number
    popularityScore?: number
    description?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type CityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    costIndex?: FloatFieldUpdateOperationsInput | number
    popularityScore?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    costIndex?: FloatFieldUpdateOperationsInput | number
    popularityScore?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ActivityCreateInput = {
    id?: string
    name: string
    category: string
    description?: string | null
    estimatedCost?: number
    currency?: string
    durationMinutes?: number | null
    imageUrl?: string | null
    rating?: number | null
    popularityScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    city: CityCreateNestedOneWithoutActivitiesInput
    stopActivities?: StopActivityCreateNestedManyWithoutActivityInput
  }

  export type ActivityUncheckedCreateInput = {
    id?: string
    cityId: string
    name: string
    category: string
    description?: string | null
    estimatedCost?: number
    currency?: string
    durationMinutes?: number | null
    imageUrl?: string | null
    rating?: number | null
    popularityScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    stopActivities?: StopActivityUncheckedCreateNestedManyWithoutActivityInput
  }

  export type ActivityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCost?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    popularityScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    city?: CityUpdateOneRequiredWithoutActivitiesNestedInput
    stopActivities?: StopActivityUpdateManyWithoutActivityNestedInput
  }

  export type ActivityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCost?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    popularityScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stopActivities?: StopActivityUncheckedUpdateManyWithoutActivityNestedInput
  }

  export type ActivityCreateManyInput = {
    id?: string
    cityId: string
    name: string
    category: string
    description?: string | null
    estimatedCost?: number
    currency?: string
    durationMinutes?: number | null
    imageUrl?: string | null
    rating?: number | null
    popularityScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ActivityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCost?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    popularityScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ActivityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCost?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    popularityScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type HotelCreateInput = {
    id?: string
    name: string
    category: string
    description?: string | null
    pricePerNight: number
    currency?: string
    rating?: number | null
    amenities?: string | null
    address?: string | null
    imageUrl?: string | null
    contactPhone?: string | null
    website?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    city: CityCreateNestedOneWithoutHotelsInput
  }

  export type HotelUncheckedCreateInput = {
    id?: string
    cityId: string
    name: string
    category: string
    description?: string | null
    pricePerNight: number
    currency?: string
    rating?: number | null
    amenities?: string | null
    address?: string | null
    imageUrl?: string | null
    contactPhone?: string | null
    website?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type HotelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pricePerNight?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    amenities?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    city?: CityUpdateOneRequiredWithoutHotelsNestedInput
  }

  export type HotelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pricePerNight?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    amenities?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type HotelCreateManyInput = {
    id?: string
    cityId: string
    name: string
    category: string
    description?: string | null
    pricePerNight: number
    currency?: string
    rating?: number | null
    amenities?: string | null
    address?: string | null
    imageUrl?: string | null
    contactPhone?: string | null
    website?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type HotelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pricePerNight?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    amenities?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type HotelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pricePerNight?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    amenities?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RestaurantCreateInput = {
    id?: string
    name: string
    cuisineType: string
    priceRange: string
    avgMealCost: number
    currency?: string
    rating?: number | null
    description?: string | null
    address?: string | null
    imageUrl?: string | null
    isVegetarian?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    city: CityCreateNestedOneWithoutRestaurantsInput
  }

  export type RestaurantUncheckedCreateInput = {
    id?: string
    cityId: string
    name: string
    cuisineType: string
    priceRange: string
    avgMealCost: number
    currency?: string
    rating?: number | null
    description?: string | null
    address?: string | null
    imageUrl?: string | null
    isVegetarian?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type RestaurantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cuisineType?: StringFieldUpdateOperationsInput | string
    priceRange?: StringFieldUpdateOperationsInput | string
    avgMealCost?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isVegetarian?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    city?: CityUpdateOneRequiredWithoutRestaurantsNestedInput
  }

  export type RestaurantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cuisineType?: StringFieldUpdateOperationsInput | string
    priceRange?: StringFieldUpdateOperationsInput | string
    avgMealCost?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isVegetarian?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RestaurantCreateManyInput = {
    id?: string
    cityId: string
    name: string
    cuisineType: string
    priceRange: string
    avgMealCost: number
    currency?: string
    rating?: number | null
    description?: string | null
    address?: string | null
    imageUrl?: string | null
    isVegetarian?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type RestaurantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cuisineType?: StringFieldUpdateOperationsInput | string
    priceRange?: StringFieldUpdateOperationsInput | string
    avgMealCost?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isVegetarian?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RestaurantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cuisineType?: StringFieldUpdateOperationsInput | string
    priceRange?: StringFieldUpdateOperationsInput | string
    avgMealCost?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isVegetarian?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransportCreateInput = {
    id?: string
    transportType: string
    operatorName: string
    departureTime: string
    arrivalTime: string
    durationMinutes: number
    price: number
    currency?: string
    classType?: string | null
    frequency?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    fromCity: CityCreateNestedOneWithoutTransportFromInput
    toCity: CityCreateNestedOneWithoutTransportToInput
  }

  export type TransportUncheckedCreateInput = {
    id?: string
    fromCityId: string
    toCityId: string
    transportType: string
    operatorName: string
    departureTime: string
    arrivalTime: string
    durationMinutes: number
    price: number
    currency?: string
    classType?: string | null
    frequency?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type TransportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    transportType?: StringFieldUpdateOperationsInput | string
    operatorName?: StringFieldUpdateOperationsInput | string
    departureTime?: StringFieldUpdateOperationsInput | string
    arrivalTime?: StringFieldUpdateOperationsInput | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    classType?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fromCity?: CityUpdateOneRequiredWithoutTransportFromNestedInput
    toCity?: CityUpdateOneRequiredWithoutTransportToNestedInput
  }

  export type TransportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromCityId?: StringFieldUpdateOperationsInput | string
    toCityId?: StringFieldUpdateOperationsInput | string
    transportType?: StringFieldUpdateOperationsInput | string
    operatorName?: StringFieldUpdateOperationsInput | string
    departureTime?: StringFieldUpdateOperationsInput | string
    arrivalTime?: StringFieldUpdateOperationsInput | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    classType?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransportCreateManyInput = {
    id?: string
    fromCityId: string
    toCityId: string
    transportType: string
    operatorName: string
    departureTime: string
    arrivalTime: string
    durationMinutes: number
    price: number
    currency?: string
    classType?: string | null
    frequency?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type TransportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    transportType?: StringFieldUpdateOperationsInput | string
    operatorName?: StringFieldUpdateOperationsInput | string
    departureTime?: StringFieldUpdateOperationsInput | string
    arrivalTime?: StringFieldUpdateOperationsInput | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    classType?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromCityId?: StringFieldUpdateOperationsInput | string
    toCityId?: StringFieldUpdateOperationsInput | string
    transportType?: StringFieldUpdateOperationsInput | string
    operatorName?: StringFieldUpdateOperationsInput | string
    departureTime?: StringFieldUpdateOperationsInput | string
    arrivalTime?: StringFieldUpdateOperationsInput | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    classType?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TripCreateInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    coverPhotoUrl?: string | null
    status?: string
    isPublic?: boolean
    totalEstimatedCost?: number
    currency?: string
    travelStyle?: string | null
    versionNumber?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user: UserCreateNestedOneWithoutTripsInput
    stops?: TripStopCreateNestedManyWithoutTripInput
    budgets?: TripBudgetCreateNestedManyWithoutTripInput
    media?: TripMediaCreateNestedManyWithoutTripInput
    shares?: TripShareCreateNestedManyWithoutTripInput
    versions?: TripVersionCreateNestedManyWithoutTripInput
  }

  export type TripUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    coverPhotoUrl?: string | null
    status?: string
    isPublic?: boolean
    totalEstimatedCost?: number
    currency?: string
    travelStyle?: string | null
    versionNumber?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    stops?: TripStopUncheckedCreateNestedManyWithoutTripInput
    budgets?: TripBudgetUncheckedCreateNestedManyWithoutTripInput
    media?: TripMediaUncheckedCreateNestedManyWithoutTripInput
    shares?: TripShareUncheckedCreateNestedManyWithoutTripInput
    versions?: TripVersionUncheckedCreateNestedManyWithoutTripInput
  }

  export type TripUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    coverPhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    totalEstimatedCost?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    travelStyle?: NullableStringFieldUpdateOperationsInput | string | null
    versionNumber?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutTripsNestedInput
    stops?: TripStopUpdateManyWithoutTripNestedInput
    budgets?: TripBudgetUpdateManyWithoutTripNestedInput
    media?: TripMediaUpdateManyWithoutTripNestedInput
    shares?: TripShareUpdateManyWithoutTripNestedInput
    versions?: TripVersionUpdateManyWithoutTripNestedInput
  }

  export type TripUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    coverPhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    totalEstimatedCost?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    travelStyle?: NullableStringFieldUpdateOperationsInput | string | null
    versionNumber?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stops?: TripStopUncheckedUpdateManyWithoutTripNestedInput
    budgets?: TripBudgetUncheckedUpdateManyWithoutTripNestedInput
    media?: TripMediaUncheckedUpdateManyWithoutTripNestedInput
    shares?: TripShareUncheckedUpdateManyWithoutTripNestedInput
    versions?: TripVersionUncheckedUpdateManyWithoutTripNestedInput
  }

  export type TripCreateManyInput = {
    id?: string
    userId: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    coverPhotoUrl?: string | null
    status?: string
    isPublic?: boolean
    totalEstimatedCost?: number
    currency?: string
    travelStyle?: string | null
    versionNumber?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type TripUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    coverPhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    totalEstimatedCost?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    travelStyle?: NullableStringFieldUpdateOperationsInput | string | null
    versionNumber?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TripUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    coverPhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    totalEstimatedCost?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    travelStyle?: NullableStringFieldUpdateOperationsInput | string | null
    versionNumber?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TripStopCreateInput = {
    id?: string
    stopOrder: number
    arrivalDate: Date | string
    departureDate: Date | string
    accommodationName?: string | null
    accommodationCost?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    trip: TripCreateNestedOneWithoutStopsInput
    city: CityCreateNestedOneWithoutTripStopsInput
    activities?: StopActivityCreateNestedManyWithoutTripStopInput
  }

  export type TripStopUncheckedCreateInput = {
    id?: string
    tripId: string
    cityId: string
    stopOrder: number
    arrivalDate: Date | string
    departureDate: Date | string
    accommodationName?: string | null
    accommodationCost?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    activities?: StopActivityUncheckedCreateNestedManyWithoutTripStopInput
  }

  export type TripStopUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stopOrder?: IntFieldUpdateOperationsInput | number
    arrivalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    departureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accommodationName?: NullableStringFieldUpdateOperationsInput | string | null
    accommodationCost?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trip?: TripUpdateOneRequiredWithoutStopsNestedInput
    city?: CityUpdateOneRequiredWithoutTripStopsNestedInput
    activities?: StopActivityUpdateManyWithoutTripStopNestedInput
  }

  export type TripStopUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripId?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    stopOrder?: IntFieldUpdateOperationsInput | number
    arrivalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    departureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accommodationName?: NullableStringFieldUpdateOperationsInput | string | null
    accommodationCost?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activities?: StopActivityUncheckedUpdateManyWithoutTripStopNestedInput
  }

  export type TripStopCreateManyInput = {
    id?: string
    tripId: string
    cityId: string
    stopOrder: number
    arrivalDate: Date | string
    departureDate: Date | string
    accommodationName?: string | null
    accommodationCost?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type TripStopUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    stopOrder?: IntFieldUpdateOperationsInput | number
    arrivalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    departureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accommodationName?: NullableStringFieldUpdateOperationsInput | string | null
    accommodationCost?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TripStopUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripId?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    stopOrder?: IntFieldUpdateOperationsInput | number
    arrivalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    departureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accommodationName?: NullableStringFieldUpdateOperationsInput | string | null
    accommodationCost?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StopActivityCreateInput = {
    id?: string
    scheduledDate: Date | string
    scheduledTime?: string | null
    actualCost?: number | null
    notes?: string | null
    isCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tripStop: TripStopCreateNestedOneWithoutActivitiesInput
    activity: ActivityCreateNestedOneWithoutStopActivitiesInput
  }

  export type StopActivityUncheckedCreateInput = {
    id?: string
    tripStopId: string
    activityId: string
    scheduledDate: Date | string
    scheduledTime?: string | null
    actualCost?: number | null
    notes?: string | null
    isCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type StopActivityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledTime?: NullableStringFieldUpdateOperationsInput | string | null
    actualCost?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tripStop?: TripStopUpdateOneRequiredWithoutActivitiesNestedInput
    activity?: ActivityUpdateOneRequiredWithoutStopActivitiesNestedInput
  }

  export type StopActivityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripStopId?: StringFieldUpdateOperationsInput | string
    activityId?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledTime?: NullableStringFieldUpdateOperationsInput | string | null
    actualCost?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StopActivityCreateManyInput = {
    id?: string
    tripStopId: string
    activityId: string
    scheduledDate: Date | string
    scheduledTime?: string | null
    actualCost?: number | null
    notes?: string | null
    isCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type StopActivityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledTime?: NullableStringFieldUpdateOperationsInput | string | null
    actualCost?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StopActivityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripStopId?: StringFieldUpdateOperationsInput | string
    activityId?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledTime?: NullableStringFieldUpdateOperationsInput | string | null
    actualCost?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TripBudgetCreateInput = {
    id?: string
    category: string
    estimatedAmount?: number
    actualAmount?: number | null
    currency?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    trip: TripCreateNestedOneWithoutBudgetsInput
  }

  export type TripBudgetUncheckedCreateInput = {
    id?: string
    tripId: string
    category: string
    estimatedAmount?: number
    actualAmount?: number | null
    currency?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type TripBudgetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    estimatedAmount?: FloatFieldUpdateOperationsInput | number
    actualAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trip?: TripUpdateOneRequiredWithoutBudgetsNestedInput
  }

  export type TripBudgetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripId?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    estimatedAmount?: FloatFieldUpdateOperationsInput | number
    actualAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TripBudgetCreateManyInput = {
    id?: string
    tripId: string
    category: string
    estimatedAmount?: number
    actualAmount?: number | null
    currency?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type TripBudgetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    estimatedAmount?: FloatFieldUpdateOperationsInput | number
    actualAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TripBudgetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripId?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    estimatedAmount?: FloatFieldUpdateOperationsInput | number
    actualAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TripMediaCreateInput = {
    id?: string
    mediaType: string
    mediaUrl: string
    thumbnailUrl?: string | null
    caption?: string | null
    displayOrder?: number | null
    uploadedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    trip: TripCreateNestedOneWithoutMediaInput
  }

  export type TripMediaUncheckedCreateInput = {
    id?: string
    tripId: string
    mediaType: string
    mediaUrl: string
    thumbnailUrl?: string | null
    caption?: string | null
    displayOrder?: number | null
    uploadedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type TripMediaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    mediaType?: StringFieldUpdateOperationsInput | string
    mediaUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trip?: TripUpdateOneRequiredWithoutMediaNestedInput
  }

  export type TripMediaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripId?: StringFieldUpdateOperationsInput | string
    mediaType?: StringFieldUpdateOperationsInput | string
    mediaUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TripMediaCreateManyInput = {
    id?: string
    tripId: string
    mediaType: string
    mediaUrl: string
    thumbnailUrl?: string | null
    caption?: string | null
    displayOrder?: number | null
    uploadedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type TripMediaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    mediaType?: StringFieldUpdateOperationsInput | string
    mediaUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TripMediaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripId?: StringFieldUpdateOperationsInput | string
    mediaType?: StringFieldUpdateOperationsInput | string
    mediaUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TripShareCreateInput = {
    id?: string
    shareToken: string
    shareType?: string
    sharedWithEmail?: string | null
    viewCount?: number
    lastViewedAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    trip: TripCreateNestedOneWithoutSharesInput
  }

  export type TripShareUncheckedCreateInput = {
    id?: string
    tripId: string
    shareToken: string
    shareType?: string
    sharedWithEmail?: string | null
    viewCount?: number
    lastViewedAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type TripShareUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    shareToken?: StringFieldUpdateOperationsInput | string
    shareType?: StringFieldUpdateOperationsInput | string
    sharedWithEmail?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    lastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trip?: TripUpdateOneRequiredWithoutSharesNestedInput
  }

  export type TripShareUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripId?: StringFieldUpdateOperationsInput | string
    shareToken?: StringFieldUpdateOperationsInput | string
    shareType?: StringFieldUpdateOperationsInput | string
    sharedWithEmail?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    lastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TripShareCreateManyInput = {
    id?: string
    tripId: string
    shareToken: string
    shareType?: string
    sharedWithEmail?: string | null
    viewCount?: number
    lastViewedAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type TripShareUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    shareToken?: StringFieldUpdateOperationsInput | string
    shareType?: StringFieldUpdateOperationsInput | string
    sharedWithEmail?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    lastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TripShareUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripId?: StringFieldUpdateOperationsInput | string
    shareToken?: StringFieldUpdateOperationsInput | string
    shareType?: StringFieldUpdateOperationsInput | string
    sharedWithEmail?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    lastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TripVersionCreateInput = {
    id?: string
    versionNumber: number
    snapshotData: string
    changeSummary?: string | null
    createdBy: string
    createdAt?: Date | string
    trip: TripCreateNestedOneWithoutVersionsInput
  }

  export type TripVersionUncheckedCreateInput = {
    id?: string
    tripId: string
    versionNumber: number
    snapshotData: string
    changeSummary?: string | null
    createdBy: string
    createdAt?: Date | string
  }

  export type TripVersionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    snapshotData?: StringFieldUpdateOperationsInput | string
    changeSummary?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trip?: TripUpdateOneRequiredWithoutVersionsNestedInput
  }

  export type TripVersionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripId?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    snapshotData?: StringFieldUpdateOperationsInput | string
    changeSummary?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TripVersionCreateManyInput = {
    id?: string
    tripId: string
    versionNumber: number
    snapshotData: string
    changeSummary?: string | null
    createdBy: string
    createdAt?: Date | string
  }

  export type TripVersionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    snapshotData?: StringFieldUpdateOperationsInput | string
    changeSummary?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TripVersionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripId?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    snapshotData?: StringFieldUpdateOperationsInput | string
    changeSummary?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSavedDestinationCreateInput = {
    id?: string
    notes?: string | null
    savedAt?: Date | string
    user: UserCreateNestedOneWithoutSavedDestinationsInput
    city: CityCreateNestedOneWithoutSavedDestinationsInput
  }

  export type UserSavedDestinationUncheckedCreateInput = {
    id?: string
    userId: string
    cityId: string
    notes?: string | null
    savedAt?: Date | string
  }

  export type UserSavedDestinationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    savedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSavedDestinationsNestedInput
    city?: CityUpdateOneRequiredWithoutSavedDestinationsNestedInput
  }

  export type UserSavedDestinationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    savedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSavedDestinationCreateManyInput = {
    id?: string
    userId: string
    cityId: string
    notes?: string | null
    savedAt?: Date | string
  }

  export type UserSavedDestinationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    savedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSavedDestinationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    savedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateInput = {
    id?: string
    action: string
    entityType: string
    entityId: string
    changes?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    userId?: string | null
    action: string
    entityType: string
    entityId: string
    changes?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    changes?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    changes?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    userId?: string | null
    action: string
    entityType: string
    entityId: string
    changes?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    changes?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    changes?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeatherCreateInput = {
    id?: string
    cityId?: string | null
    city: string
    date: string
    current: string
    forecast: string
    hourlyForecast: string
    recommendation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WeatherUncheckedCreateInput = {
    id?: string
    cityId?: string | null
    city: string
    date: string
    current: string
    forecast: string
    hourlyForecast: string
    recommendation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WeatherUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    current?: StringFieldUpdateOperationsInput | string
    forecast?: StringFieldUpdateOperationsInput | string
    hourlyForecast?: StringFieldUpdateOperationsInput | string
    recommendation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeatherUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    current?: StringFieldUpdateOperationsInput | string
    forecast?: StringFieldUpdateOperationsInput | string
    hourlyForecast?: StringFieldUpdateOperationsInput | string
    recommendation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeatherCreateManyInput = {
    id?: string
    cityId?: string | null
    city: string
    date: string
    current: string
    forecast: string
    hourlyForecast: string
    recommendation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WeatherUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    current?: StringFieldUpdateOperationsInput | string
    forecast?: StringFieldUpdateOperationsInput | string
    hourlyForecast?: StringFieldUpdateOperationsInput | string
    recommendation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeatherUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    current?: StringFieldUpdateOperationsInput | string
    forecast?: StringFieldUpdateOperationsInput | string
    hourlyForecast?: StringFieldUpdateOperationsInput | string
    recommendation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GuideCreateInput = {
    id?: string
    cityId?: string | null
    name: string
    specialization: string
    city: string
    languages: string
    certification?: string | null
    yearsOfExperience: number
    rating?: number | null
    reviews?: number
    pricePerDay: string
    availability: string
    groupSize: string
    skills: string
    tours: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GuideUncheckedCreateInput = {
    id?: string
    cityId?: string | null
    name: string
    specialization: string
    city: string
    languages: string
    certification?: string | null
    yearsOfExperience: number
    rating?: number | null
    reviews?: number
    pricePerDay: string
    availability: string
    groupSize: string
    skills: string
    tours: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GuideUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    specialization?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    languages?: StringFieldUpdateOperationsInput | string
    certification?: NullableStringFieldUpdateOperationsInput | string | null
    yearsOfExperience?: IntFieldUpdateOperationsInput | number
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviews?: IntFieldUpdateOperationsInput | number
    pricePerDay?: StringFieldUpdateOperationsInput | string
    availability?: StringFieldUpdateOperationsInput | string
    groupSize?: StringFieldUpdateOperationsInput | string
    skills?: StringFieldUpdateOperationsInput | string
    tours?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GuideUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    specialization?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    languages?: StringFieldUpdateOperationsInput | string
    certification?: NullableStringFieldUpdateOperationsInput | string | null
    yearsOfExperience?: IntFieldUpdateOperationsInput | number
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviews?: IntFieldUpdateOperationsInput | number
    pricePerDay?: StringFieldUpdateOperationsInput | string
    availability?: StringFieldUpdateOperationsInput | string
    groupSize?: StringFieldUpdateOperationsInput | string
    skills?: StringFieldUpdateOperationsInput | string
    tours?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GuideCreateManyInput = {
    id?: string
    cityId?: string | null
    name: string
    specialization: string
    city: string
    languages: string
    certification?: string | null
    yearsOfExperience: number
    rating?: number | null
    reviews?: number
    pricePerDay: string
    availability: string
    groupSize: string
    skills: string
    tours: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GuideUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    specialization?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    languages?: StringFieldUpdateOperationsInput | string
    certification?: NullableStringFieldUpdateOperationsInput | string | null
    yearsOfExperience?: IntFieldUpdateOperationsInput | number
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviews?: IntFieldUpdateOperationsInput | number
    pricePerDay?: StringFieldUpdateOperationsInput | string
    availability?: StringFieldUpdateOperationsInput | string
    groupSize?: StringFieldUpdateOperationsInput | string
    skills?: StringFieldUpdateOperationsInput | string
    tours?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GuideUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    specialization?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    languages?: StringFieldUpdateOperationsInput | string
    certification?: NullableStringFieldUpdateOperationsInput | string | null
    yearsOfExperience?: IntFieldUpdateOperationsInput | number
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviews?: IntFieldUpdateOperationsInput | number
    pricePerDay?: StringFieldUpdateOperationsInput | string
    availability?: StringFieldUpdateOperationsInput | string
    groupSize?: StringFieldUpdateOperationsInput | string
    skills?: StringFieldUpdateOperationsInput | string
    tours?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventCreateInput = {
    id?: string
    name: string
    city: string
    country: string
    startDate: string
    endDate: string
    description?: string | null
    category: string
    expectedCrowd?: string | null
    entryFee?: number
    highlights: string
    bestLocations: string
    tips: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventUncheckedCreateInput = {
    id?: string
    name: string
    city: string
    country: string
    startDate: string
    endDate: string
    description?: string | null
    category: string
    expectedCrowd?: string | null
    entryFee?: number
    highlights: string
    bestLocations: string
    tips: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    startDate?: StringFieldUpdateOperationsInput | string
    endDate?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    expectedCrowd?: NullableStringFieldUpdateOperationsInput | string | null
    entryFee?: FloatFieldUpdateOperationsInput | number
    highlights?: StringFieldUpdateOperationsInput | string
    bestLocations?: StringFieldUpdateOperationsInput | string
    tips?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    startDate?: StringFieldUpdateOperationsInput | string
    endDate?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    expectedCrowd?: NullableStringFieldUpdateOperationsInput | string | null
    entryFee?: FloatFieldUpdateOperationsInput | number
    highlights?: StringFieldUpdateOperationsInput | string
    bestLocations?: StringFieldUpdateOperationsInput | string
    tips?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventCreateManyInput = {
    id?: string
    name: string
    city: string
    country: string
    startDate: string
    endDate: string
    description?: string | null
    category: string
    expectedCrowd?: string | null
    entryFee?: number
    highlights: string
    bestLocations: string
    tips: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    startDate?: StringFieldUpdateOperationsInput | string
    endDate?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    expectedCrowd?: NullableStringFieldUpdateOperationsInput | string | null
    entryFee?: FloatFieldUpdateOperationsInput | number
    highlights?: StringFieldUpdateOperationsInput | string
    bestLocations?: StringFieldUpdateOperationsInput | string
    tips?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    startDate?: StringFieldUpdateOperationsInput | string
    endDate?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    expectedCrowd?: NullableStringFieldUpdateOperationsInput | string | null
    entryFee?: FloatFieldUpdateOperationsInput | number
    highlights?: StringFieldUpdateOperationsInput | string
    bestLocations?: StringFieldUpdateOperationsInput | string
    tips?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CostOfLivingCreateInput = {
    id?: string
    city: string
    country: string
    category: string
    dailyCost: string
    weeklyTotalEstimate: number
    monthlyTotalEstimate: number
    costBreakdown: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CostOfLivingUncheckedCreateInput = {
    id?: string
    city: string
    country: string
    category: string
    dailyCost: string
    weeklyTotalEstimate: number
    monthlyTotalEstimate: number
    costBreakdown: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CostOfLivingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    dailyCost?: StringFieldUpdateOperationsInput | string
    weeklyTotalEstimate?: FloatFieldUpdateOperationsInput | number
    monthlyTotalEstimate?: FloatFieldUpdateOperationsInput | number
    costBreakdown?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CostOfLivingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    dailyCost?: StringFieldUpdateOperationsInput | string
    weeklyTotalEstimate?: FloatFieldUpdateOperationsInput | number
    monthlyTotalEstimate?: FloatFieldUpdateOperationsInput | number
    costBreakdown?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CostOfLivingCreateManyInput = {
    id?: string
    city: string
    country: string
    category: string
    dailyCost: string
    weeklyTotalEstimate: number
    monthlyTotalEstimate: number
    costBreakdown: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CostOfLivingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    dailyCost?: StringFieldUpdateOperationsInput | string
    weeklyTotalEstimate?: FloatFieldUpdateOperationsInput | number
    monthlyTotalEstimate?: FloatFieldUpdateOperationsInput | number
    costBreakdown?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CostOfLivingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    dailyCost?: StringFieldUpdateOperationsInput | string
    weeklyTotalEstimate?: FloatFieldUpdateOperationsInput | number
    monthlyTotalEstimate?: FloatFieldUpdateOperationsInput | number
    costBreakdown?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CrowdCreateInput = {
    id?: string
    location: string
    date: string
    hourlyData: string
    seasonalFactor: string
    bestTimeToVisit?: string | null
    avgWaitTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CrowdUncheckedCreateInput = {
    id?: string
    location: string
    date: string
    hourlyData: string
    seasonalFactor: string
    bestTimeToVisit?: string | null
    avgWaitTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CrowdUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    hourlyData?: StringFieldUpdateOperationsInput | string
    seasonalFactor?: StringFieldUpdateOperationsInput | string
    bestTimeToVisit?: NullableStringFieldUpdateOperationsInput | string | null
    avgWaitTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CrowdUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    hourlyData?: StringFieldUpdateOperationsInput | string
    seasonalFactor?: StringFieldUpdateOperationsInput | string
    bestTimeToVisit?: NullableStringFieldUpdateOperationsInput | string | null
    avgWaitTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CrowdCreateManyInput = {
    id?: string
    location: string
    date: string
    hourlyData: string
    seasonalFactor: string
    bestTimeToVisit?: string | null
    avgWaitTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CrowdUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    hourlyData?: StringFieldUpdateOperationsInput | string
    seasonalFactor?: StringFieldUpdateOperationsInput | string
    bestTimeToVisit?: NullableStringFieldUpdateOperationsInput | string | null
    avgWaitTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CrowdUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    hourlyData?: StringFieldUpdateOperationsInput | string
    seasonalFactor?: StringFieldUpdateOperationsInput | string
    bestTimeToVisit?: NullableStringFieldUpdateOperationsInput | string | null
    avgWaitTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CurrencyCreateInput = {
    id?: string
    date: string
    baseCurrency: string
    rates: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CurrencyUncheckedCreateInput = {
    id?: string
    date: string
    baseCurrency: string
    rates: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CurrencyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    baseCurrency?: StringFieldUpdateOperationsInput | string
    rates?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CurrencyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    baseCurrency?: StringFieldUpdateOperationsInput | string
    rates?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CurrencyCreateManyInput = {
    id?: string
    date: string
    baseCurrency: string
    rates: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CurrencyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    baseCurrency?: StringFieldUpdateOperationsInput | string
    rates?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CurrencyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    baseCurrency?: StringFieldUpdateOperationsInput | string
    rates?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type TripListRelationFilter = {
    every?: TripWhereInput
    some?: TripWhereInput
    none?: TripWhereInput
  }

  export type UserSavedDestinationListRelationFilter = {
    every?: UserSavedDestinationWhereInput
    some?: UserSavedDestinationWhereInput
    none?: UserSavedDestinationWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type UserRoleListRelationFilter = {
    every?: UserRoleWhereInput
    some?: UserRoleWhereInput
    none?: UserRoleWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type TripOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserSavedDestinationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserRoleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    fullName?: SortOrder
    profilePhotoUrl?: SortOrder
    preferredLanguage?: SortOrder
    preferredCurrency?: SortOrder
    emailVerified?: SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    fullName?: SortOrder
    profilePhotoUrl?: SortOrder
    preferredLanguage?: SortOrder
    preferredCurrency?: SortOrder
    emailVerified?: SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    fullName?: SortOrder
    profilePhotoUrl?: SortOrder
    preferredLanguage?: SortOrder
    preferredCurrency?: SortOrder
    emailVerified?: SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type RoleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    permissions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    permissions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    permissions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type RoleScalarRelationFilter = {
    is?: RoleWhereInput
    isNot?: RoleWhereInput
  }

  export type UserRoleUserIdRoleIdCompoundUniqueInput = {
    userId: string
    roleId: string
  }

  export type UserRoleCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    assignedAt?: SortOrder
  }

  export type UserRoleMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    assignedAt?: SortOrder
  }

  export type UserRoleMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    assignedAt?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type ActivityListRelationFilter = {
    every?: ActivityWhereInput
    some?: ActivityWhereInput
    none?: ActivityWhereInput
  }

  export type HotelListRelationFilter = {
    every?: HotelWhereInput
    some?: HotelWhereInput
    none?: HotelWhereInput
  }

  export type RestaurantListRelationFilter = {
    every?: RestaurantWhereInput
    some?: RestaurantWhereInput
    none?: RestaurantWhereInput
  }

  export type TransportListRelationFilter = {
    every?: TransportWhereInput
    some?: TransportWhereInput
    none?: TransportWhereInput
  }

  export type TripStopListRelationFilter = {
    every?: TripStopWhereInput
    some?: TripStopWhereInput
    none?: TripStopWhereInput
  }

  export type ActivityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HotelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RestaurantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TripStopOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CityNameCountryCompoundUniqueInput = {
    name: string
    country: string
  }

  export type CityCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    country?: SortOrder
    countryCode?: SortOrder
    region?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    timezone?: SortOrder
    costIndex?: SortOrder
    popularityScore?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type CityAvgOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
    costIndex?: SortOrder
    popularityScore?: SortOrder
  }

  export type CityMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    country?: SortOrder
    countryCode?: SortOrder
    region?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    timezone?: SortOrder
    costIndex?: SortOrder
    popularityScore?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type CityMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    country?: SortOrder
    countryCode?: SortOrder
    region?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    timezone?: SortOrder
    costIndex?: SortOrder
    popularityScore?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type CitySumOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
    costIndex?: SortOrder
    popularityScore?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type CityScalarRelationFilter = {
    is?: CityWhereInput
    isNot?: CityWhereInput
  }

  export type StopActivityListRelationFilter = {
    every?: StopActivityWhereInput
    some?: StopActivityWhereInput
    none?: StopActivityWhereInput
  }

  export type StopActivityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ActivityCountOrderByAggregateInput = {
    id?: SortOrder
    cityId?: SortOrder
    name?: SortOrder
    category?: SortOrder
    description?: SortOrder
    estimatedCost?: SortOrder
    currency?: SortOrder
    durationMinutes?: SortOrder
    imageUrl?: SortOrder
    rating?: SortOrder
    popularityScore?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ActivityAvgOrderByAggregateInput = {
    estimatedCost?: SortOrder
    durationMinutes?: SortOrder
    rating?: SortOrder
    popularityScore?: SortOrder
  }

  export type ActivityMaxOrderByAggregateInput = {
    id?: SortOrder
    cityId?: SortOrder
    name?: SortOrder
    category?: SortOrder
    description?: SortOrder
    estimatedCost?: SortOrder
    currency?: SortOrder
    durationMinutes?: SortOrder
    imageUrl?: SortOrder
    rating?: SortOrder
    popularityScore?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ActivityMinOrderByAggregateInput = {
    id?: SortOrder
    cityId?: SortOrder
    name?: SortOrder
    category?: SortOrder
    description?: SortOrder
    estimatedCost?: SortOrder
    currency?: SortOrder
    durationMinutes?: SortOrder
    imageUrl?: SortOrder
    rating?: SortOrder
    popularityScore?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ActivitySumOrderByAggregateInput = {
    estimatedCost?: SortOrder
    durationMinutes?: SortOrder
    rating?: SortOrder
    popularityScore?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type HotelCountOrderByAggregateInput = {
    id?: SortOrder
    cityId?: SortOrder
    name?: SortOrder
    category?: SortOrder
    description?: SortOrder
    pricePerNight?: SortOrder
    currency?: SortOrder
    rating?: SortOrder
    amenities?: SortOrder
    address?: SortOrder
    imageUrl?: SortOrder
    contactPhone?: SortOrder
    website?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type HotelAvgOrderByAggregateInput = {
    pricePerNight?: SortOrder
    rating?: SortOrder
  }

  export type HotelMaxOrderByAggregateInput = {
    id?: SortOrder
    cityId?: SortOrder
    name?: SortOrder
    category?: SortOrder
    description?: SortOrder
    pricePerNight?: SortOrder
    currency?: SortOrder
    rating?: SortOrder
    amenities?: SortOrder
    address?: SortOrder
    imageUrl?: SortOrder
    contactPhone?: SortOrder
    website?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type HotelMinOrderByAggregateInput = {
    id?: SortOrder
    cityId?: SortOrder
    name?: SortOrder
    category?: SortOrder
    description?: SortOrder
    pricePerNight?: SortOrder
    currency?: SortOrder
    rating?: SortOrder
    amenities?: SortOrder
    address?: SortOrder
    imageUrl?: SortOrder
    contactPhone?: SortOrder
    website?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type HotelSumOrderByAggregateInput = {
    pricePerNight?: SortOrder
    rating?: SortOrder
  }

  export type RestaurantCountOrderByAggregateInput = {
    id?: SortOrder
    cityId?: SortOrder
    name?: SortOrder
    cuisineType?: SortOrder
    priceRange?: SortOrder
    avgMealCost?: SortOrder
    currency?: SortOrder
    rating?: SortOrder
    description?: SortOrder
    address?: SortOrder
    imageUrl?: SortOrder
    isVegetarian?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type RestaurantAvgOrderByAggregateInput = {
    avgMealCost?: SortOrder
    rating?: SortOrder
  }

  export type RestaurantMaxOrderByAggregateInput = {
    id?: SortOrder
    cityId?: SortOrder
    name?: SortOrder
    cuisineType?: SortOrder
    priceRange?: SortOrder
    avgMealCost?: SortOrder
    currency?: SortOrder
    rating?: SortOrder
    description?: SortOrder
    address?: SortOrder
    imageUrl?: SortOrder
    isVegetarian?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type RestaurantMinOrderByAggregateInput = {
    id?: SortOrder
    cityId?: SortOrder
    name?: SortOrder
    cuisineType?: SortOrder
    priceRange?: SortOrder
    avgMealCost?: SortOrder
    currency?: SortOrder
    rating?: SortOrder
    description?: SortOrder
    address?: SortOrder
    imageUrl?: SortOrder
    isVegetarian?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type RestaurantSumOrderByAggregateInput = {
    avgMealCost?: SortOrder
    rating?: SortOrder
  }

  export type TransportCountOrderByAggregateInput = {
    id?: SortOrder
    fromCityId?: SortOrder
    toCityId?: SortOrder
    transportType?: SortOrder
    operatorName?: SortOrder
    departureTime?: SortOrder
    arrivalTime?: SortOrder
    durationMinutes?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    classType?: SortOrder
    frequency?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type TransportAvgOrderByAggregateInput = {
    durationMinutes?: SortOrder
    price?: SortOrder
  }

  export type TransportMaxOrderByAggregateInput = {
    id?: SortOrder
    fromCityId?: SortOrder
    toCityId?: SortOrder
    transportType?: SortOrder
    operatorName?: SortOrder
    departureTime?: SortOrder
    arrivalTime?: SortOrder
    durationMinutes?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    classType?: SortOrder
    frequency?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type TransportMinOrderByAggregateInput = {
    id?: SortOrder
    fromCityId?: SortOrder
    toCityId?: SortOrder
    transportType?: SortOrder
    operatorName?: SortOrder
    departureTime?: SortOrder
    arrivalTime?: SortOrder
    durationMinutes?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    classType?: SortOrder
    frequency?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type TransportSumOrderByAggregateInput = {
    durationMinutes?: SortOrder
    price?: SortOrder
  }

  export type TripBudgetListRelationFilter = {
    every?: TripBudgetWhereInput
    some?: TripBudgetWhereInput
    none?: TripBudgetWhereInput
  }

  export type TripMediaListRelationFilter = {
    every?: TripMediaWhereInput
    some?: TripMediaWhereInput
    none?: TripMediaWhereInput
  }

  export type TripShareListRelationFilter = {
    every?: TripShareWhereInput
    some?: TripShareWhereInput
    none?: TripShareWhereInput
  }

  export type TripVersionListRelationFilter = {
    every?: TripVersionWhereInput
    some?: TripVersionWhereInput
    none?: TripVersionWhereInput
  }

  export type TripBudgetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TripMediaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TripShareOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TripVersionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TripCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    coverPhotoUrl?: SortOrder
    status?: SortOrder
    isPublic?: SortOrder
    totalEstimatedCost?: SortOrder
    currency?: SortOrder
    travelStyle?: SortOrder
    versionNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type TripAvgOrderByAggregateInput = {
    totalEstimatedCost?: SortOrder
    versionNumber?: SortOrder
  }

  export type TripMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    coverPhotoUrl?: SortOrder
    status?: SortOrder
    isPublic?: SortOrder
    totalEstimatedCost?: SortOrder
    currency?: SortOrder
    travelStyle?: SortOrder
    versionNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type TripMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    coverPhotoUrl?: SortOrder
    status?: SortOrder
    isPublic?: SortOrder
    totalEstimatedCost?: SortOrder
    currency?: SortOrder
    travelStyle?: SortOrder
    versionNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type TripSumOrderByAggregateInput = {
    totalEstimatedCost?: SortOrder
    versionNumber?: SortOrder
  }

  export type TripScalarRelationFilter = {
    is?: TripWhereInput
    isNot?: TripWhereInput
  }

  export type TripStopTripIdStopOrderCompoundUniqueInput = {
    tripId: string
    stopOrder: number
  }

  export type TripStopCountOrderByAggregateInput = {
    id?: SortOrder
    tripId?: SortOrder
    cityId?: SortOrder
    stopOrder?: SortOrder
    arrivalDate?: SortOrder
    departureDate?: SortOrder
    accommodationName?: SortOrder
    accommodationCost?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type TripStopAvgOrderByAggregateInput = {
    stopOrder?: SortOrder
    accommodationCost?: SortOrder
  }

  export type TripStopMaxOrderByAggregateInput = {
    id?: SortOrder
    tripId?: SortOrder
    cityId?: SortOrder
    stopOrder?: SortOrder
    arrivalDate?: SortOrder
    departureDate?: SortOrder
    accommodationName?: SortOrder
    accommodationCost?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type TripStopMinOrderByAggregateInput = {
    id?: SortOrder
    tripId?: SortOrder
    cityId?: SortOrder
    stopOrder?: SortOrder
    arrivalDate?: SortOrder
    departureDate?: SortOrder
    accommodationName?: SortOrder
    accommodationCost?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type TripStopSumOrderByAggregateInput = {
    stopOrder?: SortOrder
    accommodationCost?: SortOrder
  }

  export type TripStopScalarRelationFilter = {
    is?: TripStopWhereInput
    isNot?: TripStopWhereInput
  }

  export type ActivityScalarRelationFilter = {
    is?: ActivityWhereInput
    isNot?: ActivityWhereInput
  }

  export type StopActivityCountOrderByAggregateInput = {
    id?: SortOrder
    tripStopId?: SortOrder
    activityId?: SortOrder
    scheduledDate?: SortOrder
    scheduledTime?: SortOrder
    actualCost?: SortOrder
    notes?: SortOrder
    isCompleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type StopActivityAvgOrderByAggregateInput = {
    actualCost?: SortOrder
  }

  export type StopActivityMaxOrderByAggregateInput = {
    id?: SortOrder
    tripStopId?: SortOrder
    activityId?: SortOrder
    scheduledDate?: SortOrder
    scheduledTime?: SortOrder
    actualCost?: SortOrder
    notes?: SortOrder
    isCompleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type StopActivityMinOrderByAggregateInput = {
    id?: SortOrder
    tripStopId?: SortOrder
    activityId?: SortOrder
    scheduledDate?: SortOrder
    scheduledTime?: SortOrder
    actualCost?: SortOrder
    notes?: SortOrder
    isCompleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type StopActivitySumOrderByAggregateInput = {
    actualCost?: SortOrder
  }

  export type TripBudgetTripIdCategoryCompoundUniqueInput = {
    tripId: string
    category: string
  }

  export type TripBudgetCountOrderByAggregateInput = {
    id?: SortOrder
    tripId?: SortOrder
    category?: SortOrder
    estimatedAmount?: SortOrder
    actualAmount?: SortOrder
    currency?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type TripBudgetAvgOrderByAggregateInput = {
    estimatedAmount?: SortOrder
    actualAmount?: SortOrder
  }

  export type TripBudgetMaxOrderByAggregateInput = {
    id?: SortOrder
    tripId?: SortOrder
    category?: SortOrder
    estimatedAmount?: SortOrder
    actualAmount?: SortOrder
    currency?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type TripBudgetMinOrderByAggregateInput = {
    id?: SortOrder
    tripId?: SortOrder
    category?: SortOrder
    estimatedAmount?: SortOrder
    actualAmount?: SortOrder
    currency?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type TripBudgetSumOrderByAggregateInput = {
    estimatedAmount?: SortOrder
    actualAmount?: SortOrder
  }

  export type TripMediaCountOrderByAggregateInput = {
    id?: SortOrder
    tripId?: SortOrder
    mediaType?: SortOrder
    mediaUrl?: SortOrder
    thumbnailUrl?: SortOrder
    caption?: SortOrder
    displayOrder?: SortOrder
    uploadedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type TripMediaAvgOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type TripMediaMaxOrderByAggregateInput = {
    id?: SortOrder
    tripId?: SortOrder
    mediaType?: SortOrder
    mediaUrl?: SortOrder
    thumbnailUrl?: SortOrder
    caption?: SortOrder
    displayOrder?: SortOrder
    uploadedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type TripMediaMinOrderByAggregateInput = {
    id?: SortOrder
    tripId?: SortOrder
    mediaType?: SortOrder
    mediaUrl?: SortOrder
    thumbnailUrl?: SortOrder
    caption?: SortOrder
    displayOrder?: SortOrder
    uploadedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type TripMediaSumOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type TripShareCountOrderByAggregateInput = {
    id?: SortOrder
    tripId?: SortOrder
    shareToken?: SortOrder
    shareType?: SortOrder
    sharedWithEmail?: SortOrder
    viewCount?: SortOrder
    lastViewedAt?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type TripShareAvgOrderByAggregateInput = {
    viewCount?: SortOrder
  }

  export type TripShareMaxOrderByAggregateInput = {
    id?: SortOrder
    tripId?: SortOrder
    shareToken?: SortOrder
    shareType?: SortOrder
    sharedWithEmail?: SortOrder
    viewCount?: SortOrder
    lastViewedAt?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type TripShareMinOrderByAggregateInput = {
    id?: SortOrder
    tripId?: SortOrder
    shareToken?: SortOrder
    shareType?: SortOrder
    sharedWithEmail?: SortOrder
    viewCount?: SortOrder
    lastViewedAt?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type TripShareSumOrderByAggregateInput = {
    viewCount?: SortOrder
  }

  export type TripVersionTripIdVersionNumberCompoundUniqueInput = {
    tripId: string
    versionNumber: number
  }

  export type TripVersionCountOrderByAggregateInput = {
    id?: SortOrder
    tripId?: SortOrder
    versionNumber?: SortOrder
    snapshotData?: SortOrder
    changeSummary?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type TripVersionAvgOrderByAggregateInput = {
    versionNumber?: SortOrder
  }

  export type TripVersionMaxOrderByAggregateInput = {
    id?: SortOrder
    tripId?: SortOrder
    versionNumber?: SortOrder
    snapshotData?: SortOrder
    changeSummary?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type TripVersionMinOrderByAggregateInput = {
    id?: SortOrder
    tripId?: SortOrder
    versionNumber?: SortOrder
    snapshotData?: SortOrder
    changeSummary?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type TripVersionSumOrderByAggregateInput = {
    versionNumber?: SortOrder
  }

  export type UserSavedDestinationUserIdCityIdCompoundUniqueInput = {
    userId: string
    cityId: string
  }

  export type UserSavedDestinationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    cityId?: SortOrder
    notes?: SortOrder
    savedAt?: SortOrder
  }

  export type UserSavedDestinationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    cityId?: SortOrder
    notes?: SortOrder
    savedAt?: SortOrder
  }

  export type UserSavedDestinationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    cityId?: SortOrder
    notes?: SortOrder
    savedAt?: SortOrder
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    changes?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    changes?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    changes?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type WeatherCountOrderByAggregateInput = {
    id?: SortOrder
    cityId?: SortOrder
    city?: SortOrder
    date?: SortOrder
    current?: SortOrder
    forecast?: SortOrder
    hourlyForecast?: SortOrder
    recommendation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WeatherMaxOrderByAggregateInput = {
    id?: SortOrder
    cityId?: SortOrder
    city?: SortOrder
    date?: SortOrder
    current?: SortOrder
    forecast?: SortOrder
    hourlyForecast?: SortOrder
    recommendation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WeatherMinOrderByAggregateInput = {
    id?: SortOrder
    cityId?: SortOrder
    city?: SortOrder
    date?: SortOrder
    current?: SortOrder
    forecast?: SortOrder
    hourlyForecast?: SortOrder
    recommendation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GuideCountOrderByAggregateInput = {
    id?: SortOrder
    cityId?: SortOrder
    name?: SortOrder
    specialization?: SortOrder
    city?: SortOrder
    languages?: SortOrder
    certification?: SortOrder
    yearsOfExperience?: SortOrder
    rating?: SortOrder
    reviews?: SortOrder
    pricePerDay?: SortOrder
    availability?: SortOrder
    groupSize?: SortOrder
    skills?: SortOrder
    tours?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GuideAvgOrderByAggregateInput = {
    yearsOfExperience?: SortOrder
    rating?: SortOrder
    reviews?: SortOrder
  }

  export type GuideMaxOrderByAggregateInput = {
    id?: SortOrder
    cityId?: SortOrder
    name?: SortOrder
    specialization?: SortOrder
    city?: SortOrder
    languages?: SortOrder
    certification?: SortOrder
    yearsOfExperience?: SortOrder
    rating?: SortOrder
    reviews?: SortOrder
    pricePerDay?: SortOrder
    availability?: SortOrder
    groupSize?: SortOrder
    skills?: SortOrder
    tours?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GuideMinOrderByAggregateInput = {
    id?: SortOrder
    cityId?: SortOrder
    name?: SortOrder
    specialization?: SortOrder
    city?: SortOrder
    languages?: SortOrder
    certification?: SortOrder
    yearsOfExperience?: SortOrder
    rating?: SortOrder
    reviews?: SortOrder
    pricePerDay?: SortOrder
    availability?: SortOrder
    groupSize?: SortOrder
    skills?: SortOrder
    tours?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GuideSumOrderByAggregateInput = {
    yearsOfExperience?: SortOrder
    rating?: SortOrder
    reviews?: SortOrder
  }

  export type EventCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    city?: SortOrder
    country?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    description?: SortOrder
    category?: SortOrder
    expectedCrowd?: SortOrder
    entryFee?: SortOrder
    highlights?: SortOrder
    bestLocations?: SortOrder
    tips?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventAvgOrderByAggregateInput = {
    entryFee?: SortOrder
  }

  export type EventMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    city?: SortOrder
    country?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    description?: SortOrder
    category?: SortOrder
    expectedCrowd?: SortOrder
    entryFee?: SortOrder
    highlights?: SortOrder
    bestLocations?: SortOrder
    tips?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    city?: SortOrder
    country?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    description?: SortOrder
    category?: SortOrder
    expectedCrowd?: SortOrder
    entryFee?: SortOrder
    highlights?: SortOrder
    bestLocations?: SortOrder
    tips?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventSumOrderByAggregateInput = {
    entryFee?: SortOrder
  }

  export type CostOfLivingCountOrderByAggregateInput = {
    id?: SortOrder
    city?: SortOrder
    country?: SortOrder
    category?: SortOrder
    dailyCost?: SortOrder
    weeklyTotalEstimate?: SortOrder
    monthlyTotalEstimate?: SortOrder
    costBreakdown?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CostOfLivingAvgOrderByAggregateInput = {
    weeklyTotalEstimate?: SortOrder
    monthlyTotalEstimate?: SortOrder
  }

  export type CostOfLivingMaxOrderByAggregateInput = {
    id?: SortOrder
    city?: SortOrder
    country?: SortOrder
    category?: SortOrder
    dailyCost?: SortOrder
    weeklyTotalEstimate?: SortOrder
    monthlyTotalEstimate?: SortOrder
    costBreakdown?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CostOfLivingMinOrderByAggregateInput = {
    id?: SortOrder
    city?: SortOrder
    country?: SortOrder
    category?: SortOrder
    dailyCost?: SortOrder
    weeklyTotalEstimate?: SortOrder
    monthlyTotalEstimate?: SortOrder
    costBreakdown?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CostOfLivingSumOrderByAggregateInput = {
    weeklyTotalEstimate?: SortOrder
    monthlyTotalEstimate?: SortOrder
  }

  export type CrowdCountOrderByAggregateInput = {
    id?: SortOrder
    location?: SortOrder
    date?: SortOrder
    hourlyData?: SortOrder
    seasonalFactor?: SortOrder
    bestTimeToVisit?: SortOrder
    avgWaitTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CrowdAvgOrderByAggregateInput = {
    avgWaitTime?: SortOrder
  }

  export type CrowdMaxOrderByAggregateInput = {
    id?: SortOrder
    location?: SortOrder
    date?: SortOrder
    hourlyData?: SortOrder
    seasonalFactor?: SortOrder
    bestTimeToVisit?: SortOrder
    avgWaitTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CrowdMinOrderByAggregateInput = {
    id?: SortOrder
    location?: SortOrder
    date?: SortOrder
    hourlyData?: SortOrder
    seasonalFactor?: SortOrder
    bestTimeToVisit?: SortOrder
    avgWaitTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CrowdSumOrderByAggregateInput = {
    avgWaitTime?: SortOrder
  }

  export type CurrencyCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    baseCurrency?: SortOrder
    rates?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CurrencyMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    baseCurrency?: SortOrder
    rates?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CurrencyMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    baseCurrency?: SortOrder
    rates?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TripCreateNestedManyWithoutUserInput = {
    create?: XOR<TripCreateWithoutUserInput, TripUncheckedCreateWithoutUserInput> | TripCreateWithoutUserInput[] | TripUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TripCreateOrConnectWithoutUserInput | TripCreateOrConnectWithoutUserInput[]
    createMany?: TripCreateManyUserInputEnvelope
    connect?: TripWhereUniqueInput | TripWhereUniqueInput[]
  }

  export type UserSavedDestinationCreateNestedManyWithoutUserInput = {
    create?: XOR<UserSavedDestinationCreateWithoutUserInput, UserSavedDestinationUncheckedCreateWithoutUserInput> | UserSavedDestinationCreateWithoutUserInput[] | UserSavedDestinationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSavedDestinationCreateOrConnectWithoutUserInput | UserSavedDestinationCreateOrConnectWithoutUserInput[]
    createMany?: UserSavedDestinationCreateManyUserInputEnvelope
    connect?: UserSavedDestinationWhereUniqueInput | UserSavedDestinationWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type UserRoleCreateNestedManyWithoutUserInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type TripUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TripCreateWithoutUserInput, TripUncheckedCreateWithoutUserInput> | TripCreateWithoutUserInput[] | TripUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TripCreateOrConnectWithoutUserInput | TripCreateOrConnectWithoutUserInput[]
    createMany?: TripCreateManyUserInputEnvelope
    connect?: TripWhereUniqueInput | TripWhereUniqueInput[]
  }

  export type UserSavedDestinationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserSavedDestinationCreateWithoutUserInput, UserSavedDestinationUncheckedCreateWithoutUserInput> | UserSavedDestinationCreateWithoutUserInput[] | UserSavedDestinationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSavedDestinationCreateOrConnectWithoutUserInput | UserSavedDestinationCreateOrConnectWithoutUserInput[]
    createMany?: UserSavedDestinationCreateManyUserInputEnvelope
    connect?: UserSavedDestinationWhereUniqueInput | UserSavedDestinationWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type UserRoleUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type TripUpdateManyWithoutUserNestedInput = {
    create?: XOR<TripCreateWithoutUserInput, TripUncheckedCreateWithoutUserInput> | TripCreateWithoutUserInput[] | TripUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TripCreateOrConnectWithoutUserInput | TripCreateOrConnectWithoutUserInput[]
    upsert?: TripUpsertWithWhereUniqueWithoutUserInput | TripUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TripCreateManyUserInputEnvelope
    set?: TripWhereUniqueInput | TripWhereUniqueInput[]
    disconnect?: TripWhereUniqueInput | TripWhereUniqueInput[]
    delete?: TripWhereUniqueInput | TripWhereUniqueInput[]
    connect?: TripWhereUniqueInput | TripWhereUniqueInput[]
    update?: TripUpdateWithWhereUniqueWithoutUserInput | TripUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TripUpdateManyWithWhereWithoutUserInput | TripUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TripScalarWhereInput | TripScalarWhereInput[]
  }

  export type UserSavedDestinationUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserSavedDestinationCreateWithoutUserInput, UserSavedDestinationUncheckedCreateWithoutUserInput> | UserSavedDestinationCreateWithoutUserInput[] | UserSavedDestinationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSavedDestinationCreateOrConnectWithoutUserInput | UserSavedDestinationCreateOrConnectWithoutUserInput[]
    upsert?: UserSavedDestinationUpsertWithWhereUniqueWithoutUserInput | UserSavedDestinationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserSavedDestinationCreateManyUserInputEnvelope
    set?: UserSavedDestinationWhereUniqueInput | UserSavedDestinationWhereUniqueInput[]
    disconnect?: UserSavedDestinationWhereUniqueInput | UserSavedDestinationWhereUniqueInput[]
    delete?: UserSavedDestinationWhereUniqueInput | UserSavedDestinationWhereUniqueInput[]
    connect?: UserSavedDestinationWhereUniqueInput | UserSavedDestinationWhereUniqueInput[]
    update?: UserSavedDestinationUpdateWithWhereUniqueWithoutUserInput | UserSavedDestinationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserSavedDestinationUpdateManyWithWhereWithoutUserInput | UserSavedDestinationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserSavedDestinationScalarWhereInput | UserSavedDestinationScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type UserRoleUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutUserInput | UserRoleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutUserInput | UserRoleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutUserInput | UserRoleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type TripUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TripCreateWithoutUserInput, TripUncheckedCreateWithoutUserInput> | TripCreateWithoutUserInput[] | TripUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TripCreateOrConnectWithoutUserInput | TripCreateOrConnectWithoutUserInput[]
    upsert?: TripUpsertWithWhereUniqueWithoutUserInput | TripUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TripCreateManyUserInputEnvelope
    set?: TripWhereUniqueInput | TripWhereUniqueInput[]
    disconnect?: TripWhereUniqueInput | TripWhereUniqueInput[]
    delete?: TripWhereUniqueInput | TripWhereUniqueInput[]
    connect?: TripWhereUniqueInput | TripWhereUniqueInput[]
    update?: TripUpdateWithWhereUniqueWithoutUserInput | TripUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TripUpdateManyWithWhereWithoutUserInput | TripUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TripScalarWhereInput | TripScalarWhereInput[]
  }

  export type UserSavedDestinationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserSavedDestinationCreateWithoutUserInput, UserSavedDestinationUncheckedCreateWithoutUserInput> | UserSavedDestinationCreateWithoutUserInput[] | UserSavedDestinationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSavedDestinationCreateOrConnectWithoutUserInput | UserSavedDestinationCreateOrConnectWithoutUserInput[]
    upsert?: UserSavedDestinationUpsertWithWhereUniqueWithoutUserInput | UserSavedDestinationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserSavedDestinationCreateManyUserInputEnvelope
    set?: UserSavedDestinationWhereUniqueInput | UserSavedDestinationWhereUniqueInput[]
    disconnect?: UserSavedDestinationWhereUniqueInput | UserSavedDestinationWhereUniqueInput[]
    delete?: UserSavedDestinationWhereUniqueInput | UserSavedDestinationWhereUniqueInput[]
    connect?: UserSavedDestinationWhereUniqueInput | UserSavedDestinationWhereUniqueInput[]
    update?: UserSavedDestinationUpdateWithWhereUniqueWithoutUserInput | UserSavedDestinationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserSavedDestinationUpdateManyWithWhereWithoutUserInput | UserSavedDestinationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserSavedDestinationScalarWhereInput | UserSavedDestinationScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type UserRoleUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutUserInput | UserRoleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutUserInput | UserRoleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutUserInput | UserRoleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type UserRoleCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type UserRoleUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type UserRoleUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutRoleInput | UserRoleUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutRoleInput | UserRoleUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutRoleInput | UserRoleUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type UserRoleUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutRoleInput | UserRoleUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutRoleInput | UserRoleUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutRoleInput | UserRoleUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutUserRolesInput = {
    create?: XOR<UserCreateWithoutUserRolesInput, UserUncheckedCreateWithoutUserRolesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserRolesInput
    connect?: UserWhereUniqueInput
  }

  export type RoleCreateNestedOneWithoutUserRolesInput = {
    create?: XOR<RoleCreateWithoutUserRolesInput, RoleUncheckedCreateWithoutUserRolesInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUserRolesInput
    connect?: RoleWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUserRolesNestedInput = {
    create?: XOR<UserCreateWithoutUserRolesInput, UserUncheckedCreateWithoutUserRolesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserRolesInput
    upsert?: UserUpsertWithoutUserRolesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserRolesInput, UserUpdateWithoutUserRolesInput>, UserUncheckedUpdateWithoutUserRolesInput>
  }

  export type RoleUpdateOneRequiredWithoutUserRolesNestedInput = {
    create?: XOR<RoleCreateWithoutUserRolesInput, RoleUncheckedCreateWithoutUserRolesInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUserRolesInput
    upsert?: RoleUpsertWithoutUserRolesInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutUserRolesInput, RoleUpdateWithoutUserRolesInput>, RoleUncheckedUpdateWithoutUserRolesInput>
  }

  export type ActivityCreateNestedManyWithoutCityInput = {
    create?: XOR<ActivityCreateWithoutCityInput, ActivityUncheckedCreateWithoutCityInput> | ActivityCreateWithoutCityInput[] | ActivityUncheckedCreateWithoutCityInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutCityInput | ActivityCreateOrConnectWithoutCityInput[]
    createMany?: ActivityCreateManyCityInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type HotelCreateNestedManyWithoutCityInput = {
    create?: XOR<HotelCreateWithoutCityInput, HotelUncheckedCreateWithoutCityInput> | HotelCreateWithoutCityInput[] | HotelUncheckedCreateWithoutCityInput[]
    connectOrCreate?: HotelCreateOrConnectWithoutCityInput | HotelCreateOrConnectWithoutCityInput[]
    createMany?: HotelCreateManyCityInputEnvelope
    connect?: HotelWhereUniqueInput | HotelWhereUniqueInput[]
  }

  export type RestaurantCreateNestedManyWithoutCityInput = {
    create?: XOR<RestaurantCreateWithoutCityInput, RestaurantUncheckedCreateWithoutCityInput> | RestaurantCreateWithoutCityInput[] | RestaurantUncheckedCreateWithoutCityInput[]
    connectOrCreate?: RestaurantCreateOrConnectWithoutCityInput | RestaurantCreateOrConnectWithoutCityInput[]
    createMany?: RestaurantCreateManyCityInputEnvelope
    connect?: RestaurantWhereUniqueInput | RestaurantWhereUniqueInput[]
  }

  export type TransportCreateNestedManyWithoutFromCityInput = {
    create?: XOR<TransportCreateWithoutFromCityInput, TransportUncheckedCreateWithoutFromCityInput> | TransportCreateWithoutFromCityInput[] | TransportUncheckedCreateWithoutFromCityInput[]
    connectOrCreate?: TransportCreateOrConnectWithoutFromCityInput | TransportCreateOrConnectWithoutFromCityInput[]
    createMany?: TransportCreateManyFromCityInputEnvelope
    connect?: TransportWhereUniqueInput | TransportWhereUniqueInput[]
  }

  export type TransportCreateNestedManyWithoutToCityInput = {
    create?: XOR<TransportCreateWithoutToCityInput, TransportUncheckedCreateWithoutToCityInput> | TransportCreateWithoutToCityInput[] | TransportUncheckedCreateWithoutToCityInput[]
    connectOrCreate?: TransportCreateOrConnectWithoutToCityInput | TransportCreateOrConnectWithoutToCityInput[]
    createMany?: TransportCreateManyToCityInputEnvelope
    connect?: TransportWhereUniqueInput | TransportWhereUniqueInput[]
  }

  export type TripStopCreateNestedManyWithoutCityInput = {
    create?: XOR<TripStopCreateWithoutCityInput, TripStopUncheckedCreateWithoutCityInput> | TripStopCreateWithoutCityInput[] | TripStopUncheckedCreateWithoutCityInput[]
    connectOrCreate?: TripStopCreateOrConnectWithoutCityInput | TripStopCreateOrConnectWithoutCityInput[]
    createMany?: TripStopCreateManyCityInputEnvelope
    connect?: TripStopWhereUniqueInput | TripStopWhereUniqueInput[]
  }

  export type UserSavedDestinationCreateNestedManyWithoutCityInput = {
    create?: XOR<UserSavedDestinationCreateWithoutCityInput, UserSavedDestinationUncheckedCreateWithoutCityInput> | UserSavedDestinationCreateWithoutCityInput[] | UserSavedDestinationUncheckedCreateWithoutCityInput[]
    connectOrCreate?: UserSavedDestinationCreateOrConnectWithoutCityInput | UserSavedDestinationCreateOrConnectWithoutCityInput[]
    createMany?: UserSavedDestinationCreateManyCityInputEnvelope
    connect?: UserSavedDestinationWhereUniqueInput | UserSavedDestinationWhereUniqueInput[]
  }

  export type ActivityUncheckedCreateNestedManyWithoutCityInput = {
    create?: XOR<ActivityCreateWithoutCityInput, ActivityUncheckedCreateWithoutCityInput> | ActivityCreateWithoutCityInput[] | ActivityUncheckedCreateWithoutCityInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutCityInput | ActivityCreateOrConnectWithoutCityInput[]
    createMany?: ActivityCreateManyCityInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type HotelUncheckedCreateNestedManyWithoutCityInput = {
    create?: XOR<HotelCreateWithoutCityInput, HotelUncheckedCreateWithoutCityInput> | HotelCreateWithoutCityInput[] | HotelUncheckedCreateWithoutCityInput[]
    connectOrCreate?: HotelCreateOrConnectWithoutCityInput | HotelCreateOrConnectWithoutCityInput[]
    createMany?: HotelCreateManyCityInputEnvelope
    connect?: HotelWhereUniqueInput | HotelWhereUniqueInput[]
  }

  export type RestaurantUncheckedCreateNestedManyWithoutCityInput = {
    create?: XOR<RestaurantCreateWithoutCityInput, RestaurantUncheckedCreateWithoutCityInput> | RestaurantCreateWithoutCityInput[] | RestaurantUncheckedCreateWithoutCityInput[]
    connectOrCreate?: RestaurantCreateOrConnectWithoutCityInput | RestaurantCreateOrConnectWithoutCityInput[]
    createMany?: RestaurantCreateManyCityInputEnvelope
    connect?: RestaurantWhereUniqueInput | RestaurantWhereUniqueInput[]
  }

  export type TransportUncheckedCreateNestedManyWithoutFromCityInput = {
    create?: XOR<TransportCreateWithoutFromCityInput, TransportUncheckedCreateWithoutFromCityInput> | TransportCreateWithoutFromCityInput[] | TransportUncheckedCreateWithoutFromCityInput[]
    connectOrCreate?: TransportCreateOrConnectWithoutFromCityInput | TransportCreateOrConnectWithoutFromCityInput[]
    createMany?: TransportCreateManyFromCityInputEnvelope
    connect?: TransportWhereUniqueInput | TransportWhereUniqueInput[]
  }

  export type TransportUncheckedCreateNestedManyWithoutToCityInput = {
    create?: XOR<TransportCreateWithoutToCityInput, TransportUncheckedCreateWithoutToCityInput> | TransportCreateWithoutToCityInput[] | TransportUncheckedCreateWithoutToCityInput[]
    connectOrCreate?: TransportCreateOrConnectWithoutToCityInput | TransportCreateOrConnectWithoutToCityInput[]
    createMany?: TransportCreateManyToCityInputEnvelope
    connect?: TransportWhereUniqueInput | TransportWhereUniqueInput[]
  }

  export type TripStopUncheckedCreateNestedManyWithoutCityInput = {
    create?: XOR<TripStopCreateWithoutCityInput, TripStopUncheckedCreateWithoutCityInput> | TripStopCreateWithoutCityInput[] | TripStopUncheckedCreateWithoutCityInput[]
    connectOrCreate?: TripStopCreateOrConnectWithoutCityInput | TripStopCreateOrConnectWithoutCityInput[]
    createMany?: TripStopCreateManyCityInputEnvelope
    connect?: TripStopWhereUniqueInput | TripStopWhereUniqueInput[]
  }

  export type UserSavedDestinationUncheckedCreateNestedManyWithoutCityInput = {
    create?: XOR<UserSavedDestinationCreateWithoutCityInput, UserSavedDestinationUncheckedCreateWithoutCityInput> | UserSavedDestinationCreateWithoutCityInput[] | UserSavedDestinationUncheckedCreateWithoutCityInput[]
    connectOrCreate?: UserSavedDestinationCreateOrConnectWithoutCityInput | UserSavedDestinationCreateOrConnectWithoutCityInput[]
    createMany?: UserSavedDestinationCreateManyCityInputEnvelope
    connect?: UserSavedDestinationWhereUniqueInput | UserSavedDestinationWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ActivityUpdateManyWithoutCityNestedInput = {
    create?: XOR<ActivityCreateWithoutCityInput, ActivityUncheckedCreateWithoutCityInput> | ActivityCreateWithoutCityInput[] | ActivityUncheckedCreateWithoutCityInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutCityInput | ActivityCreateOrConnectWithoutCityInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutCityInput | ActivityUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: ActivityCreateManyCityInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutCityInput | ActivityUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutCityInput | ActivityUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type HotelUpdateManyWithoutCityNestedInput = {
    create?: XOR<HotelCreateWithoutCityInput, HotelUncheckedCreateWithoutCityInput> | HotelCreateWithoutCityInput[] | HotelUncheckedCreateWithoutCityInput[]
    connectOrCreate?: HotelCreateOrConnectWithoutCityInput | HotelCreateOrConnectWithoutCityInput[]
    upsert?: HotelUpsertWithWhereUniqueWithoutCityInput | HotelUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: HotelCreateManyCityInputEnvelope
    set?: HotelWhereUniqueInput | HotelWhereUniqueInput[]
    disconnect?: HotelWhereUniqueInput | HotelWhereUniqueInput[]
    delete?: HotelWhereUniqueInput | HotelWhereUniqueInput[]
    connect?: HotelWhereUniqueInput | HotelWhereUniqueInput[]
    update?: HotelUpdateWithWhereUniqueWithoutCityInput | HotelUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: HotelUpdateManyWithWhereWithoutCityInput | HotelUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: HotelScalarWhereInput | HotelScalarWhereInput[]
  }

  export type RestaurantUpdateManyWithoutCityNestedInput = {
    create?: XOR<RestaurantCreateWithoutCityInput, RestaurantUncheckedCreateWithoutCityInput> | RestaurantCreateWithoutCityInput[] | RestaurantUncheckedCreateWithoutCityInput[]
    connectOrCreate?: RestaurantCreateOrConnectWithoutCityInput | RestaurantCreateOrConnectWithoutCityInput[]
    upsert?: RestaurantUpsertWithWhereUniqueWithoutCityInput | RestaurantUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: RestaurantCreateManyCityInputEnvelope
    set?: RestaurantWhereUniqueInput | RestaurantWhereUniqueInput[]
    disconnect?: RestaurantWhereUniqueInput | RestaurantWhereUniqueInput[]
    delete?: RestaurantWhereUniqueInput | RestaurantWhereUniqueInput[]
    connect?: RestaurantWhereUniqueInput | RestaurantWhereUniqueInput[]
    update?: RestaurantUpdateWithWhereUniqueWithoutCityInput | RestaurantUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: RestaurantUpdateManyWithWhereWithoutCityInput | RestaurantUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: RestaurantScalarWhereInput | RestaurantScalarWhereInput[]
  }

  export type TransportUpdateManyWithoutFromCityNestedInput = {
    create?: XOR<TransportCreateWithoutFromCityInput, TransportUncheckedCreateWithoutFromCityInput> | TransportCreateWithoutFromCityInput[] | TransportUncheckedCreateWithoutFromCityInput[]
    connectOrCreate?: TransportCreateOrConnectWithoutFromCityInput | TransportCreateOrConnectWithoutFromCityInput[]
    upsert?: TransportUpsertWithWhereUniqueWithoutFromCityInput | TransportUpsertWithWhereUniqueWithoutFromCityInput[]
    createMany?: TransportCreateManyFromCityInputEnvelope
    set?: TransportWhereUniqueInput | TransportWhereUniqueInput[]
    disconnect?: TransportWhereUniqueInput | TransportWhereUniqueInput[]
    delete?: TransportWhereUniqueInput | TransportWhereUniqueInput[]
    connect?: TransportWhereUniqueInput | TransportWhereUniqueInput[]
    update?: TransportUpdateWithWhereUniqueWithoutFromCityInput | TransportUpdateWithWhereUniqueWithoutFromCityInput[]
    updateMany?: TransportUpdateManyWithWhereWithoutFromCityInput | TransportUpdateManyWithWhereWithoutFromCityInput[]
    deleteMany?: TransportScalarWhereInput | TransportScalarWhereInput[]
  }

  export type TransportUpdateManyWithoutToCityNestedInput = {
    create?: XOR<TransportCreateWithoutToCityInput, TransportUncheckedCreateWithoutToCityInput> | TransportCreateWithoutToCityInput[] | TransportUncheckedCreateWithoutToCityInput[]
    connectOrCreate?: TransportCreateOrConnectWithoutToCityInput | TransportCreateOrConnectWithoutToCityInput[]
    upsert?: TransportUpsertWithWhereUniqueWithoutToCityInput | TransportUpsertWithWhereUniqueWithoutToCityInput[]
    createMany?: TransportCreateManyToCityInputEnvelope
    set?: TransportWhereUniqueInput | TransportWhereUniqueInput[]
    disconnect?: TransportWhereUniqueInput | TransportWhereUniqueInput[]
    delete?: TransportWhereUniqueInput | TransportWhereUniqueInput[]
    connect?: TransportWhereUniqueInput | TransportWhereUniqueInput[]
    update?: TransportUpdateWithWhereUniqueWithoutToCityInput | TransportUpdateWithWhereUniqueWithoutToCityInput[]
    updateMany?: TransportUpdateManyWithWhereWithoutToCityInput | TransportUpdateManyWithWhereWithoutToCityInput[]
    deleteMany?: TransportScalarWhereInput | TransportScalarWhereInput[]
  }

  export type TripStopUpdateManyWithoutCityNestedInput = {
    create?: XOR<TripStopCreateWithoutCityInput, TripStopUncheckedCreateWithoutCityInput> | TripStopCreateWithoutCityInput[] | TripStopUncheckedCreateWithoutCityInput[]
    connectOrCreate?: TripStopCreateOrConnectWithoutCityInput | TripStopCreateOrConnectWithoutCityInput[]
    upsert?: TripStopUpsertWithWhereUniqueWithoutCityInput | TripStopUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: TripStopCreateManyCityInputEnvelope
    set?: TripStopWhereUniqueInput | TripStopWhereUniqueInput[]
    disconnect?: TripStopWhereUniqueInput | TripStopWhereUniqueInput[]
    delete?: TripStopWhereUniqueInput | TripStopWhereUniqueInput[]
    connect?: TripStopWhereUniqueInput | TripStopWhereUniqueInput[]
    update?: TripStopUpdateWithWhereUniqueWithoutCityInput | TripStopUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: TripStopUpdateManyWithWhereWithoutCityInput | TripStopUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: TripStopScalarWhereInput | TripStopScalarWhereInput[]
  }

  export type UserSavedDestinationUpdateManyWithoutCityNestedInput = {
    create?: XOR<UserSavedDestinationCreateWithoutCityInput, UserSavedDestinationUncheckedCreateWithoutCityInput> | UserSavedDestinationCreateWithoutCityInput[] | UserSavedDestinationUncheckedCreateWithoutCityInput[]
    connectOrCreate?: UserSavedDestinationCreateOrConnectWithoutCityInput | UserSavedDestinationCreateOrConnectWithoutCityInput[]
    upsert?: UserSavedDestinationUpsertWithWhereUniqueWithoutCityInput | UserSavedDestinationUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: UserSavedDestinationCreateManyCityInputEnvelope
    set?: UserSavedDestinationWhereUniqueInput | UserSavedDestinationWhereUniqueInput[]
    disconnect?: UserSavedDestinationWhereUniqueInput | UserSavedDestinationWhereUniqueInput[]
    delete?: UserSavedDestinationWhereUniqueInput | UserSavedDestinationWhereUniqueInput[]
    connect?: UserSavedDestinationWhereUniqueInput | UserSavedDestinationWhereUniqueInput[]
    update?: UserSavedDestinationUpdateWithWhereUniqueWithoutCityInput | UserSavedDestinationUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: UserSavedDestinationUpdateManyWithWhereWithoutCityInput | UserSavedDestinationUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: UserSavedDestinationScalarWhereInput | UserSavedDestinationScalarWhereInput[]
  }

  export type ActivityUncheckedUpdateManyWithoutCityNestedInput = {
    create?: XOR<ActivityCreateWithoutCityInput, ActivityUncheckedCreateWithoutCityInput> | ActivityCreateWithoutCityInput[] | ActivityUncheckedCreateWithoutCityInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutCityInput | ActivityCreateOrConnectWithoutCityInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutCityInput | ActivityUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: ActivityCreateManyCityInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutCityInput | ActivityUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutCityInput | ActivityUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type HotelUncheckedUpdateManyWithoutCityNestedInput = {
    create?: XOR<HotelCreateWithoutCityInput, HotelUncheckedCreateWithoutCityInput> | HotelCreateWithoutCityInput[] | HotelUncheckedCreateWithoutCityInput[]
    connectOrCreate?: HotelCreateOrConnectWithoutCityInput | HotelCreateOrConnectWithoutCityInput[]
    upsert?: HotelUpsertWithWhereUniqueWithoutCityInput | HotelUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: HotelCreateManyCityInputEnvelope
    set?: HotelWhereUniqueInput | HotelWhereUniqueInput[]
    disconnect?: HotelWhereUniqueInput | HotelWhereUniqueInput[]
    delete?: HotelWhereUniqueInput | HotelWhereUniqueInput[]
    connect?: HotelWhereUniqueInput | HotelWhereUniqueInput[]
    update?: HotelUpdateWithWhereUniqueWithoutCityInput | HotelUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: HotelUpdateManyWithWhereWithoutCityInput | HotelUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: HotelScalarWhereInput | HotelScalarWhereInput[]
  }

  export type RestaurantUncheckedUpdateManyWithoutCityNestedInput = {
    create?: XOR<RestaurantCreateWithoutCityInput, RestaurantUncheckedCreateWithoutCityInput> | RestaurantCreateWithoutCityInput[] | RestaurantUncheckedCreateWithoutCityInput[]
    connectOrCreate?: RestaurantCreateOrConnectWithoutCityInput | RestaurantCreateOrConnectWithoutCityInput[]
    upsert?: RestaurantUpsertWithWhereUniqueWithoutCityInput | RestaurantUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: RestaurantCreateManyCityInputEnvelope
    set?: RestaurantWhereUniqueInput | RestaurantWhereUniqueInput[]
    disconnect?: RestaurantWhereUniqueInput | RestaurantWhereUniqueInput[]
    delete?: RestaurantWhereUniqueInput | RestaurantWhereUniqueInput[]
    connect?: RestaurantWhereUniqueInput | RestaurantWhereUniqueInput[]
    update?: RestaurantUpdateWithWhereUniqueWithoutCityInput | RestaurantUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: RestaurantUpdateManyWithWhereWithoutCityInput | RestaurantUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: RestaurantScalarWhereInput | RestaurantScalarWhereInput[]
  }

  export type TransportUncheckedUpdateManyWithoutFromCityNestedInput = {
    create?: XOR<TransportCreateWithoutFromCityInput, TransportUncheckedCreateWithoutFromCityInput> | TransportCreateWithoutFromCityInput[] | TransportUncheckedCreateWithoutFromCityInput[]
    connectOrCreate?: TransportCreateOrConnectWithoutFromCityInput | TransportCreateOrConnectWithoutFromCityInput[]
    upsert?: TransportUpsertWithWhereUniqueWithoutFromCityInput | TransportUpsertWithWhereUniqueWithoutFromCityInput[]
    createMany?: TransportCreateManyFromCityInputEnvelope
    set?: TransportWhereUniqueInput | TransportWhereUniqueInput[]
    disconnect?: TransportWhereUniqueInput | TransportWhereUniqueInput[]
    delete?: TransportWhereUniqueInput | TransportWhereUniqueInput[]
    connect?: TransportWhereUniqueInput | TransportWhereUniqueInput[]
    update?: TransportUpdateWithWhereUniqueWithoutFromCityInput | TransportUpdateWithWhereUniqueWithoutFromCityInput[]
    updateMany?: TransportUpdateManyWithWhereWithoutFromCityInput | TransportUpdateManyWithWhereWithoutFromCityInput[]
    deleteMany?: TransportScalarWhereInput | TransportScalarWhereInput[]
  }

  export type TransportUncheckedUpdateManyWithoutToCityNestedInput = {
    create?: XOR<TransportCreateWithoutToCityInput, TransportUncheckedCreateWithoutToCityInput> | TransportCreateWithoutToCityInput[] | TransportUncheckedCreateWithoutToCityInput[]
    connectOrCreate?: TransportCreateOrConnectWithoutToCityInput | TransportCreateOrConnectWithoutToCityInput[]
    upsert?: TransportUpsertWithWhereUniqueWithoutToCityInput | TransportUpsertWithWhereUniqueWithoutToCityInput[]
    createMany?: TransportCreateManyToCityInputEnvelope
    set?: TransportWhereUniqueInput | TransportWhereUniqueInput[]
    disconnect?: TransportWhereUniqueInput | TransportWhereUniqueInput[]
    delete?: TransportWhereUniqueInput | TransportWhereUniqueInput[]
    connect?: TransportWhereUniqueInput | TransportWhereUniqueInput[]
    update?: TransportUpdateWithWhereUniqueWithoutToCityInput | TransportUpdateWithWhereUniqueWithoutToCityInput[]
    updateMany?: TransportUpdateManyWithWhereWithoutToCityInput | TransportUpdateManyWithWhereWithoutToCityInput[]
    deleteMany?: TransportScalarWhereInput | TransportScalarWhereInput[]
  }

  export type TripStopUncheckedUpdateManyWithoutCityNestedInput = {
    create?: XOR<TripStopCreateWithoutCityInput, TripStopUncheckedCreateWithoutCityInput> | TripStopCreateWithoutCityInput[] | TripStopUncheckedCreateWithoutCityInput[]
    connectOrCreate?: TripStopCreateOrConnectWithoutCityInput | TripStopCreateOrConnectWithoutCityInput[]
    upsert?: TripStopUpsertWithWhereUniqueWithoutCityInput | TripStopUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: TripStopCreateManyCityInputEnvelope
    set?: TripStopWhereUniqueInput | TripStopWhereUniqueInput[]
    disconnect?: TripStopWhereUniqueInput | TripStopWhereUniqueInput[]
    delete?: TripStopWhereUniqueInput | TripStopWhereUniqueInput[]
    connect?: TripStopWhereUniqueInput | TripStopWhereUniqueInput[]
    update?: TripStopUpdateWithWhereUniqueWithoutCityInput | TripStopUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: TripStopUpdateManyWithWhereWithoutCityInput | TripStopUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: TripStopScalarWhereInput | TripStopScalarWhereInput[]
  }

  export type UserSavedDestinationUncheckedUpdateManyWithoutCityNestedInput = {
    create?: XOR<UserSavedDestinationCreateWithoutCityInput, UserSavedDestinationUncheckedCreateWithoutCityInput> | UserSavedDestinationCreateWithoutCityInput[] | UserSavedDestinationUncheckedCreateWithoutCityInput[]
    connectOrCreate?: UserSavedDestinationCreateOrConnectWithoutCityInput | UserSavedDestinationCreateOrConnectWithoutCityInput[]
    upsert?: UserSavedDestinationUpsertWithWhereUniqueWithoutCityInput | UserSavedDestinationUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: UserSavedDestinationCreateManyCityInputEnvelope
    set?: UserSavedDestinationWhereUniqueInput | UserSavedDestinationWhereUniqueInput[]
    disconnect?: UserSavedDestinationWhereUniqueInput | UserSavedDestinationWhereUniqueInput[]
    delete?: UserSavedDestinationWhereUniqueInput | UserSavedDestinationWhereUniqueInput[]
    connect?: UserSavedDestinationWhereUniqueInput | UserSavedDestinationWhereUniqueInput[]
    update?: UserSavedDestinationUpdateWithWhereUniqueWithoutCityInput | UserSavedDestinationUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: UserSavedDestinationUpdateManyWithWhereWithoutCityInput | UserSavedDestinationUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: UserSavedDestinationScalarWhereInput | UserSavedDestinationScalarWhereInput[]
  }

  export type CityCreateNestedOneWithoutActivitiesInput = {
    create?: XOR<CityCreateWithoutActivitiesInput, CityUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: CityCreateOrConnectWithoutActivitiesInput
    connect?: CityWhereUniqueInput
  }

  export type StopActivityCreateNestedManyWithoutActivityInput = {
    create?: XOR<StopActivityCreateWithoutActivityInput, StopActivityUncheckedCreateWithoutActivityInput> | StopActivityCreateWithoutActivityInput[] | StopActivityUncheckedCreateWithoutActivityInput[]
    connectOrCreate?: StopActivityCreateOrConnectWithoutActivityInput | StopActivityCreateOrConnectWithoutActivityInput[]
    createMany?: StopActivityCreateManyActivityInputEnvelope
    connect?: StopActivityWhereUniqueInput | StopActivityWhereUniqueInput[]
  }

  export type StopActivityUncheckedCreateNestedManyWithoutActivityInput = {
    create?: XOR<StopActivityCreateWithoutActivityInput, StopActivityUncheckedCreateWithoutActivityInput> | StopActivityCreateWithoutActivityInput[] | StopActivityUncheckedCreateWithoutActivityInput[]
    connectOrCreate?: StopActivityCreateOrConnectWithoutActivityInput | StopActivityCreateOrConnectWithoutActivityInput[]
    createMany?: StopActivityCreateManyActivityInputEnvelope
    connect?: StopActivityWhereUniqueInput | StopActivityWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CityUpdateOneRequiredWithoutActivitiesNestedInput = {
    create?: XOR<CityCreateWithoutActivitiesInput, CityUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: CityCreateOrConnectWithoutActivitiesInput
    upsert?: CityUpsertWithoutActivitiesInput
    connect?: CityWhereUniqueInput
    update?: XOR<XOR<CityUpdateToOneWithWhereWithoutActivitiesInput, CityUpdateWithoutActivitiesInput>, CityUncheckedUpdateWithoutActivitiesInput>
  }

  export type StopActivityUpdateManyWithoutActivityNestedInput = {
    create?: XOR<StopActivityCreateWithoutActivityInput, StopActivityUncheckedCreateWithoutActivityInput> | StopActivityCreateWithoutActivityInput[] | StopActivityUncheckedCreateWithoutActivityInput[]
    connectOrCreate?: StopActivityCreateOrConnectWithoutActivityInput | StopActivityCreateOrConnectWithoutActivityInput[]
    upsert?: StopActivityUpsertWithWhereUniqueWithoutActivityInput | StopActivityUpsertWithWhereUniqueWithoutActivityInput[]
    createMany?: StopActivityCreateManyActivityInputEnvelope
    set?: StopActivityWhereUniqueInput | StopActivityWhereUniqueInput[]
    disconnect?: StopActivityWhereUniqueInput | StopActivityWhereUniqueInput[]
    delete?: StopActivityWhereUniqueInput | StopActivityWhereUniqueInput[]
    connect?: StopActivityWhereUniqueInput | StopActivityWhereUniqueInput[]
    update?: StopActivityUpdateWithWhereUniqueWithoutActivityInput | StopActivityUpdateWithWhereUniqueWithoutActivityInput[]
    updateMany?: StopActivityUpdateManyWithWhereWithoutActivityInput | StopActivityUpdateManyWithWhereWithoutActivityInput[]
    deleteMany?: StopActivityScalarWhereInput | StopActivityScalarWhereInput[]
  }

  export type StopActivityUncheckedUpdateManyWithoutActivityNestedInput = {
    create?: XOR<StopActivityCreateWithoutActivityInput, StopActivityUncheckedCreateWithoutActivityInput> | StopActivityCreateWithoutActivityInput[] | StopActivityUncheckedCreateWithoutActivityInput[]
    connectOrCreate?: StopActivityCreateOrConnectWithoutActivityInput | StopActivityCreateOrConnectWithoutActivityInput[]
    upsert?: StopActivityUpsertWithWhereUniqueWithoutActivityInput | StopActivityUpsertWithWhereUniqueWithoutActivityInput[]
    createMany?: StopActivityCreateManyActivityInputEnvelope
    set?: StopActivityWhereUniqueInput | StopActivityWhereUniqueInput[]
    disconnect?: StopActivityWhereUniqueInput | StopActivityWhereUniqueInput[]
    delete?: StopActivityWhereUniqueInput | StopActivityWhereUniqueInput[]
    connect?: StopActivityWhereUniqueInput | StopActivityWhereUniqueInput[]
    update?: StopActivityUpdateWithWhereUniqueWithoutActivityInput | StopActivityUpdateWithWhereUniqueWithoutActivityInput[]
    updateMany?: StopActivityUpdateManyWithWhereWithoutActivityInput | StopActivityUpdateManyWithWhereWithoutActivityInput[]
    deleteMany?: StopActivityScalarWhereInput | StopActivityScalarWhereInput[]
  }

  export type CityCreateNestedOneWithoutHotelsInput = {
    create?: XOR<CityCreateWithoutHotelsInput, CityUncheckedCreateWithoutHotelsInput>
    connectOrCreate?: CityCreateOrConnectWithoutHotelsInput
    connect?: CityWhereUniqueInput
  }

  export type CityUpdateOneRequiredWithoutHotelsNestedInput = {
    create?: XOR<CityCreateWithoutHotelsInput, CityUncheckedCreateWithoutHotelsInput>
    connectOrCreate?: CityCreateOrConnectWithoutHotelsInput
    upsert?: CityUpsertWithoutHotelsInput
    connect?: CityWhereUniqueInput
    update?: XOR<XOR<CityUpdateToOneWithWhereWithoutHotelsInput, CityUpdateWithoutHotelsInput>, CityUncheckedUpdateWithoutHotelsInput>
  }

  export type CityCreateNestedOneWithoutRestaurantsInput = {
    create?: XOR<CityCreateWithoutRestaurantsInput, CityUncheckedCreateWithoutRestaurantsInput>
    connectOrCreate?: CityCreateOrConnectWithoutRestaurantsInput
    connect?: CityWhereUniqueInput
  }

  export type CityUpdateOneRequiredWithoutRestaurantsNestedInput = {
    create?: XOR<CityCreateWithoutRestaurantsInput, CityUncheckedCreateWithoutRestaurantsInput>
    connectOrCreate?: CityCreateOrConnectWithoutRestaurantsInput
    upsert?: CityUpsertWithoutRestaurantsInput
    connect?: CityWhereUniqueInput
    update?: XOR<XOR<CityUpdateToOneWithWhereWithoutRestaurantsInput, CityUpdateWithoutRestaurantsInput>, CityUncheckedUpdateWithoutRestaurantsInput>
  }

  export type CityCreateNestedOneWithoutTransportFromInput = {
    create?: XOR<CityCreateWithoutTransportFromInput, CityUncheckedCreateWithoutTransportFromInput>
    connectOrCreate?: CityCreateOrConnectWithoutTransportFromInput
    connect?: CityWhereUniqueInput
  }

  export type CityCreateNestedOneWithoutTransportToInput = {
    create?: XOR<CityCreateWithoutTransportToInput, CityUncheckedCreateWithoutTransportToInput>
    connectOrCreate?: CityCreateOrConnectWithoutTransportToInput
    connect?: CityWhereUniqueInput
  }

  export type CityUpdateOneRequiredWithoutTransportFromNestedInput = {
    create?: XOR<CityCreateWithoutTransportFromInput, CityUncheckedCreateWithoutTransportFromInput>
    connectOrCreate?: CityCreateOrConnectWithoutTransportFromInput
    upsert?: CityUpsertWithoutTransportFromInput
    connect?: CityWhereUniqueInput
    update?: XOR<XOR<CityUpdateToOneWithWhereWithoutTransportFromInput, CityUpdateWithoutTransportFromInput>, CityUncheckedUpdateWithoutTransportFromInput>
  }

  export type CityUpdateOneRequiredWithoutTransportToNestedInput = {
    create?: XOR<CityCreateWithoutTransportToInput, CityUncheckedCreateWithoutTransportToInput>
    connectOrCreate?: CityCreateOrConnectWithoutTransportToInput
    upsert?: CityUpsertWithoutTransportToInput
    connect?: CityWhereUniqueInput
    update?: XOR<XOR<CityUpdateToOneWithWhereWithoutTransportToInput, CityUpdateWithoutTransportToInput>, CityUncheckedUpdateWithoutTransportToInput>
  }

  export type UserCreateNestedOneWithoutTripsInput = {
    create?: XOR<UserCreateWithoutTripsInput, UserUncheckedCreateWithoutTripsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTripsInput
    connect?: UserWhereUniqueInput
  }

  export type TripStopCreateNestedManyWithoutTripInput = {
    create?: XOR<TripStopCreateWithoutTripInput, TripStopUncheckedCreateWithoutTripInput> | TripStopCreateWithoutTripInput[] | TripStopUncheckedCreateWithoutTripInput[]
    connectOrCreate?: TripStopCreateOrConnectWithoutTripInput | TripStopCreateOrConnectWithoutTripInput[]
    createMany?: TripStopCreateManyTripInputEnvelope
    connect?: TripStopWhereUniqueInput | TripStopWhereUniqueInput[]
  }

  export type TripBudgetCreateNestedManyWithoutTripInput = {
    create?: XOR<TripBudgetCreateWithoutTripInput, TripBudgetUncheckedCreateWithoutTripInput> | TripBudgetCreateWithoutTripInput[] | TripBudgetUncheckedCreateWithoutTripInput[]
    connectOrCreate?: TripBudgetCreateOrConnectWithoutTripInput | TripBudgetCreateOrConnectWithoutTripInput[]
    createMany?: TripBudgetCreateManyTripInputEnvelope
    connect?: TripBudgetWhereUniqueInput | TripBudgetWhereUniqueInput[]
  }

  export type TripMediaCreateNestedManyWithoutTripInput = {
    create?: XOR<TripMediaCreateWithoutTripInput, TripMediaUncheckedCreateWithoutTripInput> | TripMediaCreateWithoutTripInput[] | TripMediaUncheckedCreateWithoutTripInput[]
    connectOrCreate?: TripMediaCreateOrConnectWithoutTripInput | TripMediaCreateOrConnectWithoutTripInput[]
    createMany?: TripMediaCreateManyTripInputEnvelope
    connect?: TripMediaWhereUniqueInput | TripMediaWhereUniqueInput[]
  }

  export type TripShareCreateNestedManyWithoutTripInput = {
    create?: XOR<TripShareCreateWithoutTripInput, TripShareUncheckedCreateWithoutTripInput> | TripShareCreateWithoutTripInput[] | TripShareUncheckedCreateWithoutTripInput[]
    connectOrCreate?: TripShareCreateOrConnectWithoutTripInput | TripShareCreateOrConnectWithoutTripInput[]
    createMany?: TripShareCreateManyTripInputEnvelope
    connect?: TripShareWhereUniqueInput | TripShareWhereUniqueInput[]
  }

  export type TripVersionCreateNestedManyWithoutTripInput = {
    create?: XOR<TripVersionCreateWithoutTripInput, TripVersionUncheckedCreateWithoutTripInput> | TripVersionCreateWithoutTripInput[] | TripVersionUncheckedCreateWithoutTripInput[]
    connectOrCreate?: TripVersionCreateOrConnectWithoutTripInput | TripVersionCreateOrConnectWithoutTripInput[]
    createMany?: TripVersionCreateManyTripInputEnvelope
    connect?: TripVersionWhereUniqueInput | TripVersionWhereUniqueInput[]
  }

  export type TripStopUncheckedCreateNestedManyWithoutTripInput = {
    create?: XOR<TripStopCreateWithoutTripInput, TripStopUncheckedCreateWithoutTripInput> | TripStopCreateWithoutTripInput[] | TripStopUncheckedCreateWithoutTripInput[]
    connectOrCreate?: TripStopCreateOrConnectWithoutTripInput | TripStopCreateOrConnectWithoutTripInput[]
    createMany?: TripStopCreateManyTripInputEnvelope
    connect?: TripStopWhereUniqueInput | TripStopWhereUniqueInput[]
  }

  export type TripBudgetUncheckedCreateNestedManyWithoutTripInput = {
    create?: XOR<TripBudgetCreateWithoutTripInput, TripBudgetUncheckedCreateWithoutTripInput> | TripBudgetCreateWithoutTripInput[] | TripBudgetUncheckedCreateWithoutTripInput[]
    connectOrCreate?: TripBudgetCreateOrConnectWithoutTripInput | TripBudgetCreateOrConnectWithoutTripInput[]
    createMany?: TripBudgetCreateManyTripInputEnvelope
    connect?: TripBudgetWhereUniqueInput | TripBudgetWhereUniqueInput[]
  }

  export type TripMediaUncheckedCreateNestedManyWithoutTripInput = {
    create?: XOR<TripMediaCreateWithoutTripInput, TripMediaUncheckedCreateWithoutTripInput> | TripMediaCreateWithoutTripInput[] | TripMediaUncheckedCreateWithoutTripInput[]
    connectOrCreate?: TripMediaCreateOrConnectWithoutTripInput | TripMediaCreateOrConnectWithoutTripInput[]
    createMany?: TripMediaCreateManyTripInputEnvelope
    connect?: TripMediaWhereUniqueInput | TripMediaWhereUniqueInput[]
  }

  export type TripShareUncheckedCreateNestedManyWithoutTripInput = {
    create?: XOR<TripShareCreateWithoutTripInput, TripShareUncheckedCreateWithoutTripInput> | TripShareCreateWithoutTripInput[] | TripShareUncheckedCreateWithoutTripInput[]
    connectOrCreate?: TripShareCreateOrConnectWithoutTripInput | TripShareCreateOrConnectWithoutTripInput[]
    createMany?: TripShareCreateManyTripInputEnvelope
    connect?: TripShareWhereUniqueInput | TripShareWhereUniqueInput[]
  }

  export type TripVersionUncheckedCreateNestedManyWithoutTripInput = {
    create?: XOR<TripVersionCreateWithoutTripInput, TripVersionUncheckedCreateWithoutTripInput> | TripVersionCreateWithoutTripInput[] | TripVersionUncheckedCreateWithoutTripInput[]
    connectOrCreate?: TripVersionCreateOrConnectWithoutTripInput | TripVersionCreateOrConnectWithoutTripInput[]
    createMany?: TripVersionCreateManyTripInputEnvelope
    connect?: TripVersionWhereUniqueInput | TripVersionWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutTripsNestedInput = {
    create?: XOR<UserCreateWithoutTripsInput, UserUncheckedCreateWithoutTripsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTripsInput
    upsert?: UserUpsertWithoutTripsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTripsInput, UserUpdateWithoutTripsInput>, UserUncheckedUpdateWithoutTripsInput>
  }

  export type TripStopUpdateManyWithoutTripNestedInput = {
    create?: XOR<TripStopCreateWithoutTripInput, TripStopUncheckedCreateWithoutTripInput> | TripStopCreateWithoutTripInput[] | TripStopUncheckedCreateWithoutTripInput[]
    connectOrCreate?: TripStopCreateOrConnectWithoutTripInput | TripStopCreateOrConnectWithoutTripInput[]
    upsert?: TripStopUpsertWithWhereUniqueWithoutTripInput | TripStopUpsertWithWhereUniqueWithoutTripInput[]
    createMany?: TripStopCreateManyTripInputEnvelope
    set?: TripStopWhereUniqueInput | TripStopWhereUniqueInput[]
    disconnect?: TripStopWhereUniqueInput | TripStopWhereUniqueInput[]
    delete?: TripStopWhereUniqueInput | TripStopWhereUniqueInput[]
    connect?: TripStopWhereUniqueInput | TripStopWhereUniqueInput[]
    update?: TripStopUpdateWithWhereUniqueWithoutTripInput | TripStopUpdateWithWhereUniqueWithoutTripInput[]
    updateMany?: TripStopUpdateManyWithWhereWithoutTripInput | TripStopUpdateManyWithWhereWithoutTripInput[]
    deleteMany?: TripStopScalarWhereInput | TripStopScalarWhereInput[]
  }

  export type TripBudgetUpdateManyWithoutTripNestedInput = {
    create?: XOR<TripBudgetCreateWithoutTripInput, TripBudgetUncheckedCreateWithoutTripInput> | TripBudgetCreateWithoutTripInput[] | TripBudgetUncheckedCreateWithoutTripInput[]
    connectOrCreate?: TripBudgetCreateOrConnectWithoutTripInput | TripBudgetCreateOrConnectWithoutTripInput[]
    upsert?: TripBudgetUpsertWithWhereUniqueWithoutTripInput | TripBudgetUpsertWithWhereUniqueWithoutTripInput[]
    createMany?: TripBudgetCreateManyTripInputEnvelope
    set?: TripBudgetWhereUniqueInput | TripBudgetWhereUniqueInput[]
    disconnect?: TripBudgetWhereUniqueInput | TripBudgetWhereUniqueInput[]
    delete?: TripBudgetWhereUniqueInput | TripBudgetWhereUniqueInput[]
    connect?: TripBudgetWhereUniqueInput | TripBudgetWhereUniqueInput[]
    update?: TripBudgetUpdateWithWhereUniqueWithoutTripInput | TripBudgetUpdateWithWhereUniqueWithoutTripInput[]
    updateMany?: TripBudgetUpdateManyWithWhereWithoutTripInput | TripBudgetUpdateManyWithWhereWithoutTripInput[]
    deleteMany?: TripBudgetScalarWhereInput | TripBudgetScalarWhereInput[]
  }

  export type TripMediaUpdateManyWithoutTripNestedInput = {
    create?: XOR<TripMediaCreateWithoutTripInput, TripMediaUncheckedCreateWithoutTripInput> | TripMediaCreateWithoutTripInput[] | TripMediaUncheckedCreateWithoutTripInput[]
    connectOrCreate?: TripMediaCreateOrConnectWithoutTripInput | TripMediaCreateOrConnectWithoutTripInput[]
    upsert?: TripMediaUpsertWithWhereUniqueWithoutTripInput | TripMediaUpsertWithWhereUniqueWithoutTripInput[]
    createMany?: TripMediaCreateManyTripInputEnvelope
    set?: TripMediaWhereUniqueInput | TripMediaWhereUniqueInput[]
    disconnect?: TripMediaWhereUniqueInput | TripMediaWhereUniqueInput[]
    delete?: TripMediaWhereUniqueInput | TripMediaWhereUniqueInput[]
    connect?: TripMediaWhereUniqueInput | TripMediaWhereUniqueInput[]
    update?: TripMediaUpdateWithWhereUniqueWithoutTripInput | TripMediaUpdateWithWhereUniqueWithoutTripInput[]
    updateMany?: TripMediaUpdateManyWithWhereWithoutTripInput | TripMediaUpdateManyWithWhereWithoutTripInput[]
    deleteMany?: TripMediaScalarWhereInput | TripMediaScalarWhereInput[]
  }

  export type TripShareUpdateManyWithoutTripNestedInput = {
    create?: XOR<TripShareCreateWithoutTripInput, TripShareUncheckedCreateWithoutTripInput> | TripShareCreateWithoutTripInput[] | TripShareUncheckedCreateWithoutTripInput[]
    connectOrCreate?: TripShareCreateOrConnectWithoutTripInput | TripShareCreateOrConnectWithoutTripInput[]
    upsert?: TripShareUpsertWithWhereUniqueWithoutTripInput | TripShareUpsertWithWhereUniqueWithoutTripInput[]
    createMany?: TripShareCreateManyTripInputEnvelope
    set?: TripShareWhereUniqueInput | TripShareWhereUniqueInput[]
    disconnect?: TripShareWhereUniqueInput | TripShareWhereUniqueInput[]
    delete?: TripShareWhereUniqueInput | TripShareWhereUniqueInput[]
    connect?: TripShareWhereUniqueInput | TripShareWhereUniqueInput[]
    update?: TripShareUpdateWithWhereUniqueWithoutTripInput | TripShareUpdateWithWhereUniqueWithoutTripInput[]
    updateMany?: TripShareUpdateManyWithWhereWithoutTripInput | TripShareUpdateManyWithWhereWithoutTripInput[]
    deleteMany?: TripShareScalarWhereInput | TripShareScalarWhereInput[]
  }

  export type TripVersionUpdateManyWithoutTripNestedInput = {
    create?: XOR<TripVersionCreateWithoutTripInput, TripVersionUncheckedCreateWithoutTripInput> | TripVersionCreateWithoutTripInput[] | TripVersionUncheckedCreateWithoutTripInput[]
    connectOrCreate?: TripVersionCreateOrConnectWithoutTripInput | TripVersionCreateOrConnectWithoutTripInput[]
    upsert?: TripVersionUpsertWithWhereUniqueWithoutTripInput | TripVersionUpsertWithWhereUniqueWithoutTripInput[]
    createMany?: TripVersionCreateManyTripInputEnvelope
    set?: TripVersionWhereUniqueInput | TripVersionWhereUniqueInput[]
    disconnect?: TripVersionWhereUniqueInput | TripVersionWhereUniqueInput[]
    delete?: TripVersionWhereUniqueInput | TripVersionWhereUniqueInput[]
    connect?: TripVersionWhereUniqueInput | TripVersionWhereUniqueInput[]
    update?: TripVersionUpdateWithWhereUniqueWithoutTripInput | TripVersionUpdateWithWhereUniqueWithoutTripInput[]
    updateMany?: TripVersionUpdateManyWithWhereWithoutTripInput | TripVersionUpdateManyWithWhereWithoutTripInput[]
    deleteMany?: TripVersionScalarWhereInput | TripVersionScalarWhereInput[]
  }

  export type TripStopUncheckedUpdateManyWithoutTripNestedInput = {
    create?: XOR<TripStopCreateWithoutTripInput, TripStopUncheckedCreateWithoutTripInput> | TripStopCreateWithoutTripInput[] | TripStopUncheckedCreateWithoutTripInput[]
    connectOrCreate?: TripStopCreateOrConnectWithoutTripInput | TripStopCreateOrConnectWithoutTripInput[]
    upsert?: TripStopUpsertWithWhereUniqueWithoutTripInput | TripStopUpsertWithWhereUniqueWithoutTripInput[]
    createMany?: TripStopCreateManyTripInputEnvelope
    set?: TripStopWhereUniqueInput | TripStopWhereUniqueInput[]
    disconnect?: TripStopWhereUniqueInput | TripStopWhereUniqueInput[]
    delete?: TripStopWhereUniqueInput | TripStopWhereUniqueInput[]
    connect?: TripStopWhereUniqueInput | TripStopWhereUniqueInput[]
    update?: TripStopUpdateWithWhereUniqueWithoutTripInput | TripStopUpdateWithWhereUniqueWithoutTripInput[]
    updateMany?: TripStopUpdateManyWithWhereWithoutTripInput | TripStopUpdateManyWithWhereWithoutTripInput[]
    deleteMany?: TripStopScalarWhereInput | TripStopScalarWhereInput[]
  }

  export type TripBudgetUncheckedUpdateManyWithoutTripNestedInput = {
    create?: XOR<TripBudgetCreateWithoutTripInput, TripBudgetUncheckedCreateWithoutTripInput> | TripBudgetCreateWithoutTripInput[] | TripBudgetUncheckedCreateWithoutTripInput[]
    connectOrCreate?: TripBudgetCreateOrConnectWithoutTripInput | TripBudgetCreateOrConnectWithoutTripInput[]
    upsert?: TripBudgetUpsertWithWhereUniqueWithoutTripInput | TripBudgetUpsertWithWhereUniqueWithoutTripInput[]
    createMany?: TripBudgetCreateManyTripInputEnvelope
    set?: TripBudgetWhereUniqueInput | TripBudgetWhereUniqueInput[]
    disconnect?: TripBudgetWhereUniqueInput | TripBudgetWhereUniqueInput[]
    delete?: TripBudgetWhereUniqueInput | TripBudgetWhereUniqueInput[]
    connect?: TripBudgetWhereUniqueInput | TripBudgetWhereUniqueInput[]
    update?: TripBudgetUpdateWithWhereUniqueWithoutTripInput | TripBudgetUpdateWithWhereUniqueWithoutTripInput[]
    updateMany?: TripBudgetUpdateManyWithWhereWithoutTripInput | TripBudgetUpdateManyWithWhereWithoutTripInput[]
    deleteMany?: TripBudgetScalarWhereInput | TripBudgetScalarWhereInput[]
  }

  export type TripMediaUncheckedUpdateManyWithoutTripNestedInput = {
    create?: XOR<TripMediaCreateWithoutTripInput, TripMediaUncheckedCreateWithoutTripInput> | TripMediaCreateWithoutTripInput[] | TripMediaUncheckedCreateWithoutTripInput[]
    connectOrCreate?: TripMediaCreateOrConnectWithoutTripInput | TripMediaCreateOrConnectWithoutTripInput[]
    upsert?: TripMediaUpsertWithWhereUniqueWithoutTripInput | TripMediaUpsertWithWhereUniqueWithoutTripInput[]
    createMany?: TripMediaCreateManyTripInputEnvelope
    set?: TripMediaWhereUniqueInput | TripMediaWhereUniqueInput[]
    disconnect?: TripMediaWhereUniqueInput | TripMediaWhereUniqueInput[]
    delete?: TripMediaWhereUniqueInput | TripMediaWhereUniqueInput[]
    connect?: TripMediaWhereUniqueInput | TripMediaWhereUniqueInput[]
    update?: TripMediaUpdateWithWhereUniqueWithoutTripInput | TripMediaUpdateWithWhereUniqueWithoutTripInput[]
    updateMany?: TripMediaUpdateManyWithWhereWithoutTripInput | TripMediaUpdateManyWithWhereWithoutTripInput[]
    deleteMany?: TripMediaScalarWhereInput | TripMediaScalarWhereInput[]
  }

  export type TripShareUncheckedUpdateManyWithoutTripNestedInput = {
    create?: XOR<TripShareCreateWithoutTripInput, TripShareUncheckedCreateWithoutTripInput> | TripShareCreateWithoutTripInput[] | TripShareUncheckedCreateWithoutTripInput[]
    connectOrCreate?: TripShareCreateOrConnectWithoutTripInput | TripShareCreateOrConnectWithoutTripInput[]
    upsert?: TripShareUpsertWithWhereUniqueWithoutTripInput | TripShareUpsertWithWhereUniqueWithoutTripInput[]
    createMany?: TripShareCreateManyTripInputEnvelope
    set?: TripShareWhereUniqueInput | TripShareWhereUniqueInput[]
    disconnect?: TripShareWhereUniqueInput | TripShareWhereUniqueInput[]
    delete?: TripShareWhereUniqueInput | TripShareWhereUniqueInput[]
    connect?: TripShareWhereUniqueInput | TripShareWhereUniqueInput[]
    update?: TripShareUpdateWithWhereUniqueWithoutTripInput | TripShareUpdateWithWhereUniqueWithoutTripInput[]
    updateMany?: TripShareUpdateManyWithWhereWithoutTripInput | TripShareUpdateManyWithWhereWithoutTripInput[]
    deleteMany?: TripShareScalarWhereInput | TripShareScalarWhereInput[]
  }

  export type TripVersionUncheckedUpdateManyWithoutTripNestedInput = {
    create?: XOR<TripVersionCreateWithoutTripInput, TripVersionUncheckedCreateWithoutTripInput> | TripVersionCreateWithoutTripInput[] | TripVersionUncheckedCreateWithoutTripInput[]
    connectOrCreate?: TripVersionCreateOrConnectWithoutTripInput | TripVersionCreateOrConnectWithoutTripInput[]
    upsert?: TripVersionUpsertWithWhereUniqueWithoutTripInput | TripVersionUpsertWithWhereUniqueWithoutTripInput[]
    createMany?: TripVersionCreateManyTripInputEnvelope
    set?: TripVersionWhereUniqueInput | TripVersionWhereUniqueInput[]
    disconnect?: TripVersionWhereUniqueInput | TripVersionWhereUniqueInput[]
    delete?: TripVersionWhereUniqueInput | TripVersionWhereUniqueInput[]
    connect?: TripVersionWhereUniqueInput | TripVersionWhereUniqueInput[]
    update?: TripVersionUpdateWithWhereUniqueWithoutTripInput | TripVersionUpdateWithWhereUniqueWithoutTripInput[]
    updateMany?: TripVersionUpdateManyWithWhereWithoutTripInput | TripVersionUpdateManyWithWhereWithoutTripInput[]
    deleteMany?: TripVersionScalarWhereInput | TripVersionScalarWhereInput[]
  }

  export type TripCreateNestedOneWithoutStopsInput = {
    create?: XOR<TripCreateWithoutStopsInput, TripUncheckedCreateWithoutStopsInput>
    connectOrCreate?: TripCreateOrConnectWithoutStopsInput
    connect?: TripWhereUniqueInput
  }

  export type CityCreateNestedOneWithoutTripStopsInput = {
    create?: XOR<CityCreateWithoutTripStopsInput, CityUncheckedCreateWithoutTripStopsInput>
    connectOrCreate?: CityCreateOrConnectWithoutTripStopsInput
    connect?: CityWhereUniqueInput
  }

  export type StopActivityCreateNestedManyWithoutTripStopInput = {
    create?: XOR<StopActivityCreateWithoutTripStopInput, StopActivityUncheckedCreateWithoutTripStopInput> | StopActivityCreateWithoutTripStopInput[] | StopActivityUncheckedCreateWithoutTripStopInput[]
    connectOrCreate?: StopActivityCreateOrConnectWithoutTripStopInput | StopActivityCreateOrConnectWithoutTripStopInput[]
    createMany?: StopActivityCreateManyTripStopInputEnvelope
    connect?: StopActivityWhereUniqueInput | StopActivityWhereUniqueInput[]
  }

  export type StopActivityUncheckedCreateNestedManyWithoutTripStopInput = {
    create?: XOR<StopActivityCreateWithoutTripStopInput, StopActivityUncheckedCreateWithoutTripStopInput> | StopActivityCreateWithoutTripStopInput[] | StopActivityUncheckedCreateWithoutTripStopInput[]
    connectOrCreate?: StopActivityCreateOrConnectWithoutTripStopInput | StopActivityCreateOrConnectWithoutTripStopInput[]
    createMany?: StopActivityCreateManyTripStopInputEnvelope
    connect?: StopActivityWhereUniqueInput | StopActivityWhereUniqueInput[]
  }

  export type TripUpdateOneRequiredWithoutStopsNestedInput = {
    create?: XOR<TripCreateWithoutStopsInput, TripUncheckedCreateWithoutStopsInput>
    connectOrCreate?: TripCreateOrConnectWithoutStopsInput
    upsert?: TripUpsertWithoutStopsInput
    connect?: TripWhereUniqueInput
    update?: XOR<XOR<TripUpdateToOneWithWhereWithoutStopsInput, TripUpdateWithoutStopsInput>, TripUncheckedUpdateWithoutStopsInput>
  }

  export type CityUpdateOneRequiredWithoutTripStopsNestedInput = {
    create?: XOR<CityCreateWithoutTripStopsInput, CityUncheckedCreateWithoutTripStopsInput>
    connectOrCreate?: CityCreateOrConnectWithoutTripStopsInput
    upsert?: CityUpsertWithoutTripStopsInput
    connect?: CityWhereUniqueInput
    update?: XOR<XOR<CityUpdateToOneWithWhereWithoutTripStopsInput, CityUpdateWithoutTripStopsInput>, CityUncheckedUpdateWithoutTripStopsInput>
  }

  export type StopActivityUpdateManyWithoutTripStopNestedInput = {
    create?: XOR<StopActivityCreateWithoutTripStopInput, StopActivityUncheckedCreateWithoutTripStopInput> | StopActivityCreateWithoutTripStopInput[] | StopActivityUncheckedCreateWithoutTripStopInput[]
    connectOrCreate?: StopActivityCreateOrConnectWithoutTripStopInput | StopActivityCreateOrConnectWithoutTripStopInput[]
    upsert?: StopActivityUpsertWithWhereUniqueWithoutTripStopInput | StopActivityUpsertWithWhereUniqueWithoutTripStopInput[]
    createMany?: StopActivityCreateManyTripStopInputEnvelope
    set?: StopActivityWhereUniqueInput | StopActivityWhereUniqueInput[]
    disconnect?: StopActivityWhereUniqueInput | StopActivityWhereUniqueInput[]
    delete?: StopActivityWhereUniqueInput | StopActivityWhereUniqueInput[]
    connect?: StopActivityWhereUniqueInput | StopActivityWhereUniqueInput[]
    update?: StopActivityUpdateWithWhereUniqueWithoutTripStopInput | StopActivityUpdateWithWhereUniqueWithoutTripStopInput[]
    updateMany?: StopActivityUpdateManyWithWhereWithoutTripStopInput | StopActivityUpdateManyWithWhereWithoutTripStopInput[]
    deleteMany?: StopActivityScalarWhereInput | StopActivityScalarWhereInput[]
  }

  export type StopActivityUncheckedUpdateManyWithoutTripStopNestedInput = {
    create?: XOR<StopActivityCreateWithoutTripStopInput, StopActivityUncheckedCreateWithoutTripStopInput> | StopActivityCreateWithoutTripStopInput[] | StopActivityUncheckedCreateWithoutTripStopInput[]
    connectOrCreate?: StopActivityCreateOrConnectWithoutTripStopInput | StopActivityCreateOrConnectWithoutTripStopInput[]
    upsert?: StopActivityUpsertWithWhereUniqueWithoutTripStopInput | StopActivityUpsertWithWhereUniqueWithoutTripStopInput[]
    createMany?: StopActivityCreateManyTripStopInputEnvelope
    set?: StopActivityWhereUniqueInput | StopActivityWhereUniqueInput[]
    disconnect?: StopActivityWhereUniqueInput | StopActivityWhereUniqueInput[]
    delete?: StopActivityWhereUniqueInput | StopActivityWhereUniqueInput[]
    connect?: StopActivityWhereUniqueInput | StopActivityWhereUniqueInput[]
    update?: StopActivityUpdateWithWhereUniqueWithoutTripStopInput | StopActivityUpdateWithWhereUniqueWithoutTripStopInput[]
    updateMany?: StopActivityUpdateManyWithWhereWithoutTripStopInput | StopActivityUpdateManyWithWhereWithoutTripStopInput[]
    deleteMany?: StopActivityScalarWhereInput | StopActivityScalarWhereInput[]
  }

  export type TripStopCreateNestedOneWithoutActivitiesInput = {
    create?: XOR<TripStopCreateWithoutActivitiesInput, TripStopUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: TripStopCreateOrConnectWithoutActivitiesInput
    connect?: TripStopWhereUniqueInput
  }

  export type ActivityCreateNestedOneWithoutStopActivitiesInput = {
    create?: XOR<ActivityCreateWithoutStopActivitiesInput, ActivityUncheckedCreateWithoutStopActivitiesInput>
    connectOrCreate?: ActivityCreateOrConnectWithoutStopActivitiesInput
    connect?: ActivityWhereUniqueInput
  }

  export type TripStopUpdateOneRequiredWithoutActivitiesNestedInput = {
    create?: XOR<TripStopCreateWithoutActivitiesInput, TripStopUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: TripStopCreateOrConnectWithoutActivitiesInput
    upsert?: TripStopUpsertWithoutActivitiesInput
    connect?: TripStopWhereUniqueInput
    update?: XOR<XOR<TripStopUpdateToOneWithWhereWithoutActivitiesInput, TripStopUpdateWithoutActivitiesInput>, TripStopUncheckedUpdateWithoutActivitiesInput>
  }

  export type ActivityUpdateOneRequiredWithoutStopActivitiesNestedInput = {
    create?: XOR<ActivityCreateWithoutStopActivitiesInput, ActivityUncheckedCreateWithoutStopActivitiesInput>
    connectOrCreate?: ActivityCreateOrConnectWithoutStopActivitiesInput
    upsert?: ActivityUpsertWithoutStopActivitiesInput
    connect?: ActivityWhereUniqueInput
    update?: XOR<XOR<ActivityUpdateToOneWithWhereWithoutStopActivitiesInput, ActivityUpdateWithoutStopActivitiesInput>, ActivityUncheckedUpdateWithoutStopActivitiesInput>
  }

  export type TripCreateNestedOneWithoutBudgetsInput = {
    create?: XOR<TripCreateWithoutBudgetsInput, TripUncheckedCreateWithoutBudgetsInput>
    connectOrCreate?: TripCreateOrConnectWithoutBudgetsInput
    connect?: TripWhereUniqueInput
  }

  export type TripUpdateOneRequiredWithoutBudgetsNestedInput = {
    create?: XOR<TripCreateWithoutBudgetsInput, TripUncheckedCreateWithoutBudgetsInput>
    connectOrCreate?: TripCreateOrConnectWithoutBudgetsInput
    upsert?: TripUpsertWithoutBudgetsInput
    connect?: TripWhereUniqueInput
    update?: XOR<XOR<TripUpdateToOneWithWhereWithoutBudgetsInput, TripUpdateWithoutBudgetsInput>, TripUncheckedUpdateWithoutBudgetsInput>
  }

  export type TripCreateNestedOneWithoutMediaInput = {
    create?: XOR<TripCreateWithoutMediaInput, TripUncheckedCreateWithoutMediaInput>
    connectOrCreate?: TripCreateOrConnectWithoutMediaInput
    connect?: TripWhereUniqueInput
  }

  export type TripUpdateOneRequiredWithoutMediaNestedInput = {
    create?: XOR<TripCreateWithoutMediaInput, TripUncheckedCreateWithoutMediaInput>
    connectOrCreate?: TripCreateOrConnectWithoutMediaInput
    upsert?: TripUpsertWithoutMediaInput
    connect?: TripWhereUniqueInput
    update?: XOR<XOR<TripUpdateToOneWithWhereWithoutMediaInput, TripUpdateWithoutMediaInput>, TripUncheckedUpdateWithoutMediaInput>
  }

  export type TripCreateNestedOneWithoutSharesInput = {
    create?: XOR<TripCreateWithoutSharesInput, TripUncheckedCreateWithoutSharesInput>
    connectOrCreate?: TripCreateOrConnectWithoutSharesInput
    connect?: TripWhereUniqueInput
  }

  export type TripUpdateOneRequiredWithoutSharesNestedInput = {
    create?: XOR<TripCreateWithoutSharesInput, TripUncheckedCreateWithoutSharesInput>
    connectOrCreate?: TripCreateOrConnectWithoutSharesInput
    upsert?: TripUpsertWithoutSharesInput
    connect?: TripWhereUniqueInput
    update?: XOR<XOR<TripUpdateToOneWithWhereWithoutSharesInput, TripUpdateWithoutSharesInput>, TripUncheckedUpdateWithoutSharesInput>
  }

  export type TripCreateNestedOneWithoutVersionsInput = {
    create?: XOR<TripCreateWithoutVersionsInput, TripUncheckedCreateWithoutVersionsInput>
    connectOrCreate?: TripCreateOrConnectWithoutVersionsInput
    connect?: TripWhereUniqueInput
  }

  export type TripUpdateOneRequiredWithoutVersionsNestedInput = {
    create?: XOR<TripCreateWithoutVersionsInput, TripUncheckedCreateWithoutVersionsInput>
    connectOrCreate?: TripCreateOrConnectWithoutVersionsInput
    upsert?: TripUpsertWithoutVersionsInput
    connect?: TripWhereUniqueInput
    update?: XOR<XOR<TripUpdateToOneWithWhereWithoutVersionsInput, TripUpdateWithoutVersionsInput>, TripUncheckedUpdateWithoutVersionsInput>
  }

  export type UserCreateNestedOneWithoutSavedDestinationsInput = {
    create?: XOR<UserCreateWithoutSavedDestinationsInput, UserUncheckedCreateWithoutSavedDestinationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSavedDestinationsInput
    connect?: UserWhereUniqueInput
  }

  export type CityCreateNestedOneWithoutSavedDestinationsInput = {
    create?: XOR<CityCreateWithoutSavedDestinationsInput, CityUncheckedCreateWithoutSavedDestinationsInput>
    connectOrCreate?: CityCreateOrConnectWithoutSavedDestinationsInput
    connect?: CityWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSavedDestinationsNestedInput = {
    create?: XOR<UserCreateWithoutSavedDestinationsInput, UserUncheckedCreateWithoutSavedDestinationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSavedDestinationsInput
    upsert?: UserUpsertWithoutSavedDestinationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSavedDestinationsInput, UserUpdateWithoutSavedDestinationsInput>, UserUncheckedUpdateWithoutSavedDestinationsInput>
  }

  export type CityUpdateOneRequiredWithoutSavedDestinationsNestedInput = {
    create?: XOR<CityCreateWithoutSavedDestinationsInput, CityUncheckedCreateWithoutSavedDestinationsInput>
    connectOrCreate?: CityCreateOrConnectWithoutSavedDestinationsInput
    upsert?: CityUpsertWithoutSavedDestinationsInput
    connect?: CityWhereUniqueInput
    update?: XOR<XOR<CityUpdateToOneWithWhereWithoutSavedDestinationsInput, CityUpdateWithoutSavedDestinationsInput>, CityUncheckedUpdateWithoutSavedDestinationsInput>
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type TripCreateWithoutUserInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    coverPhotoUrl?: string | null
    status?: string
    isPublic?: boolean
    totalEstimatedCost?: number
    currency?: string
    travelStyle?: string | null
    versionNumber?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    stops?: TripStopCreateNestedManyWithoutTripInput
    budgets?: TripBudgetCreateNestedManyWithoutTripInput
    media?: TripMediaCreateNestedManyWithoutTripInput
    shares?: TripShareCreateNestedManyWithoutTripInput
    versions?: TripVersionCreateNestedManyWithoutTripInput
  }

  export type TripUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    coverPhotoUrl?: string | null
    status?: string
    isPublic?: boolean
    totalEstimatedCost?: number
    currency?: string
    travelStyle?: string | null
    versionNumber?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    stops?: TripStopUncheckedCreateNestedManyWithoutTripInput
    budgets?: TripBudgetUncheckedCreateNestedManyWithoutTripInput
    media?: TripMediaUncheckedCreateNestedManyWithoutTripInput
    shares?: TripShareUncheckedCreateNestedManyWithoutTripInput
    versions?: TripVersionUncheckedCreateNestedManyWithoutTripInput
  }

  export type TripCreateOrConnectWithoutUserInput = {
    where: TripWhereUniqueInput
    create: XOR<TripCreateWithoutUserInput, TripUncheckedCreateWithoutUserInput>
  }

  export type TripCreateManyUserInputEnvelope = {
    data: TripCreateManyUserInput | TripCreateManyUserInput[]
  }

  export type UserSavedDestinationCreateWithoutUserInput = {
    id?: string
    notes?: string | null
    savedAt?: Date | string
    city: CityCreateNestedOneWithoutSavedDestinationsInput
  }

  export type UserSavedDestinationUncheckedCreateWithoutUserInput = {
    id?: string
    cityId: string
    notes?: string | null
    savedAt?: Date | string
  }

  export type UserSavedDestinationCreateOrConnectWithoutUserInput = {
    where: UserSavedDestinationWhereUniqueInput
    create: XOR<UserSavedDestinationCreateWithoutUserInput, UserSavedDestinationUncheckedCreateWithoutUserInput>
  }

  export type UserSavedDestinationCreateManyUserInputEnvelope = {
    data: UserSavedDestinationCreateManyUserInput | UserSavedDestinationCreateManyUserInput[]
  }

  export type AuditLogCreateWithoutUserInput = {
    id?: string
    action: string
    entityType: string
    entityId: string
    changes?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: string
    action: string
    entityType: string
    entityId: string
    changes?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[]
  }

  export type UserRoleCreateWithoutUserInput = {
    id?: string
    assignedAt?: Date | string
    role: RoleCreateNestedOneWithoutUserRolesInput
  }

  export type UserRoleUncheckedCreateWithoutUserInput = {
    id?: string
    roleId: string
    assignedAt?: Date | string
  }

  export type UserRoleCreateOrConnectWithoutUserInput = {
    where: UserRoleWhereUniqueInput
    create: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput>
  }

  export type UserRoleCreateManyUserInputEnvelope = {
    data: UserRoleCreateManyUserInput | UserRoleCreateManyUserInput[]
  }

  export type TripUpsertWithWhereUniqueWithoutUserInput = {
    where: TripWhereUniqueInput
    update: XOR<TripUpdateWithoutUserInput, TripUncheckedUpdateWithoutUserInput>
    create: XOR<TripCreateWithoutUserInput, TripUncheckedCreateWithoutUserInput>
  }

  export type TripUpdateWithWhereUniqueWithoutUserInput = {
    where: TripWhereUniqueInput
    data: XOR<TripUpdateWithoutUserInput, TripUncheckedUpdateWithoutUserInput>
  }

  export type TripUpdateManyWithWhereWithoutUserInput = {
    where: TripScalarWhereInput
    data: XOR<TripUpdateManyMutationInput, TripUncheckedUpdateManyWithoutUserInput>
  }

  export type TripScalarWhereInput = {
    AND?: TripScalarWhereInput | TripScalarWhereInput[]
    OR?: TripScalarWhereInput[]
    NOT?: TripScalarWhereInput | TripScalarWhereInput[]
    id?: StringFilter<"Trip"> | string
    userId?: StringFilter<"Trip"> | string
    name?: StringFilter<"Trip"> | string
    description?: StringNullableFilter<"Trip"> | string | null
    startDate?: DateTimeFilter<"Trip"> | Date | string
    endDate?: DateTimeFilter<"Trip"> | Date | string
    coverPhotoUrl?: StringNullableFilter<"Trip"> | string | null
    status?: StringFilter<"Trip"> | string
    isPublic?: BoolFilter<"Trip"> | boolean
    totalEstimatedCost?: FloatFilter<"Trip"> | number
    currency?: StringFilter<"Trip"> | string
    travelStyle?: StringNullableFilter<"Trip"> | string | null
    versionNumber?: IntFilter<"Trip"> | number
    createdAt?: DateTimeFilter<"Trip"> | Date | string
    updatedAt?: DateTimeFilter<"Trip"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Trip"> | Date | string | null
  }

  export type UserSavedDestinationUpsertWithWhereUniqueWithoutUserInput = {
    where: UserSavedDestinationWhereUniqueInput
    update: XOR<UserSavedDestinationUpdateWithoutUserInput, UserSavedDestinationUncheckedUpdateWithoutUserInput>
    create: XOR<UserSavedDestinationCreateWithoutUserInput, UserSavedDestinationUncheckedCreateWithoutUserInput>
  }

  export type UserSavedDestinationUpdateWithWhereUniqueWithoutUserInput = {
    where: UserSavedDestinationWhereUniqueInput
    data: XOR<UserSavedDestinationUpdateWithoutUserInput, UserSavedDestinationUncheckedUpdateWithoutUserInput>
  }

  export type UserSavedDestinationUpdateManyWithWhereWithoutUserInput = {
    where: UserSavedDestinationScalarWhereInput
    data: XOR<UserSavedDestinationUpdateManyMutationInput, UserSavedDestinationUncheckedUpdateManyWithoutUserInput>
  }

  export type UserSavedDestinationScalarWhereInput = {
    AND?: UserSavedDestinationScalarWhereInput | UserSavedDestinationScalarWhereInput[]
    OR?: UserSavedDestinationScalarWhereInput[]
    NOT?: UserSavedDestinationScalarWhereInput | UserSavedDestinationScalarWhereInput[]
    id?: StringFilter<"UserSavedDestination"> | string
    userId?: StringFilter<"UserSavedDestination"> | string
    cityId?: StringFilter<"UserSavedDestination"> | string
    notes?: StringNullableFilter<"UserSavedDestination"> | string | null
    savedAt?: DateTimeFilter<"UserSavedDestination"> | Date | string
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    changes?: StringNullableFilter<"AuditLog"> | string | null
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type UserRoleUpsertWithWhereUniqueWithoutUserInput = {
    where: UserRoleWhereUniqueInput
    update: XOR<UserRoleUpdateWithoutUserInput, UserRoleUncheckedUpdateWithoutUserInput>
    create: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput>
  }

  export type UserRoleUpdateWithWhereUniqueWithoutUserInput = {
    where: UserRoleWhereUniqueInput
    data: XOR<UserRoleUpdateWithoutUserInput, UserRoleUncheckedUpdateWithoutUserInput>
  }

  export type UserRoleUpdateManyWithWhereWithoutUserInput = {
    where: UserRoleScalarWhereInput
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyWithoutUserInput>
  }

  export type UserRoleScalarWhereInput = {
    AND?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
    OR?: UserRoleScalarWhereInput[]
    NOT?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
    id?: StringFilter<"UserRole"> | string
    userId?: StringFilter<"UserRole"> | string
    roleId?: StringFilter<"UserRole"> | string
    assignedAt?: DateTimeFilter<"UserRole"> | Date | string
  }

  export type UserRoleCreateWithoutRoleInput = {
    id?: string
    assignedAt?: Date | string
    user: UserCreateNestedOneWithoutUserRolesInput
  }

  export type UserRoleUncheckedCreateWithoutRoleInput = {
    id?: string
    userId: string
    assignedAt?: Date | string
  }

  export type UserRoleCreateOrConnectWithoutRoleInput = {
    where: UserRoleWhereUniqueInput
    create: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput>
  }

  export type UserRoleCreateManyRoleInputEnvelope = {
    data: UserRoleCreateManyRoleInput | UserRoleCreateManyRoleInput[]
  }

  export type UserRoleUpsertWithWhereUniqueWithoutRoleInput = {
    where: UserRoleWhereUniqueInput
    update: XOR<UserRoleUpdateWithoutRoleInput, UserRoleUncheckedUpdateWithoutRoleInput>
    create: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput>
  }

  export type UserRoleUpdateWithWhereUniqueWithoutRoleInput = {
    where: UserRoleWhereUniqueInput
    data: XOR<UserRoleUpdateWithoutRoleInput, UserRoleUncheckedUpdateWithoutRoleInput>
  }

  export type UserRoleUpdateManyWithWhereWithoutRoleInput = {
    where: UserRoleScalarWhereInput
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyWithoutRoleInput>
  }

  export type UserCreateWithoutUserRolesInput = {
    id?: string
    email: string
    passwordHash: string
    fullName: string
    profilePhotoUrl?: string | null
    preferredLanguage?: string
    preferredCurrency?: string
    emailVerified?: boolean
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    trips?: TripCreateNestedManyWithoutUserInput
    savedDestinations?: UserSavedDestinationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserRolesInput = {
    id?: string
    email: string
    passwordHash: string
    fullName: string
    profilePhotoUrl?: string | null
    preferredLanguage?: string
    preferredCurrency?: string
    emailVerified?: boolean
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    trips?: TripUncheckedCreateNestedManyWithoutUserInput
    savedDestinations?: UserSavedDestinationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserRolesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserRolesInput, UserUncheckedCreateWithoutUserRolesInput>
  }

  export type RoleCreateWithoutUserRolesInput = {
    id?: string
    name: string
    description?: string | null
    permissions?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleUncheckedCreateWithoutUserRolesInput = {
    id?: string
    name: string
    description?: string | null
    permissions?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleCreateOrConnectWithoutUserRolesInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutUserRolesInput, RoleUncheckedCreateWithoutUserRolesInput>
  }

  export type UserUpsertWithoutUserRolesInput = {
    update: XOR<UserUpdateWithoutUserRolesInput, UserUncheckedUpdateWithoutUserRolesInput>
    create: XOR<UserCreateWithoutUserRolesInput, UserUncheckedCreateWithoutUserRolesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserRolesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserRolesInput, UserUncheckedUpdateWithoutUserRolesInput>
  }

  export type UserUpdateWithoutUserRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    preferredCurrency?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trips?: TripUpdateManyWithoutUserNestedInput
    savedDestinations?: UserSavedDestinationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    preferredCurrency?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trips?: TripUncheckedUpdateManyWithoutUserNestedInput
    savedDestinations?: UserSavedDestinationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type RoleUpsertWithoutUserRolesInput = {
    update: XOR<RoleUpdateWithoutUserRolesInput, RoleUncheckedUpdateWithoutUserRolesInput>
    create: XOR<RoleCreateWithoutUserRolesInput, RoleUncheckedCreateWithoutUserRolesInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutUserRolesInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutUserRolesInput, RoleUncheckedUpdateWithoutUserRolesInput>
  }

  export type RoleUpdateWithoutUserRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleUncheckedUpdateWithoutUserRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityCreateWithoutCityInput = {
    id?: string
    name: string
    category: string
    description?: string | null
    estimatedCost?: number
    currency?: string
    durationMinutes?: number | null
    imageUrl?: string | null
    rating?: number | null
    popularityScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    stopActivities?: StopActivityCreateNestedManyWithoutActivityInput
  }

  export type ActivityUncheckedCreateWithoutCityInput = {
    id?: string
    name: string
    category: string
    description?: string | null
    estimatedCost?: number
    currency?: string
    durationMinutes?: number | null
    imageUrl?: string | null
    rating?: number | null
    popularityScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    stopActivities?: StopActivityUncheckedCreateNestedManyWithoutActivityInput
  }

  export type ActivityCreateOrConnectWithoutCityInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutCityInput, ActivityUncheckedCreateWithoutCityInput>
  }

  export type ActivityCreateManyCityInputEnvelope = {
    data: ActivityCreateManyCityInput | ActivityCreateManyCityInput[]
  }

  export type HotelCreateWithoutCityInput = {
    id?: string
    name: string
    category: string
    description?: string | null
    pricePerNight: number
    currency?: string
    rating?: number | null
    amenities?: string | null
    address?: string | null
    imageUrl?: string | null
    contactPhone?: string | null
    website?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type HotelUncheckedCreateWithoutCityInput = {
    id?: string
    name: string
    category: string
    description?: string | null
    pricePerNight: number
    currency?: string
    rating?: number | null
    amenities?: string | null
    address?: string | null
    imageUrl?: string | null
    contactPhone?: string | null
    website?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type HotelCreateOrConnectWithoutCityInput = {
    where: HotelWhereUniqueInput
    create: XOR<HotelCreateWithoutCityInput, HotelUncheckedCreateWithoutCityInput>
  }

  export type HotelCreateManyCityInputEnvelope = {
    data: HotelCreateManyCityInput | HotelCreateManyCityInput[]
  }

  export type RestaurantCreateWithoutCityInput = {
    id?: string
    name: string
    cuisineType: string
    priceRange: string
    avgMealCost: number
    currency?: string
    rating?: number | null
    description?: string | null
    address?: string | null
    imageUrl?: string | null
    isVegetarian?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type RestaurantUncheckedCreateWithoutCityInput = {
    id?: string
    name: string
    cuisineType: string
    priceRange: string
    avgMealCost: number
    currency?: string
    rating?: number | null
    description?: string | null
    address?: string | null
    imageUrl?: string | null
    isVegetarian?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type RestaurantCreateOrConnectWithoutCityInput = {
    where: RestaurantWhereUniqueInput
    create: XOR<RestaurantCreateWithoutCityInput, RestaurantUncheckedCreateWithoutCityInput>
  }

  export type RestaurantCreateManyCityInputEnvelope = {
    data: RestaurantCreateManyCityInput | RestaurantCreateManyCityInput[]
  }

  export type TransportCreateWithoutFromCityInput = {
    id?: string
    transportType: string
    operatorName: string
    departureTime: string
    arrivalTime: string
    durationMinutes: number
    price: number
    currency?: string
    classType?: string | null
    frequency?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    toCity: CityCreateNestedOneWithoutTransportToInput
  }

  export type TransportUncheckedCreateWithoutFromCityInput = {
    id?: string
    toCityId: string
    transportType: string
    operatorName: string
    departureTime: string
    arrivalTime: string
    durationMinutes: number
    price: number
    currency?: string
    classType?: string | null
    frequency?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type TransportCreateOrConnectWithoutFromCityInput = {
    where: TransportWhereUniqueInput
    create: XOR<TransportCreateWithoutFromCityInput, TransportUncheckedCreateWithoutFromCityInput>
  }

  export type TransportCreateManyFromCityInputEnvelope = {
    data: TransportCreateManyFromCityInput | TransportCreateManyFromCityInput[]
  }

  export type TransportCreateWithoutToCityInput = {
    id?: string
    transportType: string
    operatorName: string
    departureTime: string
    arrivalTime: string
    durationMinutes: number
    price: number
    currency?: string
    classType?: string | null
    frequency?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    fromCity: CityCreateNestedOneWithoutTransportFromInput
  }

  export type TransportUncheckedCreateWithoutToCityInput = {
    id?: string
    fromCityId: string
    transportType: string
    operatorName: string
    departureTime: string
    arrivalTime: string
    durationMinutes: number
    price: number
    currency?: string
    classType?: string | null
    frequency?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type TransportCreateOrConnectWithoutToCityInput = {
    where: TransportWhereUniqueInput
    create: XOR<TransportCreateWithoutToCityInput, TransportUncheckedCreateWithoutToCityInput>
  }

  export type TransportCreateManyToCityInputEnvelope = {
    data: TransportCreateManyToCityInput | TransportCreateManyToCityInput[]
  }

  export type TripStopCreateWithoutCityInput = {
    id?: string
    stopOrder: number
    arrivalDate: Date | string
    departureDate: Date | string
    accommodationName?: string | null
    accommodationCost?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    trip: TripCreateNestedOneWithoutStopsInput
    activities?: StopActivityCreateNestedManyWithoutTripStopInput
  }

  export type TripStopUncheckedCreateWithoutCityInput = {
    id?: string
    tripId: string
    stopOrder: number
    arrivalDate: Date | string
    departureDate: Date | string
    accommodationName?: string | null
    accommodationCost?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    activities?: StopActivityUncheckedCreateNestedManyWithoutTripStopInput
  }

  export type TripStopCreateOrConnectWithoutCityInput = {
    where: TripStopWhereUniqueInput
    create: XOR<TripStopCreateWithoutCityInput, TripStopUncheckedCreateWithoutCityInput>
  }

  export type TripStopCreateManyCityInputEnvelope = {
    data: TripStopCreateManyCityInput | TripStopCreateManyCityInput[]
  }

  export type UserSavedDestinationCreateWithoutCityInput = {
    id?: string
    notes?: string | null
    savedAt?: Date | string
    user: UserCreateNestedOneWithoutSavedDestinationsInput
  }

  export type UserSavedDestinationUncheckedCreateWithoutCityInput = {
    id?: string
    userId: string
    notes?: string | null
    savedAt?: Date | string
  }

  export type UserSavedDestinationCreateOrConnectWithoutCityInput = {
    where: UserSavedDestinationWhereUniqueInput
    create: XOR<UserSavedDestinationCreateWithoutCityInput, UserSavedDestinationUncheckedCreateWithoutCityInput>
  }

  export type UserSavedDestinationCreateManyCityInputEnvelope = {
    data: UserSavedDestinationCreateManyCityInput | UserSavedDestinationCreateManyCityInput[]
  }

  export type ActivityUpsertWithWhereUniqueWithoutCityInput = {
    where: ActivityWhereUniqueInput
    update: XOR<ActivityUpdateWithoutCityInput, ActivityUncheckedUpdateWithoutCityInput>
    create: XOR<ActivityCreateWithoutCityInput, ActivityUncheckedCreateWithoutCityInput>
  }

  export type ActivityUpdateWithWhereUniqueWithoutCityInput = {
    where: ActivityWhereUniqueInput
    data: XOR<ActivityUpdateWithoutCityInput, ActivityUncheckedUpdateWithoutCityInput>
  }

  export type ActivityUpdateManyWithWhereWithoutCityInput = {
    where: ActivityScalarWhereInput
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyWithoutCityInput>
  }

  export type ActivityScalarWhereInput = {
    AND?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
    OR?: ActivityScalarWhereInput[]
    NOT?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
    id?: StringFilter<"Activity"> | string
    cityId?: StringFilter<"Activity"> | string
    name?: StringFilter<"Activity"> | string
    category?: StringFilter<"Activity"> | string
    description?: StringNullableFilter<"Activity"> | string | null
    estimatedCost?: FloatFilter<"Activity"> | number
    currency?: StringFilter<"Activity"> | string
    durationMinutes?: IntNullableFilter<"Activity"> | number | null
    imageUrl?: StringNullableFilter<"Activity"> | string | null
    rating?: FloatNullableFilter<"Activity"> | number | null
    popularityScore?: IntFilter<"Activity"> | number
    createdAt?: DateTimeFilter<"Activity"> | Date | string
    updatedAt?: DateTimeFilter<"Activity"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Activity"> | Date | string | null
  }

  export type HotelUpsertWithWhereUniqueWithoutCityInput = {
    where: HotelWhereUniqueInput
    update: XOR<HotelUpdateWithoutCityInput, HotelUncheckedUpdateWithoutCityInput>
    create: XOR<HotelCreateWithoutCityInput, HotelUncheckedCreateWithoutCityInput>
  }

  export type HotelUpdateWithWhereUniqueWithoutCityInput = {
    where: HotelWhereUniqueInput
    data: XOR<HotelUpdateWithoutCityInput, HotelUncheckedUpdateWithoutCityInput>
  }

  export type HotelUpdateManyWithWhereWithoutCityInput = {
    where: HotelScalarWhereInput
    data: XOR<HotelUpdateManyMutationInput, HotelUncheckedUpdateManyWithoutCityInput>
  }

  export type HotelScalarWhereInput = {
    AND?: HotelScalarWhereInput | HotelScalarWhereInput[]
    OR?: HotelScalarWhereInput[]
    NOT?: HotelScalarWhereInput | HotelScalarWhereInput[]
    id?: StringFilter<"Hotel"> | string
    cityId?: StringFilter<"Hotel"> | string
    name?: StringFilter<"Hotel"> | string
    category?: StringFilter<"Hotel"> | string
    description?: StringNullableFilter<"Hotel"> | string | null
    pricePerNight?: FloatFilter<"Hotel"> | number
    currency?: StringFilter<"Hotel"> | string
    rating?: FloatNullableFilter<"Hotel"> | number | null
    amenities?: StringNullableFilter<"Hotel"> | string | null
    address?: StringNullableFilter<"Hotel"> | string | null
    imageUrl?: StringNullableFilter<"Hotel"> | string | null
    contactPhone?: StringNullableFilter<"Hotel"> | string | null
    website?: StringNullableFilter<"Hotel"> | string | null
    createdAt?: DateTimeFilter<"Hotel"> | Date | string
    updatedAt?: DateTimeFilter<"Hotel"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Hotel"> | Date | string | null
  }

  export type RestaurantUpsertWithWhereUniqueWithoutCityInput = {
    where: RestaurantWhereUniqueInput
    update: XOR<RestaurantUpdateWithoutCityInput, RestaurantUncheckedUpdateWithoutCityInput>
    create: XOR<RestaurantCreateWithoutCityInput, RestaurantUncheckedCreateWithoutCityInput>
  }

  export type RestaurantUpdateWithWhereUniqueWithoutCityInput = {
    where: RestaurantWhereUniqueInput
    data: XOR<RestaurantUpdateWithoutCityInput, RestaurantUncheckedUpdateWithoutCityInput>
  }

  export type RestaurantUpdateManyWithWhereWithoutCityInput = {
    where: RestaurantScalarWhereInput
    data: XOR<RestaurantUpdateManyMutationInput, RestaurantUncheckedUpdateManyWithoutCityInput>
  }

  export type RestaurantScalarWhereInput = {
    AND?: RestaurantScalarWhereInput | RestaurantScalarWhereInput[]
    OR?: RestaurantScalarWhereInput[]
    NOT?: RestaurantScalarWhereInput | RestaurantScalarWhereInput[]
    id?: StringFilter<"Restaurant"> | string
    cityId?: StringFilter<"Restaurant"> | string
    name?: StringFilter<"Restaurant"> | string
    cuisineType?: StringFilter<"Restaurant"> | string
    priceRange?: StringFilter<"Restaurant"> | string
    avgMealCost?: FloatFilter<"Restaurant"> | number
    currency?: StringFilter<"Restaurant"> | string
    rating?: FloatNullableFilter<"Restaurant"> | number | null
    description?: StringNullableFilter<"Restaurant"> | string | null
    address?: StringNullableFilter<"Restaurant"> | string | null
    imageUrl?: StringNullableFilter<"Restaurant"> | string | null
    isVegetarian?: BoolFilter<"Restaurant"> | boolean
    createdAt?: DateTimeFilter<"Restaurant"> | Date | string
    updatedAt?: DateTimeFilter<"Restaurant"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Restaurant"> | Date | string | null
  }

  export type TransportUpsertWithWhereUniqueWithoutFromCityInput = {
    where: TransportWhereUniqueInput
    update: XOR<TransportUpdateWithoutFromCityInput, TransportUncheckedUpdateWithoutFromCityInput>
    create: XOR<TransportCreateWithoutFromCityInput, TransportUncheckedCreateWithoutFromCityInput>
  }

  export type TransportUpdateWithWhereUniqueWithoutFromCityInput = {
    where: TransportWhereUniqueInput
    data: XOR<TransportUpdateWithoutFromCityInput, TransportUncheckedUpdateWithoutFromCityInput>
  }

  export type TransportUpdateManyWithWhereWithoutFromCityInput = {
    where: TransportScalarWhereInput
    data: XOR<TransportUpdateManyMutationInput, TransportUncheckedUpdateManyWithoutFromCityInput>
  }

  export type TransportScalarWhereInput = {
    AND?: TransportScalarWhereInput | TransportScalarWhereInput[]
    OR?: TransportScalarWhereInput[]
    NOT?: TransportScalarWhereInput | TransportScalarWhereInput[]
    id?: StringFilter<"Transport"> | string
    fromCityId?: StringFilter<"Transport"> | string
    toCityId?: StringFilter<"Transport"> | string
    transportType?: StringFilter<"Transport"> | string
    operatorName?: StringFilter<"Transport"> | string
    departureTime?: StringFilter<"Transport"> | string
    arrivalTime?: StringFilter<"Transport"> | string
    durationMinutes?: IntFilter<"Transport"> | number
    price?: FloatFilter<"Transport"> | number
    currency?: StringFilter<"Transport"> | string
    classType?: StringNullableFilter<"Transport"> | string | null
    frequency?: StringNullableFilter<"Transport"> | string | null
    createdAt?: DateTimeFilter<"Transport"> | Date | string
    updatedAt?: DateTimeFilter<"Transport"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Transport"> | Date | string | null
  }

  export type TransportUpsertWithWhereUniqueWithoutToCityInput = {
    where: TransportWhereUniqueInput
    update: XOR<TransportUpdateWithoutToCityInput, TransportUncheckedUpdateWithoutToCityInput>
    create: XOR<TransportCreateWithoutToCityInput, TransportUncheckedCreateWithoutToCityInput>
  }

  export type TransportUpdateWithWhereUniqueWithoutToCityInput = {
    where: TransportWhereUniqueInput
    data: XOR<TransportUpdateWithoutToCityInput, TransportUncheckedUpdateWithoutToCityInput>
  }

  export type TransportUpdateManyWithWhereWithoutToCityInput = {
    where: TransportScalarWhereInput
    data: XOR<TransportUpdateManyMutationInput, TransportUncheckedUpdateManyWithoutToCityInput>
  }

  export type TripStopUpsertWithWhereUniqueWithoutCityInput = {
    where: TripStopWhereUniqueInput
    update: XOR<TripStopUpdateWithoutCityInput, TripStopUncheckedUpdateWithoutCityInput>
    create: XOR<TripStopCreateWithoutCityInput, TripStopUncheckedCreateWithoutCityInput>
  }

  export type TripStopUpdateWithWhereUniqueWithoutCityInput = {
    where: TripStopWhereUniqueInput
    data: XOR<TripStopUpdateWithoutCityInput, TripStopUncheckedUpdateWithoutCityInput>
  }

  export type TripStopUpdateManyWithWhereWithoutCityInput = {
    where: TripStopScalarWhereInput
    data: XOR<TripStopUpdateManyMutationInput, TripStopUncheckedUpdateManyWithoutCityInput>
  }

  export type TripStopScalarWhereInput = {
    AND?: TripStopScalarWhereInput | TripStopScalarWhereInput[]
    OR?: TripStopScalarWhereInput[]
    NOT?: TripStopScalarWhereInput | TripStopScalarWhereInput[]
    id?: StringFilter<"TripStop"> | string
    tripId?: StringFilter<"TripStop"> | string
    cityId?: StringFilter<"TripStop"> | string
    stopOrder?: IntFilter<"TripStop"> | number
    arrivalDate?: DateTimeFilter<"TripStop"> | Date | string
    departureDate?: DateTimeFilter<"TripStop"> | Date | string
    accommodationName?: StringNullableFilter<"TripStop"> | string | null
    accommodationCost?: FloatNullableFilter<"TripStop"> | number | null
    notes?: StringNullableFilter<"TripStop"> | string | null
    createdAt?: DateTimeFilter<"TripStop"> | Date | string
    updatedAt?: DateTimeFilter<"TripStop"> | Date | string
    deletedAt?: DateTimeNullableFilter<"TripStop"> | Date | string | null
  }

  export type UserSavedDestinationUpsertWithWhereUniqueWithoutCityInput = {
    where: UserSavedDestinationWhereUniqueInput
    update: XOR<UserSavedDestinationUpdateWithoutCityInput, UserSavedDestinationUncheckedUpdateWithoutCityInput>
    create: XOR<UserSavedDestinationCreateWithoutCityInput, UserSavedDestinationUncheckedCreateWithoutCityInput>
  }

  export type UserSavedDestinationUpdateWithWhereUniqueWithoutCityInput = {
    where: UserSavedDestinationWhereUniqueInput
    data: XOR<UserSavedDestinationUpdateWithoutCityInput, UserSavedDestinationUncheckedUpdateWithoutCityInput>
  }

  export type UserSavedDestinationUpdateManyWithWhereWithoutCityInput = {
    where: UserSavedDestinationScalarWhereInput
    data: XOR<UserSavedDestinationUpdateManyMutationInput, UserSavedDestinationUncheckedUpdateManyWithoutCityInput>
  }

  export type CityCreateWithoutActivitiesInput = {
    id?: string
    name: string
    country: string
    countryCode: string
    region?: string | null
    latitude: number
    longitude: number
    timezone?: string
    costIndex?: number
    popularityScore?: number
    description?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    hotels?: HotelCreateNestedManyWithoutCityInput
    restaurants?: RestaurantCreateNestedManyWithoutCityInput
    transportFrom?: TransportCreateNestedManyWithoutFromCityInput
    transportTo?: TransportCreateNestedManyWithoutToCityInput
    tripStops?: TripStopCreateNestedManyWithoutCityInput
    savedDestinations?: UserSavedDestinationCreateNestedManyWithoutCityInput
  }

  export type CityUncheckedCreateWithoutActivitiesInput = {
    id?: string
    name: string
    country: string
    countryCode: string
    region?: string | null
    latitude: number
    longitude: number
    timezone?: string
    costIndex?: number
    popularityScore?: number
    description?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    hotels?: HotelUncheckedCreateNestedManyWithoutCityInput
    restaurants?: RestaurantUncheckedCreateNestedManyWithoutCityInput
    transportFrom?: TransportUncheckedCreateNestedManyWithoutFromCityInput
    transportTo?: TransportUncheckedCreateNestedManyWithoutToCityInput
    tripStops?: TripStopUncheckedCreateNestedManyWithoutCityInput
    savedDestinations?: UserSavedDestinationUncheckedCreateNestedManyWithoutCityInput
  }

  export type CityCreateOrConnectWithoutActivitiesInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutActivitiesInput, CityUncheckedCreateWithoutActivitiesInput>
  }

  export type StopActivityCreateWithoutActivityInput = {
    id?: string
    scheduledDate: Date | string
    scheduledTime?: string | null
    actualCost?: number | null
    notes?: string | null
    isCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tripStop: TripStopCreateNestedOneWithoutActivitiesInput
  }

  export type StopActivityUncheckedCreateWithoutActivityInput = {
    id?: string
    tripStopId: string
    scheduledDate: Date | string
    scheduledTime?: string | null
    actualCost?: number | null
    notes?: string | null
    isCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type StopActivityCreateOrConnectWithoutActivityInput = {
    where: StopActivityWhereUniqueInput
    create: XOR<StopActivityCreateWithoutActivityInput, StopActivityUncheckedCreateWithoutActivityInput>
  }

  export type StopActivityCreateManyActivityInputEnvelope = {
    data: StopActivityCreateManyActivityInput | StopActivityCreateManyActivityInput[]
  }

  export type CityUpsertWithoutActivitiesInput = {
    update: XOR<CityUpdateWithoutActivitiesInput, CityUncheckedUpdateWithoutActivitiesInput>
    create: XOR<CityCreateWithoutActivitiesInput, CityUncheckedCreateWithoutActivitiesInput>
    where?: CityWhereInput
  }

  export type CityUpdateToOneWithWhereWithoutActivitiesInput = {
    where?: CityWhereInput
    data: XOR<CityUpdateWithoutActivitiesInput, CityUncheckedUpdateWithoutActivitiesInput>
  }

  export type CityUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    costIndex?: FloatFieldUpdateOperationsInput | number
    popularityScore?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hotels?: HotelUpdateManyWithoutCityNestedInput
    restaurants?: RestaurantUpdateManyWithoutCityNestedInput
    transportFrom?: TransportUpdateManyWithoutFromCityNestedInput
    transportTo?: TransportUpdateManyWithoutToCityNestedInput
    tripStops?: TripStopUpdateManyWithoutCityNestedInput
    savedDestinations?: UserSavedDestinationUpdateManyWithoutCityNestedInput
  }

  export type CityUncheckedUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    costIndex?: FloatFieldUpdateOperationsInput | number
    popularityScore?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hotels?: HotelUncheckedUpdateManyWithoutCityNestedInput
    restaurants?: RestaurantUncheckedUpdateManyWithoutCityNestedInput
    transportFrom?: TransportUncheckedUpdateManyWithoutFromCityNestedInput
    transportTo?: TransportUncheckedUpdateManyWithoutToCityNestedInput
    tripStops?: TripStopUncheckedUpdateManyWithoutCityNestedInput
    savedDestinations?: UserSavedDestinationUncheckedUpdateManyWithoutCityNestedInput
  }

  export type StopActivityUpsertWithWhereUniqueWithoutActivityInput = {
    where: StopActivityWhereUniqueInput
    update: XOR<StopActivityUpdateWithoutActivityInput, StopActivityUncheckedUpdateWithoutActivityInput>
    create: XOR<StopActivityCreateWithoutActivityInput, StopActivityUncheckedCreateWithoutActivityInput>
  }

  export type StopActivityUpdateWithWhereUniqueWithoutActivityInput = {
    where: StopActivityWhereUniqueInput
    data: XOR<StopActivityUpdateWithoutActivityInput, StopActivityUncheckedUpdateWithoutActivityInput>
  }

  export type StopActivityUpdateManyWithWhereWithoutActivityInput = {
    where: StopActivityScalarWhereInput
    data: XOR<StopActivityUpdateManyMutationInput, StopActivityUncheckedUpdateManyWithoutActivityInput>
  }

  export type StopActivityScalarWhereInput = {
    AND?: StopActivityScalarWhereInput | StopActivityScalarWhereInput[]
    OR?: StopActivityScalarWhereInput[]
    NOT?: StopActivityScalarWhereInput | StopActivityScalarWhereInput[]
    id?: StringFilter<"StopActivity"> | string
    tripStopId?: StringFilter<"StopActivity"> | string
    activityId?: StringFilter<"StopActivity"> | string
    scheduledDate?: DateTimeFilter<"StopActivity"> | Date | string
    scheduledTime?: StringNullableFilter<"StopActivity"> | string | null
    actualCost?: FloatNullableFilter<"StopActivity"> | number | null
    notes?: StringNullableFilter<"StopActivity"> | string | null
    isCompleted?: BoolFilter<"StopActivity"> | boolean
    createdAt?: DateTimeFilter<"StopActivity"> | Date | string
    updatedAt?: DateTimeFilter<"StopActivity"> | Date | string
    deletedAt?: DateTimeNullableFilter<"StopActivity"> | Date | string | null
  }

  export type CityCreateWithoutHotelsInput = {
    id?: string
    name: string
    country: string
    countryCode: string
    region?: string | null
    latitude: number
    longitude: number
    timezone?: string
    costIndex?: number
    popularityScore?: number
    description?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    activities?: ActivityCreateNestedManyWithoutCityInput
    restaurants?: RestaurantCreateNestedManyWithoutCityInput
    transportFrom?: TransportCreateNestedManyWithoutFromCityInput
    transportTo?: TransportCreateNestedManyWithoutToCityInput
    tripStops?: TripStopCreateNestedManyWithoutCityInput
    savedDestinations?: UserSavedDestinationCreateNestedManyWithoutCityInput
  }

  export type CityUncheckedCreateWithoutHotelsInput = {
    id?: string
    name: string
    country: string
    countryCode: string
    region?: string | null
    latitude: number
    longitude: number
    timezone?: string
    costIndex?: number
    popularityScore?: number
    description?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    activities?: ActivityUncheckedCreateNestedManyWithoutCityInput
    restaurants?: RestaurantUncheckedCreateNestedManyWithoutCityInput
    transportFrom?: TransportUncheckedCreateNestedManyWithoutFromCityInput
    transportTo?: TransportUncheckedCreateNestedManyWithoutToCityInput
    tripStops?: TripStopUncheckedCreateNestedManyWithoutCityInput
    savedDestinations?: UserSavedDestinationUncheckedCreateNestedManyWithoutCityInput
  }

  export type CityCreateOrConnectWithoutHotelsInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutHotelsInput, CityUncheckedCreateWithoutHotelsInput>
  }

  export type CityUpsertWithoutHotelsInput = {
    update: XOR<CityUpdateWithoutHotelsInput, CityUncheckedUpdateWithoutHotelsInput>
    create: XOR<CityCreateWithoutHotelsInput, CityUncheckedCreateWithoutHotelsInput>
    where?: CityWhereInput
  }

  export type CityUpdateToOneWithWhereWithoutHotelsInput = {
    where?: CityWhereInput
    data: XOR<CityUpdateWithoutHotelsInput, CityUncheckedUpdateWithoutHotelsInput>
  }

  export type CityUpdateWithoutHotelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    costIndex?: FloatFieldUpdateOperationsInput | number
    popularityScore?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activities?: ActivityUpdateManyWithoutCityNestedInput
    restaurants?: RestaurantUpdateManyWithoutCityNestedInput
    transportFrom?: TransportUpdateManyWithoutFromCityNestedInput
    transportTo?: TransportUpdateManyWithoutToCityNestedInput
    tripStops?: TripStopUpdateManyWithoutCityNestedInput
    savedDestinations?: UserSavedDestinationUpdateManyWithoutCityNestedInput
  }

  export type CityUncheckedUpdateWithoutHotelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    costIndex?: FloatFieldUpdateOperationsInput | number
    popularityScore?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activities?: ActivityUncheckedUpdateManyWithoutCityNestedInput
    restaurants?: RestaurantUncheckedUpdateManyWithoutCityNestedInput
    transportFrom?: TransportUncheckedUpdateManyWithoutFromCityNestedInput
    transportTo?: TransportUncheckedUpdateManyWithoutToCityNestedInput
    tripStops?: TripStopUncheckedUpdateManyWithoutCityNestedInput
    savedDestinations?: UserSavedDestinationUncheckedUpdateManyWithoutCityNestedInput
  }

  export type CityCreateWithoutRestaurantsInput = {
    id?: string
    name: string
    country: string
    countryCode: string
    region?: string | null
    latitude: number
    longitude: number
    timezone?: string
    costIndex?: number
    popularityScore?: number
    description?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    activities?: ActivityCreateNestedManyWithoutCityInput
    hotels?: HotelCreateNestedManyWithoutCityInput
    transportFrom?: TransportCreateNestedManyWithoutFromCityInput
    transportTo?: TransportCreateNestedManyWithoutToCityInput
    tripStops?: TripStopCreateNestedManyWithoutCityInput
    savedDestinations?: UserSavedDestinationCreateNestedManyWithoutCityInput
  }

  export type CityUncheckedCreateWithoutRestaurantsInput = {
    id?: string
    name: string
    country: string
    countryCode: string
    region?: string | null
    latitude: number
    longitude: number
    timezone?: string
    costIndex?: number
    popularityScore?: number
    description?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    activities?: ActivityUncheckedCreateNestedManyWithoutCityInput
    hotels?: HotelUncheckedCreateNestedManyWithoutCityInput
    transportFrom?: TransportUncheckedCreateNestedManyWithoutFromCityInput
    transportTo?: TransportUncheckedCreateNestedManyWithoutToCityInput
    tripStops?: TripStopUncheckedCreateNestedManyWithoutCityInput
    savedDestinations?: UserSavedDestinationUncheckedCreateNestedManyWithoutCityInput
  }

  export type CityCreateOrConnectWithoutRestaurantsInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutRestaurantsInput, CityUncheckedCreateWithoutRestaurantsInput>
  }

  export type CityUpsertWithoutRestaurantsInput = {
    update: XOR<CityUpdateWithoutRestaurantsInput, CityUncheckedUpdateWithoutRestaurantsInput>
    create: XOR<CityCreateWithoutRestaurantsInput, CityUncheckedCreateWithoutRestaurantsInput>
    where?: CityWhereInput
  }

  export type CityUpdateToOneWithWhereWithoutRestaurantsInput = {
    where?: CityWhereInput
    data: XOR<CityUpdateWithoutRestaurantsInput, CityUncheckedUpdateWithoutRestaurantsInput>
  }

  export type CityUpdateWithoutRestaurantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    costIndex?: FloatFieldUpdateOperationsInput | number
    popularityScore?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activities?: ActivityUpdateManyWithoutCityNestedInput
    hotels?: HotelUpdateManyWithoutCityNestedInput
    transportFrom?: TransportUpdateManyWithoutFromCityNestedInput
    transportTo?: TransportUpdateManyWithoutToCityNestedInput
    tripStops?: TripStopUpdateManyWithoutCityNestedInput
    savedDestinations?: UserSavedDestinationUpdateManyWithoutCityNestedInput
  }

  export type CityUncheckedUpdateWithoutRestaurantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    costIndex?: FloatFieldUpdateOperationsInput | number
    popularityScore?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activities?: ActivityUncheckedUpdateManyWithoutCityNestedInput
    hotels?: HotelUncheckedUpdateManyWithoutCityNestedInput
    transportFrom?: TransportUncheckedUpdateManyWithoutFromCityNestedInput
    transportTo?: TransportUncheckedUpdateManyWithoutToCityNestedInput
    tripStops?: TripStopUncheckedUpdateManyWithoutCityNestedInput
    savedDestinations?: UserSavedDestinationUncheckedUpdateManyWithoutCityNestedInput
  }

  export type CityCreateWithoutTransportFromInput = {
    id?: string
    name: string
    country: string
    countryCode: string
    region?: string | null
    latitude: number
    longitude: number
    timezone?: string
    costIndex?: number
    popularityScore?: number
    description?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    activities?: ActivityCreateNestedManyWithoutCityInput
    hotels?: HotelCreateNestedManyWithoutCityInput
    restaurants?: RestaurantCreateNestedManyWithoutCityInput
    transportTo?: TransportCreateNestedManyWithoutToCityInput
    tripStops?: TripStopCreateNestedManyWithoutCityInput
    savedDestinations?: UserSavedDestinationCreateNestedManyWithoutCityInput
  }

  export type CityUncheckedCreateWithoutTransportFromInput = {
    id?: string
    name: string
    country: string
    countryCode: string
    region?: string | null
    latitude: number
    longitude: number
    timezone?: string
    costIndex?: number
    popularityScore?: number
    description?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    activities?: ActivityUncheckedCreateNestedManyWithoutCityInput
    hotels?: HotelUncheckedCreateNestedManyWithoutCityInput
    restaurants?: RestaurantUncheckedCreateNestedManyWithoutCityInput
    transportTo?: TransportUncheckedCreateNestedManyWithoutToCityInput
    tripStops?: TripStopUncheckedCreateNestedManyWithoutCityInput
    savedDestinations?: UserSavedDestinationUncheckedCreateNestedManyWithoutCityInput
  }

  export type CityCreateOrConnectWithoutTransportFromInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutTransportFromInput, CityUncheckedCreateWithoutTransportFromInput>
  }

  export type CityCreateWithoutTransportToInput = {
    id?: string
    name: string
    country: string
    countryCode: string
    region?: string | null
    latitude: number
    longitude: number
    timezone?: string
    costIndex?: number
    popularityScore?: number
    description?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    activities?: ActivityCreateNestedManyWithoutCityInput
    hotels?: HotelCreateNestedManyWithoutCityInput
    restaurants?: RestaurantCreateNestedManyWithoutCityInput
    transportFrom?: TransportCreateNestedManyWithoutFromCityInput
    tripStops?: TripStopCreateNestedManyWithoutCityInput
    savedDestinations?: UserSavedDestinationCreateNestedManyWithoutCityInput
  }

  export type CityUncheckedCreateWithoutTransportToInput = {
    id?: string
    name: string
    country: string
    countryCode: string
    region?: string | null
    latitude: number
    longitude: number
    timezone?: string
    costIndex?: number
    popularityScore?: number
    description?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    activities?: ActivityUncheckedCreateNestedManyWithoutCityInput
    hotels?: HotelUncheckedCreateNestedManyWithoutCityInput
    restaurants?: RestaurantUncheckedCreateNestedManyWithoutCityInput
    transportFrom?: TransportUncheckedCreateNestedManyWithoutFromCityInput
    tripStops?: TripStopUncheckedCreateNestedManyWithoutCityInput
    savedDestinations?: UserSavedDestinationUncheckedCreateNestedManyWithoutCityInput
  }

  export type CityCreateOrConnectWithoutTransportToInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutTransportToInput, CityUncheckedCreateWithoutTransportToInput>
  }

  export type CityUpsertWithoutTransportFromInput = {
    update: XOR<CityUpdateWithoutTransportFromInput, CityUncheckedUpdateWithoutTransportFromInput>
    create: XOR<CityCreateWithoutTransportFromInput, CityUncheckedCreateWithoutTransportFromInput>
    where?: CityWhereInput
  }

  export type CityUpdateToOneWithWhereWithoutTransportFromInput = {
    where?: CityWhereInput
    data: XOR<CityUpdateWithoutTransportFromInput, CityUncheckedUpdateWithoutTransportFromInput>
  }

  export type CityUpdateWithoutTransportFromInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    costIndex?: FloatFieldUpdateOperationsInput | number
    popularityScore?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activities?: ActivityUpdateManyWithoutCityNestedInput
    hotels?: HotelUpdateManyWithoutCityNestedInput
    restaurants?: RestaurantUpdateManyWithoutCityNestedInput
    transportTo?: TransportUpdateManyWithoutToCityNestedInput
    tripStops?: TripStopUpdateManyWithoutCityNestedInput
    savedDestinations?: UserSavedDestinationUpdateManyWithoutCityNestedInput
  }

  export type CityUncheckedUpdateWithoutTransportFromInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    costIndex?: FloatFieldUpdateOperationsInput | number
    popularityScore?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activities?: ActivityUncheckedUpdateManyWithoutCityNestedInput
    hotels?: HotelUncheckedUpdateManyWithoutCityNestedInput
    restaurants?: RestaurantUncheckedUpdateManyWithoutCityNestedInput
    transportTo?: TransportUncheckedUpdateManyWithoutToCityNestedInput
    tripStops?: TripStopUncheckedUpdateManyWithoutCityNestedInput
    savedDestinations?: UserSavedDestinationUncheckedUpdateManyWithoutCityNestedInput
  }

  export type CityUpsertWithoutTransportToInput = {
    update: XOR<CityUpdateWithoutTransportToInput, CityUncheckedUpdateWithoutTransportToInput>
    create: XOR<CityCreateWithoutTransportToInput, CityUncheckedCreateWithoutTransportToInput>
    where?: CityWhereInput
  }

  export type CityUpdateToOneWithWhereWithoutTransportToInput = {
    where?: CityWhereInput
    data: XOR<CityUpdateWithoutTransportToInput, CityUncheckedUpdateWithoutTransportToInput>
  }

  export type CityUpdateWithoutTransportToInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    costIndex?: FloatFieldUpdateOperationsInput | number
    popularityScore?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activities?: ActivityUpdateManyWithoutCityNestedInput
    hotels?: HotelUpdateManyWithoutCityNestedInput
    restaurants?: RestaurantUpdateManyWithoutCityNestedInput
    transportFrom?: TransportUpdateManyWithoutFromCityNestedInput
    tripStops?: TripStopUpdateManyWithoutCityNestedInput
    savedDestinations?: UserSavedDestinationUpdateManyWithoutCityNestedInput
  }

  export type CityUncheckedUpdateWithoutTransportToInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    costIndex?: FloatFieldUpdateOperationsInput | number
    popularityScore?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activities?: ActivityUncheckedUpdateManyWithoutCityNestedInput
    hotels?: HotelUncheckedUpdateManyWithoutCityNestedInput
    restaurants?: RestaurantUncheckedUpdateManyWithoutCityNestedInput
    transportFrom?: TransportUncheckedUpdateManyWithoutFromCityNestedInput
    tripStops?: TripStopUncheckedUpdateManyWithoutCityNestedInput
    savedDestinations?: UserSavedDestinationUncheckedUpdateManyWithoutCityNestedInput
  }

  export type UserCreateWithoutTripsInput = {
    id?: string
    email: string
    passwordHash: string
    fullName: string
    profilePhotoUrl?: string | null
    preferredLanguage?: string
    preferredCurrency?: string
    emailVerified?: boolean
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    savedDestinations?: UserSavedDestinationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTripsInput = {
    id?: string
    email: string
    passwordHash: string
    fullName: string
    profilePhotoUrl?: string | null
    preferredLanguage?: string
    preferredCurrency?: string
    emailVerified?: boolean
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    savedDestinations?: UserSavedDestinationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTripsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTripsInput, UserUncheckedCreateWithoutTripsInput>
  }

  export type TripStopCreateWithoutTripInput = {
    id?: string
    stopOrder: number
    arrivalDate: Date | string
    departureDate: Date | string
    accommodationName?: string | null
    accommodationCost?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    city: CityCreateNestedOneWithoutTripStopsInput
    activities?: StopActivityCreateNestedManyWithoutTripStopInput
  }

  export type TripStopUncheckedCreateWithoutTripInput = {
    id?: string
    cityId: string
    stopOrder: number
    arrivalDate: Date | string
    departureDate: Date | string
    accommodationName?: string | null
    accommodationCost?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    activities?: StopActivityUncheckedCreateNestedManyWithoutTripStopInput
  }

  export type TripStopCreateOrConnectWithoutTripInput = {
    where: TripStopWhereUniqueInput
    create: XOR<TripStopCreateWithoutTripInput, TripStopUncheckedCreateWithoutTripInput>
  }

  export type TripStopCreateManyTripInputEnvelope = {
    data: TripStopCreateManyTripInput | TripStopCreateManyTripInput[]
  }

  export type TripBudgetCreateWithoutTripInput = {
    id?: string
    category: string
    estimatedAmount?: number
    actualAmount?: number | null
    currency?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type TripBudgetUncheckedCreateWithoutTripInput = {
    id?: string
    category: string
    estimatedAmount?: number
    actualAmount?: number | null
    currency?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type TripBudgetCreateOrConnectWithoutTripInput = {
    where: TripBudgetWhereUniqueInput
    create: XOR<TripBudgetCreateWithoutTripInput, TripBudgetUncheckedCreateWithoutTripInput>
  }

  export type TripBudgetCreateManyTripInputEnvelope = {
    data: TripBudgetCreateManyTripInput | TripBudgetCreateManyTripInput[]
  }

  export type TripMediaCreateWithoutTripInput = {
    id?: string
    mediaType: string
    mediaUrl: string
    thumbnailUrl?: string | null
    caption?: string | null
    displayOrder?: number | null
    uploadedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type TripMediaUncheckedCreateWithoutTripInput = {
    id?: string
    mediaType: string
    mediaUrl: string
    thumbnailUrl?: string | null
    caption?: string | null
    displayOrder?: number | null
    uploadedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type TripMediaCreateOrConnectWithoutTripInput = {
    where: TripMediaWhereUniqueInput
    create: XOR<TripMediaCreateWithoutTripInput, TripMediaUncheckedCreateWithoutTripInput>
  }

  export type TripMediaCreateManyTripInputEnvelope = {
    data: TripMediaCreateManyTripInput | TripMediaCreateManyTripInput[]
  }

  export type TripShareCreateWithoutTripInput = {
    id?: string
    shareToken: string
    shareType?: string
    sharedWithEmail?: string | null
    viewCount?: number
    lastViewedAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type TripShareUncheckedCreateWithoutTripInput = {
    id?: string
    shareToken: string
    shareType?: string
    sharedWithEmail?: string | null
    viewCount?: number
    lastViewedAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type TripShareCreateOrConnectWithoutTripInput = {
    where: TripShareWhereUniqueInput
    create: XOR<TripShareCreateWithoutTripInput, TripShareUncheckedCreateWithoutTripInput>
  }

  export type TripShareCreateManyTripInputEnvelope = {
    data: TripShareCreateManyTripInput | TripShareCreateManyTripInput[]
  }

  export type TripVersionCreateWithoutTripInput = {
    id?: string
    versionNumber: number
    snapshotData: string
    changeSummary?: string | null
    createdBy: string
    createdAt?: Date | string
  }

  export type TripVersionUncheckedCreateWithoutTripInput = {
    id?: string
    versionNumber: number
    snapshotData: string
    changeSummary?: string | null
    createdBy: string
    createdAt?: Date | string
  }

  export type TripVersionCreateOrConnectWithoutTripInput = {
    where: TripVersionWhereUniqueInput
    create: XOR<TripVersionCreateWithoutTripInput, TripVersionUncheckedCreateWithoutTripInput>
  }

  export type TripVersionCreateManyTripInputEnvelope = {
    data: TripVersionCreateManyTripInput | TripVersionCreateManyTripInput[]
  }

  export type UserUpsertWithoutTripsInput = {
    update: XOR<UserUpdateWithoutTripsInput, UserUncheckedUpdateWithoutTripsInput>
    create: XOR<UserCreateWithoutTripsInput, UserUncheckedCreateWithoutTripsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTripsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTripsInput, UserUncheckedUpdateWithoutTripsInput>
  }

  export type UserUpdateWithoutTripsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    preferredCurrency?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    savedDestinations?: UserSavedDestinationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTripsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    preferredCurrency?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    savedDestinations?: UserSavedDestinationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TripStopUpsertWithWhereUniqueWithoutTripInput = {
    where: TripStopWhereUniqueInput
    update: XOR<TripStopUpdateWithoutTripInput, TripStopUncheckedUpdateWithoutTripInput>
    create: XOR<TripStopCreateWithoutTripInput, TripStopUncheckedCreateWithoutTripInput>
  }

  export type TripStopUpdateWithWhereUniqueWithoutTripInput = {
    where: TripStopWhereUniqueInput
    data: XOR<TripStopUpdateWithoutTripInput, TripStopUncheckedUpdateWithoutTripInput>
  }

  export type TripStopUpdateManyWithWhereWithoutTripInput = {
    where: TripStopScalarWhereInput
    data: XOR<TripStopUpdateManyMutationInput, TripStopUncheckedUpdateManyWithoutTripInput>
  }

  export type TripBudgetUpsertWithWhereUniqueWithoutTripInput = {
    where: TripBudgetWhereUniqueInput
    update: XOR<TripBudgetUpdateWithoutTripInput, TripBudgetUncheckedUpdateWithoutTripInput>
    create: XOR<TripBudgetCreateWithoutTripInput, TripBudgetUncheckedCreateWithoutTripInput>
  }

  export type TripBudgetUpdateWithWhereUniqueWithoutTripInput = {
    where: TripBudgetWhereUniqueInput
    data: XOR<TripBudgetUpdateWithoutTripInput, TripBudgetUncheckedUpdateWithoutTripInput>
  }

  export type TripBudgetUpdateManyWithWhereWithoutTripInput = {
    where: TripBudgetScalarWhereInput
    data: XOR<TripBudgetUpdateManyMutationInput, TripBudgetUncheckedUpdateManyWithoutTripInput>
  }

  export type TripBudgetScalarWhereInput = {
    AND?: TripBudgetScalarWhereInput | TripBudgetScalarWhereInput[]
    OR?: TripBudgetScalarWhereInput[]
    NOT?: TripBudgetScalarWhereInput | TripBudgetScalarWhereInput[]
    id?: StringFilter<"TripBudget"> | string
    tripId?: StringFilter<"TripBudget"> | string
    category?: StringFilter<"TripBudget"> | string
    estimatedAmount?: FloatFilter<"TripBudget"> | number
    actualAmount?: FloatNullableFilter<"TripBudget"> | number | null
    currency?: StringFilter<"TripBudget"> | string
    notes?: StringNullableFilter<"TripBudget"> | string | null
    createdAt?: DateTimeFilter<"TripBudget"> | Date | string
    updatedAt?: DateTimeFilter<"TripBudget"> | Date | string
    deletedAt?: DateTimeNullableFilter<"TripBudget"> | Date | string | null
  }

  export type TripMediaUpsertWithWhereUniqueWithoutTripInput = {
    where: TripMediaWhereUniqueInput
    update: XOR<TripMediaUpdateWithoutTripInput, TripMediaUncheckedUpdateWithoutTripInput>
    create: XOR<TripMediaCreateWithoutTripInput, TripMediaUncheckedCreateWithoutTripInput>
  }

  export type TripMediaUpdateWithWhereUniqueWithoutTripInput = {
    where: TripMediaWhereUniqueInput
    data: XOR<TripMediaUpdateWithoutTripInput, TripMediaUncheckedUpdateWithoutTripInput>
  }

  export type TripMediaUpdateManyWithWhereWithoutTripInput = {
    where: TripMediaScalarWhereInput
    data: XOR<TripMediaUpdateManyMutationInput, TripMediaUncheckedUpdateManyWithoutTripInput>
  }

  export type TripMediaScalarWhereInput = {
    AND?: TripMediaScalarWhereInput | TripMediaScalarWhereInput[]
    OR?: TripMediaScalarWhereInput[]
    NOT?: TripMediaScalarWhereInput | TripMediaScalarWhereInput[]
    id?: StringFilter<"TripMedia"> | string
    tripId?: StringFilter<"TripMedia"> | string
    mediaType?: StringFilter<"TripMedia"> | string
    mediaUrl?: StringFilter<"TripMedia"> | string
    thumbnailUrl?: StringNullableFilter<"TripMedia"> | string | null
    caption?: StringNullableFilter<"TripMedia"> | string | null
    displayOrder?: IntNullableFilter<"TripMedia"> | number | null
    uploadedAt?: DateTimeFilter<"TripMedia"> | Date | string
    createdAt?: DateTimeFilter<"TripMedia"> | Date | string
    updatedAt?: DateTimeFilter<"TripMedia"> | Date | string
    deletedAt?: DateTimeNullableFilter<"TripMedia"> | Date | string | null
  }

  export type TripShareUpsertWithWhereUniqueWithoutTripInput = {
    where: TripShareWhereUniqueInput
    update: XOR<TripShareUpdateWithoutTripInput, TripShareUncheckedUpdateWithoutTripInput>
    create: XOR<TripShareCreateWithoutTripInput, TripShareUncheckedCreateWithoutTripInput>
  }

  export type TripShareUpdateWithWhereUniqueWithoutTripInput = {
    where: TripShareWhereUniqueInput
    data: XOR<TripShareUpdateWithoutTripInput, TripShareUncheckedUpdateWithoutTripInput>
  }

  export type TripShareUpdateManyWithWhereWithoutTripInput = {
    where: TripShareScalarWhereInput
    data: XOR<TripShareUpdateManyMutationInput, TripShareUncheckedUpdateManyWithoutTripInput>
  }

  export type TripShareScalarWhereInput = {
    AND?: TripShareScalarWhereInput | TripShareScalarWhereInput[]
    OR?: TripShareScalarWhereInput[]
    NOT?: TripShareScalarWhereInput | TripShareScalarWhereInput[]
    id?: StringFilter<"TripShare"> | string
    tripId?: StringFilter<"TripShare"> | string
    shareToken?: StringFilter<"TripShare"> | string
    shareType?: StringFilter<"TripShare"> | string
    sharedWithEmail?: StringNullableFilter<"TripShare"> | string | null
    viewCount?: IntFilter<"TripShare"> | number
    lastViewedAt?: DateTimeNullableFilter<"TripShare"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"TripShare"> | Date | string | null
    createdAt?: DateTimeFilter<"TripShare"> | Date | string
    updatedAt?: DateTimeFilter<"TripShare"> | Date | string
    deletedAt?: DateTimeNullableFilter<"TripShare"> | Date | string | null
  }

  export type TripVersionUpsertWithWhereUniqueWithoutTripInput = {
    where: TripVersionWhereUniqueInput
    update: XOR<TripVersionUpdateWithoutTripInput, TripVersionUncheckedUpdateWithoutTripInput>
    create: XOR<TripVersionCreateWithoutTripInput, TripVersionUncheckedCreateWithoutTripInput>
  }

  export type TripVersionUpdateWithWhereUniqueWithoutTripInput = {
    where: TripVersionWhereUniqueInput
    data: XOR<TripVersionUpdateWithoutTripInput, TripVersionUncheckedUpdateWithoutTripInput>
  }

  export type TripVersionUpdateManyWithWhereWithoutTripInput = {
    where: TripVersionScalarWhereInput
    data: XOR<TripVersionUpdateManyMutationInput, TripVersionUncheckedUpdateManyWithoutTripInput>
  }

  export type TripVersionScalarWhereInput = {
    AND?: TripVersionScalarWhereInput | TripVersionScalarWhereInput[]
    OR?: TripVersionScalarWhereInput[]
    NOT?: TripVersionScalarWhereInput | TripVersionScalarWhereInput[]
    id?: StringFilter<"TripVersion"> | string
    tripId?: StringFilter<"TripVersion"> | string
    versionNumber?: IntFilter<"TripVersion"> | number
    snapshotData?: StringFilter<"TripVersion"> | string
    changeSummary?: StringNullableFilter<"TripVersion"> | string | null
    createdBy?: StringFilter<"TripVersion"> | string
    createdAt?: DateTimeFilter<"TripVersion"> | Date | string
  }

  export type TripCreateWithoutStopsInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    coverPhotoUrl?: string | null
    status?: string
    isPublic?: boolean
    totalEstimatedCost?: number
    currency?: string
    travelStyle?: string | null
    versionNumber?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user: UserCreateNestedOneWithoutTripsInput
    budgets?: TripBudgetCreateNestedManyWithoutTripInput
    media?: TripMediaCreateNestedManyWithoutTripInput
    shares?: TripShareCreateNestedManyWithoutTripInput
    versions?: TripVersionCreateNestedManyWithoutTripInput
  }

  export type TripUncheckedCreateWithoutStopsInput = {
    id?: string
    userId: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    coverPhotoUrl?: string | null
    status?: string
    isPublic?: boolean
    totalEstimatedCost?: number
    currency?: string
    travelStyle?: string | null
    versionNumber?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    budgets?: TripBudgetUncheckedCreateNestedManyWithoutTripInput
    media?: TripMediaUncheckedCreateNestedManyWithoutTripInput
    shares?: TripShareUncheckedCreateNestedManyWithoutTripInput
    versions?: TripVersionUncheckedCreateNestedManyWithoutTripInput
  }

  export type TripCreateOrConnectWithoutStopsInput = {
    where: TripWhereUniqueInput
    create: XOR<TripCreateWithoutStopsInput, TripUncheckedCreateWithoutStopsInput>
  }

  export type CityCreateWithoutTripStopsInput = {
    id?: string
    name: string
    country: string
    countryCode: string
    region?: string | null
    latitude: number
    longitude: number
    timezone?: string
    costIndex?: number
    popularityScore?: number
    description?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    activities?: ActivityCreateNestedManyWithoutCityInput
    hotels?: HotelCreateNestedManyWithoutCityInput
    restaurants?: RestaurantCreateNestedManyWithoutCityInput
    transportFrom?: TransportCreateNestedManyWithoutFromCityInput
    transportTo?: TransportCreateNestedManyWithoutToCityInput
    savedDestinations?: UserSavedDestinationCreateNestedManyWithoutCityInput
  }

  export type CityUncheckedCreateWithoutTripStopsInput = {
    id?: string
    name: string
    country: string
    countryCode: string
    region?: string | null
    latitude: number
    longitude: number
    timezone?: string
    costIndex?: number
    popularityScore?: number
    description?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    activities?: ActivityUncheckedCreateNestedManyWithoutCityInput
    hotels?: HotelUncheckedCreateNestedManyWithoutCityInput
    restaurants?: RestaurantUncheckedCreateNestedManyWithoutCityInput
    transportFrom?: TransportUncheckedCreateNestedManyWithoutFromCityInput
    transportTo?: TransportUncheckedCreateNestedManyWithoutToCityInput
    savedDestinations?: UserSavedDestinationUncheckedCreateNestedManyWithoutCityInput
  }

  export type CityCreateOrConnectWithoutTripStopsInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutTripStopsInput, CityUncheckedCreateWithoutTripStopsInput>
  }

  export type StopActivityCreateWithoutTripStopInput = {
    id?: string
    scheduledDate: Date | string
    scheduledTime?: string | null
    actualCost?: number | null
    notes?: string | null
    isCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    activity: ActivityCreateNestedOneWithoutStopActivitiesInput
  }

  export type StopActivityUncheckedCreateWithoutTripStopInput = {
    id?: string
    activityId: string
    scheduledDate: Date | string
    scheduledTime?: string | null
    actualCost?: number | null
    notes?: string | null
    isCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type StopActivityCreateOrConnectWithoutTripStopInput = {
    where: StopActivityWhereUniqueInput
    create: XOR<StopActivityCreateWithoutTripStopInput, StopActivityUncheckedCreateWithoutTripStopInput>
  }

  export type StopActivityCreateManyTripStopInputEnvelope = {
    data: StopActivityCreateManyTripStopInput | StopActivityCreateManyTripStopInput[]
  }

  export type TripUpsertWithoutStopsInput = {
    update: XOR<TripUpdateWithoutStopsInput, TripUncheckedUpdateWithoutStopsInput>
    create: XOR<TripCreateWithoutStopsInput, TripUncheckedCreateWithoutStopsInput>
    where?: TripWhereInput
  }

  export type TripUpdateToOneWithWhereWithoutStopsInput = {
    where?: TripWhereInput
    data: XOR<TripUpdateWithoutStopsInput, TripUncheckedUpdateWithoutStopsInput>
  }

  export type TripUpdateWithoutStopsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    coverPhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    totalEstimatedCost?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    travelStyle?: NullableStringFieldUpdateOperationsInput | string | null
    versionNumber?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutTripsNestedInput
    budgets?: TripBudgetUpdateManyWithoutTripNestedInput
    media?: TripMediaUpdateManyWithoutTripNestedInput
    shares?: TripShareUpdateManyWithoutTripNestedInput
    versions?: TripVersionUpdateManyWithoutTripNestedInput
  }

  export type TripUncheckedUpdateWithoutStopsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    coverPhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    totalEstimatedCost?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    travelStyle?: NullableStringFieldUpdateOperationsInput | string | null
    versionNumber?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    budgets?: TripBudgetUncheckedUpdateManyWithoutTripNestedInput
    media?: TripMediaUncheckedUpdateManyWithoutTripNestedInput
    shares?: TripShareUncheckedUpdateManyWithoutTripNestedInput
    versions?: TripVersionUncheckedUpdateManyWithoutTripNestedInput
  }

  export type CityUpsertWithoutTripStopsInput = {
    update: XOR<CityUpdateWithoutTripStopsInput, CityUncheckedUpdateWithoutTripStopsInput>
    create: XOR<CityCreateWithoutTripStopsInput, CityUncheckedCreateWithoutTripStopsInput>
    where?: CityWhereInput
  }

  export type CityUpdateToOneWithWhereWithoutTripStopsInput = {
    where?: CityWhereInput
    data: XOR<CityUpdateWithoutTripStopsInput, CityUncheckedUpdateWithoutTripStopsInput>
  }

  export type CityUpdateWithoutTripStopsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    costIndex?: FloatFieldUpdateOperationsInput | number
    popularityScore?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activities?: ActivityUpdateManyWithoutCityNestedInput
    hotels?: HotelUpdateManyWithoutCityNestedInput
    restaurants?: RestaurantUpdateManyWithoutCityNestedInput
    transportFrom?: TransportUpdateManyWithoutFromCityNestedInput
    transportTo?: TransportUpdateManyWithoutToCityNestedInput
    savedDestinations?: UserSavedDestinationUpdateManyWithoutCityNestedInput
  }

  export type CityUncheckedUpdateWithoutTripStopsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    costIndex?: FloatFieldUpdateOperationsInput | number
    popularityScore?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activities?: ActivityUncheckedUpdateManyWithoutCityNestedInput
    hotels?: HotelUncheckedUpdateManyWithoutCityNestedInput
    restaurants?: RestaurantUncheckedUpdateManyWithoutCityNestedInput
    transportFrom?: TransportUncheckedUpdateManyWithoutFromCityNestedInput
    transportTo?: TransportUncheckedUpdateManyWithoutToCityNestedInput
    savedDestinations?: UserSavedDestinationUncheckedUpdateManyWithoutCityNestedInput
  }

  export type StopActivityUpsertWithWhereUniqueWithoutTripStopInput = {
    where: StopActivityWhereUniqueInput
    update: XOR<StopActivityUpdateWithoutTripStopInput, StopActivityUncheckedUpdateWithoutTripStopInput>
    create: XOR<StopActivityCreateWithoutTripStopInput, StopActivityUncheckedCreateWithoutTripStopInput>
  }

  export type StopActivityUpdateWithWhereUniqueWithoutTripStopInput = {
    where: StopActivityWhereUniqueInput
    data: XOR<StopActivityUpdateWithoutTripStopInput, StopActivityUncheckedUpdateWithoutTripStopInput>
  }

  export type StopActivityUpdateManyWithWhereWithoutTripStopInput = {
    where: StopActivityScalarWhereInput
    data: XOR<StopActivityUpdateManyMutationInput, StopActivityUncheckedUpdateManyWithoutTripStopInput>
  }

  export type TripStopCreateWithoutActivitiesInput = {
    id?: string
    stopOrder: number
    arrivalDate: Date | string
    departureDate: Date | string
    accommodationName?: string | null
    accommodationCost?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    trip: TripCreateNestedOneWithoutStopsInput
    city: CityCreateNestedOneWithoutTripStopsInput
  }

  export type TripStopUncheckedCreateWithoutActivitiesInput = {
    id?: string
    tripId: string
    cityId: string
    stopOrder: number
    arrivalDate: Date | string
    departureDate: Date | string
    accommodationName?: string | null
    accommodationCost?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type TripStopCreateOrConnectWithoutActivitiesInput = {
    where: TripStopWhereUniqueInput
    create: XOR<TripStopCreateWithoutActivitiesInput, TripStopUncheckedCreateWithoutActivitiesInput>
  }

  export type ActivityCreateWithoutStopActivitiesInput = {
    id?: string
    name: string
    category: string
    description?: string | null
    estimatedCost?: number
    currency?: string
    durationMinutes?: number | null
    imageUrl?: string | null
    rating?: number | null
    popularityScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    city: CityCreateNestedOneWithoutActivitiesInput
  }

  export type ActivityUncheckedCreateWithoutStopActivitiesInput = {
    id?: string
    cityId: string
    name: string
    category: string
    description?: string | null
    estimatedCost?: number
    currency?: string
    durationMinutes?: number | null
    imageUrl?: string | null
    rating?: number | null
    popularityScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ActivityCreateOrConnectWithoutStopActivitiesInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutStopActivitiesInput, ActivityUncheckedCreateWithoutStopActivitiesInput>
  }

  export type TripStopUpsertWithoutActivitiesInput = {
    update: XOR<TripStopUpdateWithoutActivitiesInput, TripStopUncheckedUpdateWithoutActivitiesInput>
    create: XOR<TripStopCreateWithoutActivitiesInput, TripStopUncheckedCreateWithoutActivitiesInput>
    where?: TripStopWhereInput
  }

  export type TripStopUpdateToOneWithWhereWithoutActivitiesInput = {
    where?: TripStopWhereInput
    data: XOR<TripStopUpdateWithoutActivitiesInput, TripStopUncheckedUpdateWithoutActivitiesInput>
  }

  export type TripStopUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    stopOrder?: IntFieldUpdateOperationsInput | number
    arrivalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    departureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accommodationName?: NullableStringFieldUpdateOperationsInput | string | null
    accommodationCost?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trip?: TripUpdateOneRequiredWithoutStopsNestedInput
    city?: CityUpdateOneRequiredWithoutTripStopsNestedInput
  }

  export type TripStopUncheckedUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripId?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    stopOrder?: IntFieldUpdateOperationsInput | number
    arrivalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    departureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accommodationName?: NullableStringFieldUpdateOperationsInput | string | null
    accommodationCost?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ActivityUpsertWithoutStopActivitiesInput = {
    update: XOR<ActivityUpdateWithoutStopActivitiesInput, ActivityUncheckedUpdateWithoutStopActivitiesInput>
    create: XOR<ActivityCreateWithoutStopActivitiesInput, ActivityUncheckedCreateWithoutStopActivitiesInput>
    where?: ActivityWhereInput
  }

  export type ActivityUpdateToOneWithWhereWithoutStopActivitiesInput = {
    where?: ActivityWhereInput
    data: XOR<ActivityUpdateWithoutStopActivitiesInput, ActivityUncheckedUpdateWithoutStopActivitiesInput>
  }

  export type ActivityUpdateWithoutStopActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCost?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    popularityScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    city?: CityUpdateOneRequiredWithoutActivitiesNestedInput
  }

  export type ActivityUncheckedUpdateWithoutStopActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCost?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    popularityScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TripCreateWithoutBudgetsInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    coverPhotoUrl?: string | null
    status?: string
    isPublic?: boolean
    totalEstimatedCost?: number
    currency?: string
    travelStyle?: string | null
    versionNumber?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user: UserCreateNestedOneWithoutTripsInput
    stops?: TripStopCreateNestedManyWithoutTripInput
    media?: TripMediaCreateNestedManyWithoutTripInput
    shares?: TripShareCreateNestedManyWithoutTripInput
    versions?: TripVersionCreateNestedManyWithoutTripInput
  }

  export type TripUncheckedCreateWithoutBudgetsInput = {
    id?: string
    userId: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    coverPhotoUrl?: string | null
    status?: string
    isPublic?: boolean
    totalEstimatedCost?: number
    currency?: string
    travelStyle?: string | null
    versionNumber?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    stops?: TripStopUncheckedCreateNestedManyWithoutTripInput
    media?: TripMediaUncheckedCreateNestedManyWithoutTripInput
    shares?: TripShareUncheckedCreateNestedManyWithoutTripInput
    versions?: TripVersionUncheckedCreateNestedManyWithoutTripInput
  }

  export type TripCreateOrConnectWithoutBudgetsInput = {
    where: TripWhereUniqueInput
    create: XOR<TripCreateWithoutBudgetsInput, TripUncheckedCreateWithoutBudgetsInput>
  }

  export type TripUpsertWithoutBudgetsInput = {
    update: XOR<TripUpdateWithoutBudgetsInput, TripUncheckedUpdateWithoutBudgetsInput>
    create: XOR<TripCreateWithoutBudgetsInput, TripUncheckedCreateWithoutBudgetsInput>
    where?: TripWhereInput
  }

  export type TripUpdateToOneWithWhereWithoutBudgetsInput = {
    where?: TripWhereInput
    data: XOR<TripUpdateWithoutBudgetsInput, TripUncheckedUpdateWithoutBudgetsInput>
  }

  export type TripUpdateWithoutBudgetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    coverPhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    totalEstimatedCost?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    travelStyle?: NullableStringFieldUpdateOperationsInput | string | null
    versionNumber?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutTripsNestedInput
    stops?: TripStopUpdateManyWithoutTripNestedInput
    media?: TripMediaUpdateManyWithoutTripNestedInput
    shares?: TripShareUpdateManyWithoutTripNestedInput
    versions?: TripVersionUpdateManyWithoutTripNestedInput
  }

  export type TripUncheckedUpdateWithoutBudgetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    coverPhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    totalEstimatedCost?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    travelStyle?: NullableStringFieldUpdateOperationsInput | string | null
    versionNumber?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stops?: TripStopUncheckedUpdateManyWithoutTripNestedInput
    media?: TripMediaUncheckedUpdateManyWithoutTripNestedInput
    shares?: TripShareUncheckedUpdateManyWithoutTripNestedInput
    versions?: TripVersionUncheckedUpdateManyWithoutTripNestedInput
  }

  export type TripCreateWithoutMediaInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    coverPhotoUrl?: string | null
    status?: string
    isPublic?: boolean
    totalEstimatedCost?: number
    currency?: string
    travelStyle?: string | null
    versionNumber?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user: UserCreateNestedOneWithoutTripsInput
    stops?: TripStopCreateNestedManyWithoutTripInput
    budgets?: TripBudgetCreateNestedManyWithoutTripInput
    shares?: TripShareCreateNestedManyWithoutTripInput
    versions?: TripVersionCreateNestedManyWithoutTripInput
  }

  export type TripUncheckedCreateWithoutMediaInput = {
    id?: string
    userId: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    coverPhotoUrl?: string | null
    status?: string
    isPublic?: boolean
    totalEstimatedCost?: number
    currency?: string
    travelStyle?: string | null
    versionNumber?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    stops?: TripStopUncheckedCreateNestedManyWithoutTripInput
    budgets?: TripBudgetUncheckedCreateNestedManyWithoutTripInput
    shares?: TripShareUncheckedCreateNestedManyWithoutTripInput
    versions?: TripVersionUncheckedCreateNestedManyWithoutTripInput
  }

  export type TripCreateOrConnectWithoutMediaInput = {
    where: TripWhereUniqueInput
    create: XOR<TripCreateWithoutMediaInput, TripUncheckedCreateWithoutMediaInput>
  }

  export type TripUpsertWithoutMediaInput = {
    update: XOR<TripUpdateWithoutMediaInput, TripUncheckedUpdateWithoutMediaInput>
    create: XOR<TripCreateWithoutMediaInput, TripUncheckedCreateWithoutMediaInput>
    where?: TripWhereInput
  }

  export type TripUpdateToOneWithWhereWithoutMediaInput = {
    where?: TripWhereInput
    data: XOR<TripUpdateWithoutMediaInput, TripUncheckedUpdateWithoutMediaInput>
  }

  export type TripUpdateWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    coverPhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    totalEstimatedCost?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    travelStyle?: NullableStringFieldUpdateOperationsInput | string | null
    versionNumber?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutTripsNestedInput
    stops?: TripStopUpdateManyWithoutTripNestedInput
    budgets?: TripBudgetUpdateManyWithoutTripNestedInput
    shares?: TripShareUpdateManyWithoutTripNestedInput
    versions?: TripVersionUpdateManyWithoutTripNestedInput
  }

  export type TripUncheckedUpdateWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    coverPhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    totalEstimatedCost?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    travelStyle?: NullableStringFieldUpdateOperationsInput | string | null
    versionNumber?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stops?: TripStopUncheckedUpdateManyWithoutTripNestedInput
    budgets?: TripBudgetUncheckedUpdateManyWithoutTripNestedInput
    shares?: TripShareUncheckedUpdateManyWithoutTripNestedInput
    versions?: TripVersionUncheckedUpdateManyWithoutTripNestedInput
  }

  export type TripCreateWithoutSharesInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    coverPhotoUrl?: string | null
    status?: string
    isPublic?: boolean
    totalEstimatedCost?: number
    currency?: string
    travelStyle?: string | null
    versionNumber?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user: UserCreateNestedOneWithoutTripsInput
    stops?: TripStopCreateNestedManyWithoutTripInput
    budgets?: TripBudgetCreateNestedManyWithoutTripInput
    media?: TripMediaCreateNestedManyWithoutTripInput
    versions?: TripVersionCreateNestedManyWithoutTripInput
  }

  export type TripUncheckedCreateWithoutSharesInput = {
    id?: string
    userId: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    coverPhotoUrl?: string | null
    status?: string
    isPublic?: boolean
    totalEstimatedCost?: number
    currency?: string
    travelStyle?: string | null
    versionNumber?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    stops?: TripStopUncheckedCreateNestedManyWithoutTripInput
    budgets?: TripBudgetUncheckedCreateNestedManyWithoutTripInput
    media?: TripMediaUncheckedCreateNestedManyWithoutTripInput
    versions?: TripVersionUncheckedCreateNestedManyWithoutTripInput
  }

  export type TripCreateOrConnectWithoutSharesInput = {
    where: TripWhereUniqueInput
    create: XOR<TripCreateWithoutSharesInput, TripUncheckedCreateWithoutSharesInput>
  }

  export type TripUpsertWithoutSharesInput = {
    update: XOR<TripUpdateWithoutSharesInput, TripUncheckedUpdateWithoutSharesInput>
    create: XOR<TripCreateWithoutSharesInput, TripUncheckedCreateWithoutSharesInput>
    where?: TripWhereInput
  }

  export type TripUpdateToOneWithWhereWithoutSharesInput = {
    where?: TripWhereInput
    data: XOR<TripUpdateWithoutSharesInput, TripUncheckedUpdateWithoutSharesInput>
  }

  export type TripUpdateWithoutSharesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    coverPhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    totalEstimatedCost?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    travelStyle?: NullableStringFieldUpdateOperationsInput | string | null
    versionNumber?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutTripsNestedInput
    stops?: TripStopUpdateManyWithoutTripNestedInput
    budgets?: TripBudgetUpdateManyWithoutTripNestedInput
    media?: TripMediaUpdateManyWithoutTripNestedInput
    versions?: TripVersionUpdateManyWithoutTripNestedInput
  }

  export type TripUncheckedUpdateWithoutSharesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    coverPhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    totalEstimatedCost?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    travelStyle?: NullableStringFieldUpdateOperationsInput | string | null
    versionNumber?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stops?: TripStopUncheckedUpdateManyWithoutTripNestedInput
    budgets?: TripBudgetUncheckedUpdateManyWithoutTripNestedInput
    media?: TripMediaUncheckedUpdateManyWithoutTripNestedInput
    versions?: TripVersionUncheckedUpdateManyWithoutTripNestedInput
  }

  export type TripCreateWithoutVersionsInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    coverPhotoUrl?: string | null
    status?: string
    isPublic?: boolean
    totalEstimatedCost?: number
    currency?: string
    travelStyle?: string | null
    versionNumber?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user: UserCreateNestedOneWithoutTripsInput
    stops?: TripStopCreateNestedManyWithoutTripInput
    budgets?: TripBudgetCreateNestedManyWithoutTripInput
    media?: TripMediaCreateNestedManyWithoutTripInput
    shares?: TripShareCreateNestedManyWithoutTripInput
  }

  export type TripUncheckedCreateWithoutVersionsInput = {
    id?: string
    userId: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    coverPhotoUrl?: string | null
    status?: string
    isPublic?: boolean
    totalEstimatedCost?: number
    currency?: string
    travelStyle?: string | null
    versionNumber?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    stops?: TripStopUncheckedCreateNestedManyWithoutTripInput
    budgets?: TripBudgetUncheckedCreateNestedManyWithoutTripInput
    media?: TripMediaUncheckedCreateNestedManyWithoutTripInput
    shares?: TripShareUncheckedCreateNestedManyWithoutTripInput
  }

  export type TripCreateOrConnectWithoutVersionsInput = {
    where: TripWhereUniqueInput
    create: XOR<TripCreateWithoutVersionsInput, TripUncheckedCreateWithoutVersionsInput>
  }

  export type TripUpsertWithoutVersionsInput = {
    update: XOR<TripUpdateWithoutVersionsInput, TripUncheckedUpdateWithoutVersionsInput>
    create: XOR<TripCreateWithoutVersionsInput, TripUncheckedCreateWithoutVersionsInput>
    where?: TripWhereInput
  }

  export type TripUpdateToOneWithWhereWithoutVersionsInput = {
    where?: TripWhereInput
    data: XOR<TripUpdateWithoutVersionsInput, TripUncheckedUpdateWithoutVersionsInput>
  }

  export type TripUpdateWithoutVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    coverPhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    totalEstimatedCost?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    travelStyle?: NullableStringFieldUpdateOperationsInput | string | null
    versionNumber?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutTripsNestedInput
    stops?: TripStopUpdateManyWithoutTripNestedInput
    budgets?: TripBudgetUpdateManyWithoutTripNestedInput
    media?: TripMediaUpdateManyWithoutTripNestedInput
    shares?: TripShareUpdateManyWithoutTripNestedInput
  }

  export type TripUncheckedUpdateWithoutVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    coverPhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    totalEstimatedCost?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    travelStyle?: NullableStringFieldUpdateOperationsInput | string | null
    versionNumber?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stops?: TripStopUncheckedUpdateManyWithoutTripNestedInput
    budgets?: TripBudgetUncheckedUpdateManyWithoutTripNestedInput
    media?: TripMediaUncheckedUpdateManyWithoutTripNestedInput
    shares?: TripShareUncheckedUpdateManyWithoutTripNestedInput
  }

  export type UserCreateWithoutSavedDestinationsInput = {
    id?: string
    email: string
    passwordHash: string
    fullName: string
    profilePhotoUrl?: string | null
    preferredLanguage?: string
    preferredCurrency?: string
    emailVerified?: boolean
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    trips?: TripCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSavedDestinationsInput = {
    id?: string
    email: string
    passwordHash: string
    fullName: string
    profilePhotoUrl?: string | null
    preferredLanguage?: string
    preferredCurrency?: string
    emailVerified?: boolean
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    trips?: TripUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSavedDestinationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSavedDestinationsInput, UserUncheckedCreateWithoutSavedDestinationsInput>
  }

  export type CityCreateWithoutSavedDestinationsInput = {
    id?: string
    name: string
    country: string
    countryCode: string
    region?: string | null
    latitude: number
    longitude: number
    timezone?: string
    costIndex?: number
    popularityScore?: number
    description?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    activities?: ActivityCreateNestedManyWithoutCityInput
    hotels?: HotelCreateNestedManyWithoutCityInput
    restaurants?: RestaurantCreateNestedManyWithoutCityInput
    transportFrom?: TransportCreateNestedManyWithoutFromCityInput
    transportTo?: TransportCreateNestedManyWithoutToCityInput
    tripStops?: TripStopCreateNestedManyWithoutCityInput
  }

  export type CityUncheckedCreateWithoutSavedDestinationsInput = {
    id?: string
    name: string
    country: string
    countryCode: string
    region?: string | null
    latitude: number
    longitude: number
    timezone?: string
    costIndex?: number
    popularityScore?: number
    description?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    activities?: ActivityUncheckedCreateNestedManyWithoutCityInput
    hotels?: HotelUncheckedCreateNestedManyWithoutCityInput
    restaurants?: RestaurantUncheckedCreateNestedManyWithoutCityInput
    transportFrom?: TransportUncheckedCreateNestedManyWithoutFromCityInput
    transportTo?: TransportUncheckedCreateNestedManyWithoutToCityInput
    tripStops?: TripStopUncheckedCreateNestedManyWithoutCityInput
  }

  export type CityCreateOrConnectWithoutSavedDestinationsInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutSavedDestinationsInput, CityUncheckedCreateWithoutSavedDestinationsInput>
  }

  export type UserUpsertWithoutSavedDestinationsInput = {
    update: XOR<UserUpdateWithoutSavedDestinationsInput, UserUncheckedUpdateWithoutSavedDestinationsInput>
    create: XOR<UserCreateWithoutSavedDestinationsInput, UserUncheckedCreateWithoutSavedDestinationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSavedDestinationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSavedDestinationsInput, UserUncheckedUpdateWithoutSavedDestinationsInput>
  }

  export type UserUpdateWithoutSavedDestinationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    preferredCurrency?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trips?: TripUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSavedDestinationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    preferredCurrency?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trips?: TripUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CityUpsertWithoutSavedDestinationsInput = {
    update: XOR<CityUpdateWithoutSavedDestinationsInput, CityUncheckedUpdateWithoutSavedDestinationsInput>
    create: XOR<CityCreateWithoutSavedDestinationsInput, CityUncheckedCreateWithoutSavedDestinationsInput>
    where?: CityWhereInput
  }

  export type CityUpdateToOneWithWhereWithoutSavedDestinationsInput = {
    where?: CityWhereInput
    data: XOR<CityUpdateWithoutSavedDestinationsInput, CityUncheckedUpdateWithoutSavedDestinationsInput>
  }

  export type CityUpdateWithoutSavedDestinationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    costIndex?: FloatFieldUpdateOperationsInput | number
    popularityScore?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activities?: ActivityUpdateManyWithoutCityNestedInput
    hotels?: HotelUpdateManyWithoutCityNestedInput
    restaurants?: RestaurantUpdateManyWithoutCityNestedInput
    transportFrom?: TransportUpdateManyWithoutFromCityNestedInput
    transportTo?: TransportUpdateManyWithoutToCityNestedInput
    tripStops?: TripStopUpdateManyWithoutCityNestedInput
  }

  export type CityUncheckedUpdateWithoutSavedDestinationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    costIndex?: FloatFieldUpdateOperationsInput | number
    popularityScore?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activities?: ActivityUncheckedUpdateManyWithoutCityNestedInput
    hotels?: HotelUncheckedUpdateManyWithoutCityNestedInput
    restaurants?: RestaurantUncheckedUpdateManyWithoutCityNestedInput
    transportFrom?: TransportUncheckedUpdateManyWithoutFromCityNestedInput
    transportTo?: TransportUncheckedUpdateManyWithoutToCityNestedInput
    tripStops?: TripStopUncheckedUpdateManyWithoutCityNestedInput
  }

  export type UserCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    passwordHash: string
    fullName: string
    profilePhotoUrl?: string | null
    preferredLanguage?: string
    preferredCurrency?: string
    emailVerified?: boolean
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    trips?: TripCreateNestedManyWithoutUserInput
    savedDestinations?: UserSavedDestinationCreateNestedManyWithoutUserInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    passwordHash: string
    fullName: string
    profilePhotoUrl?: string | null
    preferredLanguage?: string
    preferredCurrency?: string
    emailVerified?: boolean
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    trips?: TripUncheckedCreateNestedManyWithoutUserInput
    savedDestinations?: UserSavedDestinationUncheckedCreateNestedManyWithoutUserInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    preferredCurrency?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trips?: TripUpdateManyWithoutUserNestedInput
    savedDestinations?: UserSavedDestinationUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    preferredCurrency?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trips?: TripUncheckedUpdateManyWithoutUserNestedInput
    savedDestinations?: UserSavedDestinationUncheckedUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TripCreateManyUserInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    coverPhotoUrl?: string | null
    status?: string
    isPublic?: boolean
    totalEstimatedCost?: number
    currency?: string
    travelStyle?: string | null
    versionNumber?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type UserSavedDestinationCreateManyUserInput = {
    id?: string
    cityId: string
    notes?: string | null
    savedAt?: Date | string
  }

  export type AuditLogCreateManyUserInput = {
    id?: string
    action: string
    entityType: string
    entityId: string
    changes?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type UserRoleCreateManyUserInput = {
    id?: string
    roleId: string
    assignedAt?: Date | string
  }

  export type TripUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    coverPhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    totalEstimatedCost?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    travelStyle?: NullableStringFieldUpdateOperationsInput | string | null
    versionNumber?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stops?: TripStopUpdateManyWithoutTripNestedInput
    budgets?: TripBudgetUpdateManyWithoutTripNestedInput
    media?: TripMediaUpdateManyWithoutTripNestedInput
    shares?: TripShareUpdateManyWithoutTripNestedInput
    versions?: TripVersionUpdateManyWithoutTripNestedInput
  }

  export type TripUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    coverPhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    totalEstimatedCost?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    travelStyle?: NullableStringFieldUpdateOperationsInput | string | null
    versionNumber?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stops?: TripStopUncheckedUpdateManyWithoutTripNestedInput
    budgets?: TripBudgetUncheckedUpdateManyWithoutTripNestedInput
    media?: TripMediaUncheckedUpdateManyWithoutTripNestedInput
    shares?: TripShareUncheckedUpdateManyWithoutTripNestedInput
    versions?: TripVersionUncheckedUpdateManyWithoutTripNestedInput
  }

  export type TripUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    coverPhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    totalEstimatedCost?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    travelStyle?: NullableStringFieldUpdateOperationsInput | string | null
    versionNumber?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserSavedDestinationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    savedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: CityUpdateOneRequiredWithoutSavedDestinationsNestedInput
  }

  export type UserSavedDestinationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    savedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSavedDestinationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    savedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    changes?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    changes?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    changes?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUserRolesNestedInput
  }

  export type UserRoleUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleCreateManyRoleInput = {
    id?: string
    userId: string
    assignedAt?: Date | string
  }

  export type UserRoleUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserRolesNestedInput
  }

  export type UserRoleUncheckedUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleUncheckedUpdateManyWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityCreateManyCityInput = {
    id?: string
    name: string
    category: string
    description?: string | null
    estimatedCost?: number
    currency?: string
    durationMinutes?: number | null
    imageUrl?: string | null
    rating?: number | null
    popularityScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type HotelCreateManyCityInput = {
    id?: string
    name: string
    category: string
    description?: string | null
    pricePerNight: number
    currency?: string
    rating?: number | null
    amenities?: string | null
    address?: string | null
    imageUrl?: string | null
    contactPhone?: string | null
    website?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type RestaurantCreateManyCityInput = {
    id?: string
    name: string
    cuisineType: string
    priceRange: string
    avgMealCost: number
    currency?: string
    rating?: number | null
    description?: string | null
    address?: string | null
    imageUrl?: string | null
    isVegetarian?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type TransportCreateManyFromCityInput = {
    id?: string
    toCityId: string
    transportType: string
    operatorName: string
    departureTime: string
    arrivalTime: string
    durationMinutes: number
    price: number
    currency?: string
    classType?: string | null
    frequency?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type TransportCreateManyToCityInput = {
    id?: string
    fromCityId: string
    transportType: string
    operatorName: string
    departureTime: string
    arrivalTime: string
    durationMinutes: number
    price: number
    currency?: string
    classType?: string | null
    frequency?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type TripStopCreateManyCityInput = {
    id?: string
    tripId: string
    stopOrder: number
    arrivalDate: Date | string
    departureDate: Date | string
    accommodationName?: string | null
    accommodationCost?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type UserSavedDestinationCreateManyCityInput = {
    id?: string
    userId: string
    notes?: string | null
    savedAt?: Date | string
  }

  export type ActivityUpdateWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCost?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    popularityScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stopActivities?: StopActivityUpdateManyWithoutActivityNestedInput
  }

  export type ActivityUncheckedUpdateWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCost?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    popularityScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stopActivities?: StopActivityUncheckedUpdateManyWithoutActivityNestedInput
  }

  export type ActivityUncheckedUpdateManyWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCost?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    popularityScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type HotelUpdateWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pricePerNight?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    amenities?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type HotelUncheckedUpdateWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pricePerNight?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    amenities?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type HotelUncheckedUpdateManyWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pricePerNight?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    amenities?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RestaurantUpdateWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cuisineType?: StringFieldUpdateOperationsInput | string
    priceRange?: StringFieldUpdateOperationsInput | string
    avgMealCost?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isVegetarian?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RestaurantUncheckedUpdateWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cuisineType?: StringFieldUpdateOperationsInput | string
    priceRange?: StringFieldUpdateOperationsInput | string
    avgMealCost?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isVegetarian?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RestaurantUncheckedUpdateManyWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cuisineType?: StringFieldUpdateOperationsInput | string
    priceRange?: StringFieldUpdateOperationsInput | string
    avgMealCost?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isVegetarian?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransportUpdateWithoutFromCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    transportType?: StringFieldUpdateOperationsInput | string
    operatorName?: StringFieldUpdateOperationsInput | string
    departureTime?: StringFieldUpdateOperationsInput | string
    arrivalTime?: StringFieldUpdateOperationsInput | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    classType?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    toCity?: CityUpdateOneRequiredWithoutTransportToNestedInput
  }

  export type TransportUncheckedUpdateWithoutFromCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    toCityId?: StringFieldUpdateOperationsInput | string
    transportType?: StringFieldUpdateOperationsInput | string
    operatorName?: StringFieldUpdateOperationsInput | string
    departureTime?: StringFieldUpdateOperationsInput | string
    arrivalTime?: StringFieldUpdateOperationsInput | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    classType?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransportUncheckedUpdateManyWithoutFromCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    toCityId?: StringFieldUpdateOperationsInput | string
    transportType?: StringFieldUpdateOperationsInput | string
    operatorName?: StringFieldUpdateOperationsInput | string
    departureTime?: StringFieldUpdateOperationsInput | string
    arrivalTime?: StringFieldUpdateOperationsInput | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    classType?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransportUpdateWithoutToCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    transportType?: StringFieldUpdateOperationsInput | string
    operatorName?: StringFieldUpdateOperationsInput | string
    departureTime?: StringFieldUpdateOperationsInput | string
    arrivalTime?: StringFieldUpdateOperationsInput | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    classType?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fromCity?: CityUpdateOneRequiredWithoutTransportFromNestedInput
  }

  export type TransportUncheckedUpdateWithoutToCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromCityId?: StringFieldUpdateOperationsInput | string
    transportType?: StringFieldUpdateOperationsInput | string
    operatorName?: StringFieldUpdateOperationsInput | string
    departureTime?: StringFieldUpdateOperationsInput | string
    arrivalTime?: StringFieldUpdateOperationsInput | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    classType?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransportUncheckedUpdateManyWithoutToCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromCityId?: StringFieldUpdateOperationsInput | string
    transportType?: StringFieldUpdateOperationsInput | string
    operatorName?: StringFieldUpdateOperationsInput | string
    departureTime?: StringFieldUpdateOperationsInput | string
    arrivalTime?: StringFieldUpdateOperationsInput | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    classType?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TripStopUpdateWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    stopOrder?: IntFieldUpdateOperationsInput | number
    arrivalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    departureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accommodationName?: NullableStringFieldUpdateOperationsInput | string | null
    accommodationCost?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trip?: TripUpdateOneRequiredWithoutStopsNestedInput
    activities?: StopActivityUpdateManyWithoutTripStopNestedInput
  }

  export type TripStopUncheckedUpdateWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripId?: StringFieldUpdateOperationsInput | string
    stopOrder?: IntFieldUpdateOperationsInput | number
    arrivalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    departureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accommodationName?: NullableStringFieldUpdateOperationsInput | string | null
    accommodationCost?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activities?: StopActivityUncheckedUpdateManyWithoutTripStopNestedInput
  }

  export type TripStopUncheckedUpdateManyWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripId?: StringFieldUpdateOperationsInput | string
    stopOrder?: IntFieldUpdateOperationsInput | number
    arrivalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    departureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accommodationName?: NullableStringFieldUpdateOperationsInput | string | null
    accommodationCost?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserSavedDestinationUpdateWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    savedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSavedDestinationsNestedInput
  }

  export type UserSavedDestinationUncheckedUpdateWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    savedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSavedDestinationUncheckedUpdateManyWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    savedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StopActivityCreateManyActivityInput = {
    id?: string
    tripStopId: string
    scheduledDate: Date | string
    scheduledTime?: string | null
    actualCost?: number | null
    notes?: string | null
    isCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type StopActivityUpdateWithoutActivityInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledTime?: NullableStringFieldUpdateOperationsInput | string | null
    actualCost?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tripStop?: TripStopUpdateOneRequiredWithoutActivitiesNestedInput
  }

  export type StopActivityUncheckedUpdateWithoutActivityInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripStopId?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledTime?: NullableStringFieldUpdateOperationsInput | string | null
    actualCost?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StopActivityUncheckedUpdateManyWithoutActivityInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripStopId?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledTime?: NullableStringFieldUpdateOperationsInput | string | null
    actualCost?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TripStopCreateManyTripInput = {
    id?: string
    cityId: string
    stopOrder: number
    arrivalDate: Date | string
    departureDate: Date | string
    accommodationName?: string | null
    accommodationCost?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type TripBudgetCreateManyTripInput = {
    id?: string
    category: string
    estimatedAmount?: number
    actualAmount?: number | null
    currency?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type TripMediaCreateManyTripInput = {
    id?: string
    mediaType: string
    mediaUrl: string
    thumbnailUrl?: string | null
    caption?: string | null
    displayOrder?: number | null
    uploadedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type TripShareCreateManyTripInput = {
    id?: string
    shareToken: string
    shareType?: string
    sharedWithEmail?: string | null
    viewCount?: number
    lastViewedAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type TripVersionCreateManyTripInput = {
    id?: string
    versionNumber: number
    snapshotData: string
    changeSummary?: string | null
    createdBy: string
    createdAt?: Date | string
  }

  export type TripStopUpdateWithoutTripInput = {
    id?: StringFieldUpdateOperationsInput | string
    stopOrder?: IntFieldUpdateOperationsInput | number
    arrivalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    departureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accommodationName?: NullableStringFieldUpdateOperationsInput | string | null
    accommodationCost?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    city?: CityUpdateOneRequiredWithoutTripStopsNestedInput
    activities?: StopActivityUpdateManyWithoutTripStopNestedInput
  }

  export type TripStopUncheckedUpdateWithoutTripInput = {
    id?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    stopOrder?: IntFieldUpdateOperationsInput | number
    arrivalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    departureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accommodationName?: NullableStringFieldUpdateOperationsInput | string | null
    accommodationCost?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activities?: StopActivityUncheckedUpdateManyWithoutTripStopNestedInput
  }

  export type TripStopUncheckedUpdateManyWithoutTripInput = {
    id?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    stopOrder?: IntFieldUpdateOperationsInput | number
    arrivalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    departureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accommodationName?: NullableStringFieldUpdateOperationsInput | string | null
    accommodationCost?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TripBudgetUpdateWithoutTripInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    estimatedAmount?: FloatFieldUpdateOperationsInput | number
    actualAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TripBudgetUncheckedUpdateWithoutTripInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    estimatedAmount?: FloatFieldUpdateOperationsInput | number
    actualAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TripBudgetUncheckedUpdateManyWithoutTripInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    estimatedAmount?: FloatFieldUpdateOperationsInput | number
    actualAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TripMediaUpdateWithoutTripInput = {
    id?: StringFieldUpdateOperationsInput | string
    mediaType?: StringFieldUpdateOperationsInput | string
    mediaUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TripMediaUncheckedUpdateWithoutTripInput = {
    id?: StringFieldUpdateOperationsInput | string
    mediaType?: StringFieldUpdateOperationsInput | string
    mediaUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TripMediaUncheckedUpdateManyWithoutTripInput = {
    id?: StringFieldUpdateOperationsInput | string
    mediaType?: StringFieldUpdateOperationsInput | string
    mediaUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TripShareUpdateWithoutTripInput = {
    id?: StringFieldUpdateOperationsInput | string
    shareToken?: StringFieldUpdateOperationsInput | string
    shareType?: StringFieldUpdateOperationsInput | string
    sharedWithEmail?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    lastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TripShareUncheckedUpdateWithoutTripInput = {
    id?: StringFieldUpdateOperationsInput | string
    shareToken?: StringFieldUpdateOperationsInput | string
    shareType?: StringFieldUpdateOperationsInput | string
    sharedWithEmail?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    lastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TripShareUncheckedUpdateManyWithoutTripInput = {
    id?: StringFieldUpdateOperationsInput | string
    shareToken?: StringFieldUpdateOperationsInput | string
    shareType?: StringFieldUpdateOperationsInput | string
    sharedWithEmail?: NullableStringFieldUpdateOperationsInput | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    lastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TripVersionUpdateWithoutTripInput = {
    id?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    snapshotData?: StringFieldUpdateOperationsInput | string
    changeSummary?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TripVersionUncheckedUpdateWithoutTripInput = {
    id?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    snapshotData?: StringFieldUpdateOperationsInput | string
    changeSummary?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TripVersionUncheckedUpdateManyWithoutTripInput = {
    id?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    snapshotData?: StringFieldUpdateOperationsInput | string
    changeSummary?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StopActivityCreateManyTripStopInput = {
    id?: string
    activityId: string
    scheduledDate: Date | string
    scheduledTime?: string | null
    actualCost?: number | null
    notes?: string | null
    isCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type StopActivityUpdateWithoutTripStopInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledTime?: NullableStringFieldUpdateOperationsInput | string | null
    actualCost?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: ActivityUpdateOneRequiredWithoutStopActivitiesNestedInput
  }

  export type StopActivityUncheckedUpdateWithoutTripStopInput = {
    id?: StringFieldUpdateOperationsInput | string
    activityId?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledTime?: NullableStringFieldUpdateOperationsInput | string | null
    actualCost?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StopActivityUncheckedUpdateManyWithoutTripStopInput = {
    id?: StringFieldUpdateOperationsInput | string
    activityId?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledTime?: NullableStringFieldUpdateOperationsInput | string | null
    actualCost?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}